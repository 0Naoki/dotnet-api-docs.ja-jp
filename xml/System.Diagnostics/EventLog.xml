<Type Name="EventLog" FullName="System.Diagnostics.EventLog">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c7b0720d24124f7818c7801c79354a1bfa733467" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39888447" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventLog : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventLog extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.EventLog" />
  <TypeSignature Language="VB.NET" Value="Public Class EventLog&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventLog : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type EventLog = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
      <AttributeName>System.ComponentModel.DefaultEvent("EntryWritten")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Diagnostics.EventLogInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Represents an event log")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.EventLogInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Diagnostics.MonitoringDescription("EventLogDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Windows イベント ログとの対話を提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog> アクセスしたり、Windows イベント ログは、ソフトウェアまたはハードウェアの重要なイベントに関する情報を記録をカスタマイズできます。 使用して<xref:System.Diagnostics.EventLog>、既存のログからの読み取り、ログにエントリを書き込む、作成またはイベント ソースを削除する、ログを削除してログ エントリに対応します。 イベント ソースを作成するときに、新しいログを作成することもできます。  
  
> [!IMPORTANT]
>  この型は、<xref:System.IDisposable>インターフェイス。 型の使用が完了したら、直接的または間接的にそれを破棄する必要があります。 型の直接 dispose を呼び出してその<xref:System.IDisposable.Dispose%2A>メソッド、 `try` / `catch`ブロックします。 直接ことのない破棄する場合など、言語コンストラクトを使用して`using`(で C# の場合) または`Using`(Visual Basic) でします。 詳細については、"を使用して、オブジェクトを実装する IDisposable"のセクションを参照してください、<xref:System.IDisposable>インターフェイスに関するトピック。  
  
 個々 のイベント ログと、そのエントリへのアクセスを提供することに加えて、<xref:System.Diagnostics.EventLog>クラスでは、すべてのイベント ログのコレクションにアクセスすることができます。 使用することができます、`static`のメンバー<xref:System.Diagnostics.EventLog>ログを削除するログの一覧を取得、作成や、ソースの削除またはコンピューターに既に特定のソースが含まれるかどうかを確認します。  
  
 次の 3 つの既定のイベント ログがある: アプリケーション、システム、およびセキュリティ。 セキュリティ ログとは、読み取り専用です。 他のアプリケーションやサービスなど、Active Directory をインストールするには、追加のイベント ログがある場合があります。  
  
 セキュリティに関する考慮事項があるを使用する場合、<xref:System.Diagnostics.EventLog>クラス。 <xref:System.Diagnostics.EventLog> 必要があります<xref:System.Diagnostics.EventLogPermission>で .NET Framework 2.0 およびそれ以降のバージョンでは、特定のアクションまたは .NET Framework 1.0 および 1.1 で完全な信頼のアクセス許可。 お勧め<xref:System.Diagnostics.EventLogPermission>部分的に信頼されたコードに付与することです。  任意のイベント ログ オブジェクトを渡す必要がありますしないなど<xref:System.Diagnostics.EventLogEntryCollection>と<xref:System.Diagnostics.EventLogEntry>オブジェクトの信頼度の低いコード。 作成など、<xref:System.Diagnostics.EventLog>オブジェクトが、エントリの書き込み、および渡す、<xref:System.Diagnostics.EventLog>を読み取り、イベント ログに書き込む機能の発行などのアクションを実行するコードを使用するため、部分的に信頼されたコードにオブジェクトがセキュリティの問題を作成できますイベント ログ メッセージの別のアプリケーションの名前。  
  
 Windows Vista 以降、ユーザー アカウント制御 (UAC) は、ユーザーの資格情報を決定します。 ユーザーが組み込みの Administrators グループのメンバーである場合、そのユーザーには標準ユーザー アクセス トークンおよび管理者アクセス トークンの 2 つのランタイム アクセス トークンが割り当てられています。 既定では、ユーザーは標準ユーザー ロールに所属します。 セキュリティ ログにアクセスするコードを実行するには、最初に、資格情報を標準ユーザーから管理者に昇格させる必要があります。 これを行うアプリケーションのショートカット メニューを開き、アプリケーションを起動するときに (マウスを使用している場合は、アプリケーションのアイコンを右) に管理者として実行することを示すとします。  
  
 使用することができます<xref:System.Diagnostics.EventLog>イベント ビューアーのサーバーを表示できるカスタムのイベント ログを作成します。 使用して、<xref:System.Diagnostics.EventLog.RegisterDisplayName%2A>メソッドをイベント ビューアーでイベント ログのローカライズされた名前を表示します。 使用して、<xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>最大ログ サイズに達したときに、イベント ログの動作を構成する方法。  
  
 イベント ログからの読み取り、ログの名前を指定します (<xref:System.Diagnostics.EventLog.Log%2A>プロパティ) とサーバーのコンピューター名 (<xref:System.Diagnostics.EventLog.MachineName%2A>イベント ログのプロパティ。 ローカルのコンピューターでは、サーバー コンピューターの名前を指定しない場合は、"."と見なされます。 イベント ソースを指定する必要はありません (<xref:System.Diagnostics.EventLog.Source%2A>プロパティ)、ソースはログに書き込むのみ必要であるためです。 <xref:System.Diagnostics.EventLog.Entries%2A>プロパティはエントリのイベント ログの一覧が設定されます。  
  
 イベント ログに書き込み、指定するか、イベント ソースの作成 (<xref:System.Diagnostics.EventLog.Source%2A>プロパティ)。 新しいイベント ソースを作成するコンピューターの管理者の資格情報が必要です。 イベント ソースは、有効なエントリのソースとしてイベント ログに、アプリケーションを登録します。 イベント ソースを使用するには、一度に 1 つのログに書き込めません。 <xref:System.Diagnostics.EventLog.Source%2A>プロパティは、任意のランダムな文字列を指定できますが、名前は、コンピューター上の他のソースから個別である必要があります。 イベント ソースは、通常、アプリケーションまたは別の識別文字列の名前です。 複製を作成しようとしています。<xref:System.Diagnostics.EventLog.Source%2A>値は、例外をスローします。 ただし、1 つのイベント ログは、複数のソースを関連付けることができます。  
  
 イベント ログのイベント ソースに関連付けられた、<xref:System.Diagnostics.EventLog>インスタンスが存在しないと、新しいイベント ソースが作成されます。 Windows Vista 以降のイベント ソースまたは Windows Server 2003 を作成するには、管理者の資格情報があります。  
  
 この要件はセキュリティのログを含め、すべてのイベント ログを検索して、イベント ソースが一意であるかどうかを確認する必要があるためにです。 Windows Vista 以降、ユーザー権限がありません。 セキュリティ ログにアクセスするにはそのため、<xref:System.Security.SecurityException>がスローされます。  
  
> [!IMPORTANT]
>  イベント ソースを作成、削除する名前付きミュー テックスを使用して、基になるコードの同期が必要です。 高い特権を持つアプリケーションは、名前付きミュー テックスをロックする場合、作成、またはイベント ソースを削除しようとしています。 すると、アプリケーションは、ロックが解放されるまでの応答を停止します。 この問題を回避するには、決して付与<xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode>信頼されていないコードへのアクセスを許可します。 さらに、<xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode>アクセス許可は、可能性のあるにより、他のアクセス許可をバイパスすることし、信頼性の高いコードにのみ付与する必要があります。  
  
 アプリケーションとサービスは、アプリケーション ログまたはカスタムのログを書き込む必要があります。 デバイス ドライバーは、システム ログに書き込む必要があります。 明示的に設定しない場合、<xref:System.Diagnostics.EventLog.Log%2A>プロパティ、アプリケーション ログにイベント ログの既定値します。  
  
> [!NOTE]
>  登録済みのソースとしての書き込みアプリケーションを保護するために何もないです。  アプリケーションが与えられる場合<xref:System.Diagnostics.EventLogPermissionAccess.Write>アクセス許可は、コンピューターに登録されている任意の有効なソースのイベントを書き込むことです。  
  
 使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>と<xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッド、イベント ログにイベントを書き込みます。 イベントを書き込むイベント ソースを指定する必要があります。作成し、ソースと最初のエントリを書き込む前に、イベント ソースを構成する必要があります。  
  
 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録済みのイベント ソースの一覧とその構成を更新するオペレーティング システムまでの時間です。 場合は、オペレーティング システムは、イベント ソースの一覧を更新していないし、新しいソースを持つイベントの書き込み、書き込み操作は失敗します。 使用して新しいソースを構成することができます、<xref:System.Diagnostics.EventLogInstaller>オブジェクトまたは<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド。 新しいイベント ソースを作成するコンピューターの管理者の資格情報が必要です。  
  
 各ソースは、一度に 1 つだけのイベント ログに書き込むことができます。ただし、アプリケーションでは、複数のソースを使用して、複数のイベント ログに書き込みます。 たとえば、アプリケーションでは、別のイベント ログまたは別のリソース ファイル用に構成された複数のソースを必要があります。 既存のソースの構成の詳細を変更するには、ソースを削除し、新しい構成を使用して作成する必要があります。 他のアプリケーションやコンポーネントは、既存のソースを使用する場合は、既存のソースを削除する代わりに更新された構成と新しいソースを作成します。  
  
 イベント ソースは、イベント カテゴリ、メッセージ文字列のローカライズされたリソースを登録できます。 アプリケーションでは、実際の文字列値を指定する代わりに、リソース識別子を使用して、イベント ログ エントリを書き込むことができます。 参照してください、<xref:System.Diagnostics.EventLogInstaller>と<xref:System.Diagnostics.EventSourceCreationData>リソース ファイル、ソースを構成する方法の詳細についてはクラスです。  
  
 アプリケーションがイベント ログに直接文字列値を書き込む場合は、リソース、ソース ファイルのプロパティを設定するはありません。 ソースは、ローカライズされたエントリを書き込むか、または直接の文字列を書き込むように構成する必要があります。 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルでは、1 つのソースを構成およびでは、そのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>メソッドをイベント ログのリソース識別子を使用してエントリを書き込みます。 リソースのファイルがない場合、別のソースを作成しでそのソースを使用し、<xref:System.Diagnostics.EventLog.WriteEntry%2A>そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
 イベントを記述する場合は、メッセージ文字列またはメッセージ文字列のリソース識別子を少なくとも指定する必要があります。 その他のイベント プロパティは省略可能です。 省略可能なイベントの設定の例については、次のとおりです。  
  
-   設定することができます、<xref:System.Diagnostics.EventLogEntryType>エントリのイベント ビューアーを表示するアイコンを指定します。  
  
-   アプリケーションは、イベントをフィルター処理するためのカテゴリを使用する場合は、イベントのカテゴリの識別子を指定できます。  
  
-   特定のイベントに追加情報を関連付ける場合は、イベント エントリにバイナリ データをアタッチできます。  
  
> [!IMPORTANT]
>  イベントのログ記録は、ディスク領域、プロセッサ時間、およびその他のシステム リソースを消費します。 重要な情報のみをログに重要です。 エラー パスにイベント ログの呼び出しを配置するではなく、メインのコード パスでので、しないパフォーマンスに悪影響をお勧めします。  
  
 インスタンスの初期プロパティ値の一覧については<xref:System.Diagnostics.EventLog>を参照してください、<xref:System.Diagnostics.EventLog.%23ctor%2A>コンス トラクター。  
  
   
  
## Examples  
 次の例では、イベント ソースを作成する`MySource`が既に存在し、イベント ログにエントリを書き込みかどうか`MyNewLog`します。  
  
> [!NOTE]
>  Windows Vista 以降、管理者としてこのアプリケーションを実行する必要があります。  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.EventLogInstaller" />
    <altmember cref="T:System.Diagnostics.EventLogEntry" />
    <altmember cref="T:System.Diagnostics.EntryWrittenEventArgs" />
    <altmember cref="T:System.ServiceProcess.ServiceBase" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Diagnostics.EventLog" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Diagnostics.EventLog" /> クラスの新しいインスタンスを初期化します。 このインスタンスは、ログとは関連付けられません。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出しの前に<xref:System.Diagnostics.EventLog.WriteEntry%2A>、指定、<xref:System.Diagnostics.EventLog.Source%2A>のプロパティ、<xref:System.Diagnostics.EventLog>インスタンス。 読み取りのみを行う場合<xref:System.Diagnostics.EventLog.Entries%2A>ログからを指定できますのみ、<xref:System.Diagnostics.EventLog.Log%2A>と<xref:System.Diagnostics.EventLog.MachineName%2A>プロパティ。  
  
> [!NOTE]
>  指定しない場合、 <xref:System.Diagnostics.EventLog.MachineName%2A>、ローカル コンピューター (".") と見なされます。  
  
 次の表のインスタンスの初期プロパティ値<xref:System.Diagnostics.EventLog>します。  
  
|プロパティ|初期値|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|空の文字列 ("")。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|空の文字列 ("")。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|ローカル コンピューター (".")。|  
  
   
  
## Examples  
 次の例では、ソース`MySource`が存在しない場合、イベント ログにエントリを書き込みます`MyNewLog`します。  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を書き込む。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog logName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">ローカル コンピューター上のログの名前。</param>
        <summary>
          <see cref="T:System.Diagnostics.EventLog" /> クラスの新しいインスタンスを初期化します。 ローカル コンピューター上のログにインスタンスを関連付けます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードの設定、<xref:System.Diagnostics.EventLog.Log%2A>プロパティを`logName`パラメーター。 呼び出しの前に<xref:System.Diagnostics.EventLog.WriteEntry%2A>、指定、<xref:System.Diagnostics.EventLog.Source%2A>のプロパティ、<xref:System.Diagnostics.EventLog>インスタンス。 読み取りのみを行う場合<xref:System.Diagnostics.EventLog.Entries%2A>ログからを指定できますのみ、<xref:System.Diagnostics.EventLog.Log%2A>と<xref:System.Diagnostics.EventLog.MachineName%2A>プロパティ。  
  
> [!NOTE]
>  指定しない場合、 <xref:System.Diagnostics.EventLog.MachineName%2A>、ローカル コンピューター (".") と見なされます。 このコンス トラクターのオーバー ロードを指定します、<xref:System.Diagnostics.EventLog.Log%2A>プロパティが変更できます読み取る前に、<xref:System.Diagnostics.EventLog.Entries%2A>プロパティ。  
  
 ソースで指定した場合、<xref:System.Diagnostics.EventLog.Source%2A>プロパティは、コンピューターでは、後続の呼び出しでは、他のソースから<xref:System.Diagnostics.EventLog.WriteEntry%2A>が既に存在しない場合は、指定の名前を持つログを作成します。  
  
 次の表のインスタンスの初期プロパティ値<xref:System.Diagnostics.EventLog>します。  
  
|プロパティ|初期値|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|空の文字列 ("")。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` パラメーター。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|ローカル コンピューター (".")。|  
  
   
  
## Examples  
 次の例では、ローカル コンピューターの"myNewLog"、イベント ログにエントリを読み取ります。  
  
 [!code-cpp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">ログ名が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">ログ名が無効です。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を書き込む。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string * string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog (logName, machineName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">指定したコンピューター上のログの名前。</param>
        <param name="machineName">ログが存在するコンピューター。</param>
        <summary>
          <see cref="T:System.Diagnostics.EventLog" /> クラスの新しいインスタンスを初期化します。 指定したコンピューター上のログにインスタンスを関連付けます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードの設定、<xref:System.Diagnostics.EventLog.Log%2A>プロパティを`logName`パラメーターおよび<xref:System.Diagnostics.EventLog.MachineName%2A>プロパティを`machineName`パラメーター。 呼び出しの前に<xref:System.Diagnostics.EventLog.WriteEntry%2A>、指定、<xref:System.Diagnostics.EventLog.Source%2A>のプロパティ、<xref:System.Diagnostics.EventLog>します。 読み取りのみを行う場合<xref:System.Diagnostics.EventLog.Entries%2A>ログからを指定できますのみ、<xref:System.Diagnostics.EventLog.Log%2A>と<xref:System.Diagnostics.EventLog.MachineName%2A>プロパティ。  
  
> [!NOTE]
>  このコンス トラクターのオーバー ロードを指定します、<xref:System.Diagnostics.EventLog.Log%2A>と<xref:System.Diagnostics.EventLog.MachineName%2A>が、プロパティは読み取り前にいずれかで変更できます、<xref:System.Diagnostics.EventLog.Entries%2A>プロパティ。  
  
 次の表のインスタンスの初期プロパティ値<xref:System.Diagnostics.EventLog>します。  
  
|プロパティ|初期値|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|空の文字列 ("")。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` パラメーター。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|`machineName` パラメーター。|  
  
   
  
## Examples  
 次の例では、コンピューター"myServer"上"myNewLog"、イベント ログにエントリを読み取ります。  
  
 [!code-cpp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">ログ名が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">ログ名が無効です。  
  
- または - 
コンピューター名が無効です。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を書き込む。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName, string source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName, string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String, source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName, System::String ^ source);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string * string * string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog (logName, machineName, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">指定したコンピューター上のログの名前。</param>
        <param name="machineName">ログが存在するコンピューター。</param>
        <param name="source">イベント ログ エントリのソース。</param>
        <summary>
          <see cref="T:System.Diagnostics.EventLog" /> クラスの新しいインスタンスを初期化します。 指定したコンピューター上のログにインスタンスを関連付け、指定したソースを作成するか、または <see cref="T:System.Diagnostics.EventLog" /> に割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンス トラクターの設定、<xref:System.Diagnostics.EventLog.Log%2A>プロパティを`logName`パラメーター、<xref:System.Diagnostics.EventLog.MachineName%2A>プロパティを`machineName`パラメーター、および<xref:System.Diagnostics.EventLog.Source%2A>プロパティを`source`パラメーター。 <xref:System.Diagnostics.EventLog.Source%2A>イベント ログに書き込むときに、プロパティが必要です。 ただし、イベント ログのみからの読み取りのみの場合、<xref:System.Diagnostics.EventLog.Log%2A>と<xref:System.Diagnostics.EventLog.MachineName%2A>である限り、サーバー上のイベント ログでは、既に関連付けられているソースを持つ) は、プロパティが必要です。 イベント ログからの読み取りのみの場合は、コンス トラクターの別のオーバー ロードがありますで十分です。  
  
 次の表のインスタンスの初期プロパティ値<xref:System.Diagnostics.EventLog>します。  
  
|プロパティ|初期値|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|`source` パラメーター。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` パラメーター。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|`machineName` パラメーター。|  
  
   
  
## Examples  
 次の例では、ソース""を使用して、ローカル コンピューターで"MyNewLog"イベント ログにエントリを書き込みます。  
  
 [!code-cpp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">ログ名が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">ログ名が無効です。  
  
- または - 
コンピューター名が無効です。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を書き込む。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="eventLog.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>フォームまたは別のコンポーネントで使用される <see cref="T:System.Diagnostics.EventLog" /> の初期化を開始します。 初期化は実行時に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]デザイン環境では、このメソッドを使用して、フォームまたは別のコンポーネントで使用されるコンポーネントの初期化を開始します。 <xref:System.Diagnostics.EventLog.EndInit%2A>メソッドは、初期化を終了します。 使用して、<xref:System.Diagnostics.EventLog.BeginInit%2A>と<xref:System.Diagnostics.EventLog.EndInit%2A>メソッドのコントロールは完全に初期化される前に使用を禁止します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Diagnostics.EventLog" /> は、既に初期化されています。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を書き込む。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="eventLog.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>イベント ログからすべてのエントリを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント ログには、格納できるエントリの数を決定する最大サイズが設定されます。 イベント ログがいっぱいになった場合は新しいイベント情報の記録を停止または以前のエントリが上書きします。 イベントの記録を停止する場合は、既存のエントリのログを消去し、イベントの記録をもう一度起動することをこのメソッドを使用できます。 イベント ログ エントリを消去するログが存在するコンピューターに管理者のアクセス許可が必要です。  
  
 <xref:System.Diagnostics.EventLog.Clear%2A> イベント ログを閉じて新しいを取得しますが、ハンドルを読み書きイベント ハンドルを解放します。 イベント ログを再度開かれます。 既存のイベントと共にメソッド呼び出しの後に受信したイベントはオフにします。  
  
   
  
## Examples  
 次の例では、イベント ログを消去します。  
  
> [!CAUTION]
>  アプリケーション、システム、セキュリティ、およびその他の非カスタム ログは、重要な情報を含めることができますので、このコード例を実行する前にカスタム ログを指定することを確認します。 この例では、カスタム ログを削除します。`myNewLog`します。  
  
 [!code-cpp[Classic EventLog.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント ログが正常に消去されませんでした。  
  
- または - 
ログを開くことができません。 Windows のエラー コードは使用できません。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Log" /> プロパティの値が指定されていません。 ログ名が空の文字列でないことを確認してください。</exception>
        <exception cref="T:System.InvalidOperationException">ログが存在しません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="eventLog.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>イベント ログを閉じ、読み取りハンドルと書き込みハンドルを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.Close%2A>メソッドが呼び出されるプロテクトによって<xref:System.ComponentModel.Component.Dispose%2A>メソッド。 呼び出す必要はありません<xref:System.Diagnostics.EventLog.Close%2A>呼び出す前に<xref:System.ComponentModel.Component.Dispose%2A>します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント ログの読み取りハンドルまたは書き込みハンドルが解放されませんでした。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を書き込む。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>システム上の特定のログにイベント情報を書き込むことができるようにアプリケーションを設定します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (System.Diagnostics.EventSourceCreationData sourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(class System.Diagnostics.EventSourceCreationData sourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (sourceData As EventSourceCreationData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::Diagnostics::EventSourceCreationData ^ sourceData);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : System.Diagnostics.EventSourceCreationData -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource sourceData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceData" Type="System.Diagnostics.EventSourceCreationData" />
      </Parameters>
      <Docs>
        <param name="sourceData">イベント ソースおよび対象のイベント ログの構成プロパティ。</param>
        <summary>イベント ソースおよび対応するイベント ログに指定された構成プロパティを使用して、ローカライズされたイベント メッセージを書き込むための有効なイベント ソースを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用すると、ローカル コンピューターまたはリモート コンピューター上のイベント ログにエントリを書き込むための新しいソースを構成できます。 このメソッドを使用すると、イベント ログから読み取る必要はありません。  
  
 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッドは、入力を使用して`sourceData` <xref:System.Diagnostics.EventSourceCreationData.Source%2A>、<xref:System.Diagnostics.EventSourceCreationData.LogName%2A>と<xref:System.Diagnostics.EventSourceCreationData.MachineName%2A>新しいソースとその関連のイベント ログのターゲット コンピューター上のレジストリ値を作成するプロパティ。 新しいソース名には、既存のソース名またはターゲット コンピューター上の既存のイベント ログ名を一致ことはできません。 場合、<xref:System.Diagnostics.EventSourceCreationData.LogName%2A>プロパティが設定されていない、アプリケーション イベント ログのソースが登録されています。 場合、<xref:System.Diagnostics.EventSourceCreationData.MachineName%2A>が、ソースをローカル コンピューターの登録が設定されています。  
  
> [!NOTE]
>  Windows Vista 以降のイベント ソースまたは Windows Server 2003 を作成、管理特権が必要です。  
>   
>  この要件の理由では、セキュリティを含むすべてのイベント ログを検索して、イベント ソースが一意かどうかを確認する必要があります。 Windows Vista 以降、ユーザー権限がありません。 セキュリティ ログにアクセスするにはそのため、<xref:System.Security.SecurityException>がスローされます。  
>   
>  Windows Vista 以降、ユーザー アカウント制御 (UAC) は、ユーザーの権限を決定します。 ユーザーが組み込みの Administrators グループのメンバーである場合、そのユーザーには標準ユーザー アクセス トークンおよび管理者アクセス トークンの 2 つのランタイム アクセス トークンが割り当てられています。 既定では、ユーザーは標準ユーザー ロールに所属します。 セキュリティ ログにアクセスするコードを実行するには標準ユーザーから管理者に、特権を昇格する必要があります。 この操作は、アプリケーションの起動時にアプリケーション アイコンを右クリックし、管理者として実行することを指定して行うことができます。  
  
 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>と<xref:System.Diagnostics.EventLog.WriteEntry%2A>イベント ログにイベントを書き込みます。 イベントを書き込むイベント ソースを指定する必要があります。作成し、ソースと最初のエントリを書き込む前に、イベント ソースを構成する必要があります。  
  
 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録済みのイベント ソースの一覧とその構成を更新するオペレーティング システムまでの時間です。 オペレーティング システムでは、イベントのソースの一覧は更新されていない場合は、書き込み操作は失敗、新しいソースを持つイベントを記述しようとしました。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド。 新しいイベント ソースを作成するコンピューターの管理者権限が必要です。  
  
 既存のイベント ログまたは新しいイベント ログのイベント ソースを作成することができます。 新しいイベント ログの新しいソースを作成するときに、システムがそのログのソースを登録しますが、最初のエントリが書き込まれるまで、ログは作成されません。  
  
 オペレーティング システムは、イベント ログをファイルとして格納します。 使用すると<xref:System.Diagnostics.EventLogInstaller>または<xref:System.Diagnostics.EventLog.CreateEventSource%2A>指定したコンピューター上の %SystemRoot%\System32\Config ディレクトリに新しいイベント ログを作成する、関連付けられたファイルが格納されています。 最初の 8 文字を付加して、ファイル名が設定されて、 <xref:System.Diagnostics.EventLog.Log%2A> ".evt"ファイル名拡張子を持つプロパティです。  
  
 同時に、各ソースは 1 つだけのイベント ログに書き込むだけできます。ただし、アプリケーションでは、複数のソースを使用して、複数のイベント ログに書き込みます。 たとえば、アプリケーションでは、別のイベント ログまたは別のリソース ファイル用に構成された複数のソースを必要があります。  
  
 イベント ソースは、イベント カテゴリ、メッセージ文字列のローカライズされたリソース ファイルを登録できます。 アプリケーションでは、実際の文字列を指定するのではなく、リソースの識別子を使用してイベント ログ エントリを書き込むことができます。 イベント ビューアーでは、リソース識別子を使用して、検索し、現在の言語設定に基づいてローカライズされたリソース ファイルから、対応する文字列を表示します。 イベント カテゴリ、メッセージ、およびパラメーターの挿入文字列に個別のファイルを登録する、または 3 つすべての種類の文字列に同じリソース ファイルを登録することができます。 使用して、 <xref:System.Diagnostics.EventSourceCreationData.CategoryCount%2A>、 <xref:System.Diagnostics.EventSourceCreationData.CategoryResourceFile%2A>、 <xref:System.Diagnostics.EventSourceCreationData.MessageResourceFile%2A>、および<xref:System.Diagnostics.EventSourceCreationData.ParameterResourceFile%2A>ローカライズされたエントリをイベント ログに書き込むソースを構成するプロパティ。 アプリケーションがイベント ログに直接文字列値を書き込む場合は、これらのプロパティを設定する必要はありません。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接の文字列を書き込むように構成する必要があります。 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルでは、1 つのソースを構成およびでは、そのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>メソッドをイベント ログのリソース識別子を使用してエントリを書き込みます。 リソースのファイルがない場合、別のソースを作成しでそのソースを使用し、<xref:System.Diagnostics.EventLog.WriteEntry%2A>そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
 既存のソースの構成の詳細を変更するには、ソースを削除し、新しい構成を使用して作成する必要があります。 他のアプリケーションやコンポーネントは、既存のソースを使用する場合は、既存のソースを削除するのではなく、更新された構成で新しいソースを作成します。  
  
> [!NOTE]
>  場合は、ソースは、イベント ログの構成し、別のイベント ログの再設定、変更を反映するには、コンピューターを再起動する必要があります。  
  
   
  
## Examples  
 次の例は、イベント ソースが名前付きかどうかを判断`SampleApplicationSource`ローカル コンピューターに登録します。 イベント ソースが存在しない場合、例は、ソースのメッセージ リソース ファイルを設定し、新しいイベント ソースを作成します。 最後に、リソース識別子の値を使用して、イベント ログのローカライズされた表示名の設定例では、`DisplayNameMsgId`とリソース ファイルのパスで`messageFile`します。  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 EventLogMsgs.dll リソース ライブラリに組み込まれている次のメッセージのテキスト ファイルを使用します。 メッセージのテキスト ファイルは、メッセージ リソース ファイルの作成元のソースです。 メッセージのテキスト ファイルでは、リソース識別子とカテゴリ、イベント メッセージ、およびパラメーターの挿入文字列のテキストを定義します。 具体的には、イベント ログのローカライズされた名前のリソース識別子 5001 が定義されます。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceData" /> で指定されたコンピューター名が無効です。  
  
\- または 
<paramref name="sourceData" /> で指定されたソース名が <see langword="null" /> です。  
  
\- または 
<paramref name="sourceData" /> で指定されたログ名が無効です。 イベント ログ名は、印字可能な文字で構成されている必要があります。文字 '*'、'?'、または '\\' を含めないでください。  
  
\- または 
<paramref name="sourceData" /> で指定されたログ名は、ユーザー ログの作成には無効です。 イベント ログ名 AppEvent、SysEvent、および SecEvent は、システムで使用するために予約されています。  
  
\- または 
ログ名が既存のイベント ソース名に一致します。  
  
\- または 
<paramref name="sourceData" /> で指定されたソース名は、254 文字を超えるレジストリ キーのパスになります。  
  
\- または 
<paramref name="sourceData" /> で指定されたログ名の最初の 8 文字が一意ではありません。  
  
\- または 
<paramref name="sourceData" /> で指定されたソース名は既に登録されています。  
  
\- または 
<paramref name="sourceData" /> で指定されたソース名が既存のイベント ログ名に一致しません。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceData" /> は <see langword="null" />です。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventSourceCreationData" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLogInstaller" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource (source, logName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">アプリケーションをローカル コンピューター上に登録するときに使用するソース名。</param>
        <param name="logName">ソースのエントリが書き込まれるログの名前。 指定できる値は、"Application"、"System"、またはカスタム イベント ログです。</param>
        <summary>ローカル コンピューター上のログにエントリを書き込むための有効なイベント ソースとして指定したソース名を設定します。 また、このメソッドによってローカル コンピューター上に新しいカスタム ログを作成することもできます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 カスタム ログを作成または作成し、登録するこのオーバー ロードを使用して、<xref:System.Diagnostics.EventLog.Source%2A>ローカル コンピューターの既存のログ。  
  
 場合`logName`は`null`または空の文字列 ("") を呼び出すと<xref:System.Diagnostics.EventLog.CreateEventSource%2A>ログの既定値は、アプリケーション ログ。 システムがカスタム ログを作成し、として、アプリケーションを登録します。 ローカル コンピューターのログが存在しない場合、<xref:System.Diagnostics.EventLog.Source%2A>そのログ。  
  
> [!NOTE]
>  Windows Vista 以降のイベント ソースまたは Windows Server 2003 を作成、管理特権が必要です。  
>   
>  この要件の理由では、セキュリティを含むすべてのイベント ログを検索して、イベント ソースが一意かどうかを確認する必要があります。 Windows Vista 以降、ユーザー権限がありません。 セキュリティ ログにアクセスするにはそのため、<xref:System.Security.SecurityException>がスローされます。  
>   
>  Windows Vista 以降では、ユーザー アカウント制御 (UAC: User Account Control) でユーザーの権限が決定されます。 ユーザーが組み込みの Administrators グループのメンバーである場合、そのユーザーには標準ユーザー アクセス トークンおよび管理者アクセス トークンの 2 つのランタイム アクセス トークンが割り当てられています。 既定では、ユーザーは標準ユーザー ロールに所属します。 セキュリティ ログにアクセスするコードを実行するには標準ユーザーから管理者に、特権を昇格する必要があります。 この操作は、アプリケーションの起動時にアプリケーション アイコンを右クリックし、管理者として実行することを指定して行うことができます。  
  
 のみ、イベント ログに書き込みを行う場合は、イベント ソースを作成する必要があります。 イベント ログにエントリを書き込む前に、有効なイベントのソースとして、イベント ログにイベント ソースを登録する必要があります。 ログ エントリを記述するときに、システムを使用して、<xref:System.Diagnostics.EventLog.Source%2A>エントリを配置するための適切なログを検索します。 かどうか、イベント ログを読んでいるを指定するか、 <xref:System.Diagnostics.EventLog.Source%2A>、または<xref:System.Diagnostics.EventLog.Log%2A>と<xref:System.Diagnostics.EventLog.MachineName%2A>します。  
  
> [!NOTE]
>  指定する必要はありません、<xref:System.Diagnostics.EventLog.MachineName%2A>ローカル コンピューター上のログに接続している場合。 指定しない場合、<xref:System.Diagnostics.EventLog.MachineName%2A>を読み取るときに、ログから、ローカル コンピューター (".") と見なされます。  
  
 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>と<xref:System.Diagnostics.EventLog.WriteEntry%2A>イベント ログにイベントを書き込みます。 イベントを書き込むイベント ソースを指定する必要があります。作成し、ソースと最初のエントリを書き込む前に、イベント ソースを構成する必要があります。  
  
 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録済みのイベント ソースの一覧とその構成を更新するオペレーティング システムまでの時間です。 オペレーティング システムでは、イベントのソースの一覧は更新されていない場合は、書き込み操作は失敗、新しいソースを持つイベントを記述しようとしました。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド。 新しいイベント ソースを作成するコンピューターの管理者権限が必要です。  
  
 既存のイベント ログまたは新しいイベント ログのイベント ソースを作成することができます。 新しいイベント ログの新しいソースを作成するときに、システムがそのログのソースを登録しますが、最初のエントリが書き込まれるまで、ログは作成されません。  
  
 オペレーティング システムは、イベント ログをファイルとして格納します。 使用すると<xref:System.Diagnostics.EventLogInstaller>または<xref:System.Diagnostics.EventLog.CreateEventSource%2A>指定したコンピューター上の %SystemRoot%\System32\Config ディレクトリに新しいイベント ログを作成する、関連付けられたファイルが格納されています。 最初の 8 文字を付加して、ファイル名が設定されて、 <xref:System.Diagnostics.EventLog.Log%2A> ".evt"ファイル名拡張子を持つプロパティです。  
  
 ソースは、ローカル コンピューター上で一意である必要があります。新しいソース名には、既存のソース名または既存のイベント ログ名を一致ことはできません。 各ソースは、一度に 1 つだけのイベント ログに書き込むことができます。ただし、アプリケーションでは、複数のソースを使用して、複数のイベント ログに書き込みます。 たとえば、アプリケーションでは、別のイベント ログまたは別のリソース ファイル用に構成された複数のソースを必要があります。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接の文字列を書き込むように構成する必要があります。 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルでは、1 つのソースを構成およびでは、そのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>メソッドをイベント ログのリソース識別子を使用してエントリを書き込みます。 リソースのファイルがない場合、別のソースを作成しでそのソースを使用し、<xref:System.Diagnostics.EventLog.WriteEntry%2A>そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
 既存のソースの構成の詳細を変更するには、ソースを削除し、新しい構成を使用して作成する必要があります。 他のアプリケーションやコンポーネントは、既存のソースを使用する場合は、既存のソースを削除するのではなく、更新された構成で新しいソースを作成します。  
  
> [!NOTE]
>  ソースはログに既にマップされて、新しいログにマッピングする場合は、変更を反映するには、コンピューターを再起動する必要があります。  
  
   
  
## Examples  
 次の例では、ソース`MySource`が存在しない場合、イベント ログにエントリを書き込みます`MyNewLog`します。  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> が空の文字列 ("") または <see langword="null" />  
  
\- または 
 <paramref name="logName" /> が有効なイベント ログ名ではありません。 イベント ログ名は、印字可能な文字で構成されている必要があります。文字 '*'、'?'、または '\\' を含めないでください。  
  
\- または 
 <paramref name="logName" /> はユーザー ログの作成に有効ではありません。 イベント ログ名 AppEvent、SysEvent、および SecEvent は、システムで使用するために予約されています。  
  
\- または 
ログ名が既存のイベント ソース名に一致します。  
  
\- または 
ソース名は、254 文字を超えるレジストリ キーのパスになります。  
  
\- または 
<paramref name="logName" /> の最初の 8 文字が既存のイベント ログ名の最初の 8 文字に一致します。  
  
\- または 
ローカル コンピューター上に既にソースが存在するため、ソースを登録できません。  
  
\- または 
ソース名が既存のイベント ログ名に一致します。</exception>
        <exception cref="T:System.InvalidOperationException">ローカル コンピューター上のイベント ログのレジストリ キーを開けませんでした。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : string * string * string -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource (source, logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("use CreateEventSource(EventSourceCreationData) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("This method has been deprecated.  Please use System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData sourceData) instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">アプリケーションを指定されたコンピューターに登録するために使用されるソース。</param>
        <param name="logName">ソースのエントリが書き込まれるログの名前。 指定できる値は、"Application"、"System"、またはカスタム イベント ログです。 値を指定しなかった場合、<c>logName</c> は既定によりアプリケーションに設定されます。</param>
        <param name="machineName">このイベント ソースを登録するコンピューターの名前。ローカル コンピューターの場合は "."。</param>
        <summary>指定したコンピューター上のログにエントリを書き込むための有効なイベント ソースとして指定したソース名を設定します。 このメソッドを使用して、指定したコンピューター上に新しいカスタム ログを作成することもできます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 カスタム ログを作成または作成し、登録するこのオーバー ロードを使用して、<xref:System.Diagnostics.EventLog.Source%2A>指定したコンピューター上の既存のログ。  
  
 場合`logName`は`null`または空の文字列 ("") を呼び出すと<xref:System.Diagnostics.EventLog.CreateEventSource%2A>ログの既定値は、アプリケーション ログ。 システムがカスタム ログを作成し、として、アプリケーションを登録します。 指定したコンピューター上にログが存在しない場合、<xref:System.Diagnostics.EventLog.Source%2A>そのログ。  
  
 のみ、イベント ログに書き込みを行う場合は、イベント ソースを作成する必要があります。 イベント ログにエントリを書き込む前に、有効なイベントのソースとして、イベント ログにイベント ソースを登録する必要があります。 ログ エントリを記述するときに、システムを使用して、<xref:System.Diagnostics.EventLog.Source%2A>エントリを配置するための適切なログを検索します。 かどうか、イベント ログを読んでいるを指定するか、 <xref:System.Diagnostics.EventLog.Source%2A>、または<xref:System.Diagnostics.EventLog.Log%2A>と<xref:System.Diagnostics.EventLog.MachineName%2A>します。  
  
> [!NOTE]
>  Windows Vista 以降のイベント ソースまたは Windows Server 2003 を作成、管理特権が必要です。  
>   
>  この要件の理由では、セキュリティを含むすべてのイベント ログを検索して、イベント ソースが一意かどうかを確認する必要があります。 ユーザーは、セキュリティ ログにアクセスする権限はありません Windows Vista 以降では、そのため、<xref:System.Security.SecurityException>がスローされます。  
>   
>  Windows Vista 以降では、ユーザー アカウント制御 (UAC: User Account Control) でユーザーの権限が決定されます。 ユーザーが組み込みの Administrators グループのメンバーである場合、そのユーザーには標準ユーザー アクセス トークンおよび管理者アクセス トークンの 2 つのランタイム アクセス トークンが割り当てられています。 既定では、ユーザーは標準ユーザー ロールに所属します。 セキュリティ ログにアクセスするコードを実行するには標準ユーザーから管理者に、特権を昇格する必要があります。 この操作は、アプリケーションの起動時にアプリケーション アイコンを右クリックし、管理者として実行することを指定して行うことができます。  
  
 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>と<xref:System.Diagnostics.EventLog.WriteEntry%2A>イベント ログにイベントを書き込みます。 イベントを書き込むイベント ソースを指定する必要があります。作成し、ソースと最初のエントリを書き込む前に、イベント ソースを構成する必要があります。  
  
 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録済みのイベント ソースの一覧とその構成を更新するオペレーティング システムまでの時間です。 オペレーティング システムでは、イベントのソースの一覧は更新されていない場合は、書き込み操作は失敗、新しいソースを持つイベントを記述しようとしました。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド。 新しいイベント ソースを作成するコンピューターの管理者権限が必要です。  
  
 既存のイベント ログまたは新しいイベント ログのイベント ソースを作成することができます。 新しいイベント ログの新しいソースを作成するときに、システムがそのログのソースを登録しますが、最初のエントリが書き込まれるまで、ログは作成されません。  
  
 オペレーティング システムは、イベント ログをファイルとして格納します。 使用すると<xref:System.Diagnostics.EventLogInstaller>または<xref:System.Diagnostics.EventLog.CreateEventSource%2A>指定したコンピューター上の %SystemRoot%\System32\Config ディレクトリに新しいイベント ログを作成する、関連付けられたファイルが格納されています。 最初の 8 文字を付加して、ファイル名が設定されて、 <xref:System.Diagnostics.EventLog.Log%2A> ".evt"ファイル名拡張子を持つプロパティです。  
  
 ソースは、ローカル コンピューター上で一意である必要があります。新しいソース名には、既存のソース名または既存のイベント ログ名を一致ことはできません。 各ソースは、一度に 1 つだけのイベント ログに書き込むことができます。ただし、アプリケーションでは、複数のソースを使用して、複数のイベント ログに書き込みます。 たとえば、アプリケーションでは、別のイベント ログまたは別のリソース ファイル用に構成された複数のソースを必要があります。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接の文字列を書き込むように構成する必要があります。 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルでは、1 つのソースを構成およびでは、そのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>メソッドをイベント ログのリソース識別子を使用してエントリを書き込みます。 リソースのファイルがない場合、別のソースを作成しでそのソースを使用し、<xref:System.Diagnostics.EventLog.WriteEntry%2A>そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
 既存のソースの構成の詳細を変更するには、ソースを削除し、新しい構成を使用して作成する必要があります。 他のアプリケーションやコンポーネントは、既存のソースを使用する場合は、既存のソースを削除するのではなく、更新された構成で新しいソースを作成します。  
  
> [!NOTE]
>  ソースはログに既にマップされて、新しいログにマッピングする場合は、変更を反映するには、コンピューターを再起動する必要があります。  
  
   
  
## Examples  
 次の例では、ソースを作成します`MySource`コンピューターの`MyServer`、イベント ログにエントリを書き込み、`MyNewLog`します。  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> が有効なコンピューター名ではありません。  
  
\- または 
 <paramref name="source" /> が空の文字列 ("") または <see langword="null" />  
  
\- または 
 <paramref name="logName" /> が有効なイベント ログ名ではありません。 イベント ログ名は、印字可能な文字で構成されている必要があります。文字 '*'、'?'、または '\\' を含めないでください。  
  
\- または 
 <paramref name="logName" /> はユーザー ログの作成に有効ではありません。 イベント ログ名 AppEvent、SysEvent、および SecEvent は、システムで使用するために予約されています。  
  
\- または 
ログ名が既存のイベント ソース名に一致します。  
  
\- または 
ソース名は、254 文字を超えるレジストリ キーのパスになります。  
  
\- または 
<paramref name="logName" /> の最初の 8 文字が指定したコンピューター上の既存のイベント ログ名の最初の 8 文字に一致します。  
  
\- または 
指定したコンピューター上に既にソースが存在するため、ソースを登録できません。  
  
\- または 
ソース名が既存のイベント ソース名に一致します。</exception>
        <exception cref="T:System.InvalidOperationException">指定したコンピューター上のイベント ログのレジストリ キーを開けませんでした。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ログ リソースを削除します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Diagnostics.EventLog.Delete logName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">削除するログの名前。 指定できる値は、アプリケーション、セキュリティ、システム、およびコンピューター上の任意のカスタム イベント ログです。</param>
        <summary>ローカル コンピューターからイベント ログを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 削除するログは、ローカル コンピューター上には、このメソッドを使用します。 適切なレジストリ権限が与えられていれば、コンピューター上のすべてのログを削除できます。  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> 指定されたログを削除します。 `logName` 、ローカル コンピューターから。 ソースのみをログに登録されているを削除する場合は、呼び出す<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>します。 ログ エントリを削除する場合は、呼び出す<xref:System.Diagnostics.EventLog.Clear%2A>します。 <xref:System.Diagnostics.EventLog.Delete%2A> <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>は`static`メソッド、クラス自体を呼び出すことができるようにします。 新しいインスタンスを作成する必要はありません<xref:System.Diagnostics.EventLog>をいずれかのメソッドを呼び出します。  
  
 <xref:System.Diagnostics.EventLog.Delete%2A>メソッドが最初に、ログの内容を保持するファイルを削除します。 レジストリにアクセスし、そのログに登録されているすべてのイベント ソースを削除します。 その後の時点のログを再作成する場合、再利用する場合は、ここでも、イベント ソースを登録してください。 イベント ソースを登録しないし、ログ名を指定せず、他のユーザーがイベント ソースに書き込みは、アプリケーション イベント ログでイベント ソースが作成されます。 そのため、以前に削除して再作成するログ エントリを書き込むことはアプリケーションは、アプリケーション ログに書き込む代わりに、イベント ソースが現在含まれています。  
  
> [!NOTE]
>  イベント ログを再作成すると、困難なプロセスを指定できます。 システムで作成されたイベント ログで、アプリケーション ログなどのいずれかが削除されないようにします。  
  
 呼び出すことによって、ログを削除する<xref:System.Diagnostics.EventLog.Delete%2A>ログに登録されたソースを自動的に削除されます。 そのログ機能を使用して他のアプリケーションがあることがあります。  
  
   
  
## Examples  
 次の例では、ローカル コンピューターからログを削除します。 例では、そのソースからログを決定します。  
  
> [!NOTE]
>  複数のソースは、イベント ログに書き込む可能性があります。 カスタム ログを削除する前にそのログへの書き込み、その他のソースがないになっていることを確認します。  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logName" /> が空の文字列 ("") または <see langword="null" /></exception>
        <exception cref="T:System.InvalidOperationException">ローカル コンピューター上のイベント ログのレジストリ キーを開けませんでした。  
  
\- または 
ローカル コンピューター上にログが存在しません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント ログが正常に消去されませんでした。  
  
- または - 
ログを開くことができません。 Windows のエラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Delete : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.Delete (logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">削除するログの名前。 指定できる値は、アプリケーション、セキュリティ、システム、および指定したコンピューター上の任意のカスタム イベント ログです。</param>
        <param name="machineName">ログを削除するコンピューターの名前。ローカル コンピューターの場合は "."。</param>
        <summary>指定したコンピューターからイベント ログを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 削除するログは、リモート コンピューター上には、このメソッドを使用します。 適切なレジストリ権限が与えられていれば、コンピューター上のすべてのログを削除できます。  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> 指定されたログを削除します。`logName`で指定されたコンピューターから`machineName`します。 ソースのみをログに登録されているを削除する場合は、呼び出す<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>します。 ログ エントリを削除する場合は、呼び出す<xref:System.Diagnostics.EventLog.Clear%2A>します。 <xref:System.Diagnostics.EventLog.Delete%2A> <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>は`static`メソッド、クラス自体を呼び出すことができるようにします。 インスタンスを作成する必要はありません<xref:System.Diagnostics.EventLog>をいずれかのメソッドを呼び出します。  
  
 このメソッドは、まず、ログの内容を保持するファイルを削除します。 レジストリにアクセスし、そのログに登録されているすべてのイベント ソースを削除します。 その後の時点のログを再作成する場合、再利用する場合は、ここでも、イベント ソースを登録してください。 イベント ソースを登録しないし、ログ名を指定せず、他のユーザーがイベント ソースに書き込みは、アプリケーション イベント ログでイベント ソースが作成されます。 そのため、以前に削除して再作成するログ エントリを書き込むことはアプリケーションは、アプリケーション ログに書き込む代わりに、イベント ソースが現在含まれています。  
  
> [!NOTE]
>  イベント ログを再作成すると、困難なプロセスを指定できます。 システムで作成されたイベント ログで、アプリケーション ログなどのいずれかが削除されないようにします。  
  
 呼び出すことによって、ログを削除する<xref:System.Diagnostics.EventLog.Delete%2A>ログに登録されたソースを自動的に削除されます。 そのログ機能を使用して他のアプリケーションがあることがあります。  
  
   
  
## Examples  
 次の例では、指定したコンピューターからログを削除します。 例では、そのソースからログを決定します。  
  
> [!NOTE]
>  複数のソースは、イベント ログに書き込む可能性があります。 カスタム ログを削除する前にそのログへの書き込み、その他のソースがないになっていることを確認します。  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logName" /> が空の文字列 ("") または <see langword="null" />  
  
\- または 
 <paramref name="machineName" /> が有効なコンピューター名ではありません。</exception>
        <exception cref="T:System.InvalidOperationException">指定したコンピューター上のイベント ログのレジストリ キーを開けませんでした。  
  
\- または 
指定したコンピューター上にログが存在しません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント ログが正常に消去されませんでした。  
  
- または - 
ログを開くことができません。 Windows のエラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>イベント ログからアプリケーションのイベント ソース登録を削除します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member DeleteEventSource : string -&gt; unit" Usage="System.Diagnostics.EventLog.DeleteEventSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">イベント ログ システムにアプリケーションを登録するときに使用する名前。</param>
        <summary>ローカル コンピューターのイベント ログからイベント ソースの登録を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 登録を削除するには、このメソッドを使用して、<xref:System.Diagnostics.EventLog.Source%2A>ローカル コンピューターから。 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> ローカル コンピューターのレジストリにアクセスし、有効なイベントのソースとして、アプリケーションの登録を削除します。  
  
 ログにエントリを書き込むことが不要になった場合は、有効なイベントのソースとして、コンポーネントを削除できます。 たとえば、これを行います、コンポーネントを別の 1 つのログに変更する必要がある場合。 ソースを 1 つのログに登録するには、一度に、ため、ログを変更する必要がありますを現在の登録を削除します。  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> ログに登録されているソースのみを削除します。 ログ自体を削除する場合は、呼び出す<xref:System.Diagnostics.EventLog.Delete%2A>します。 ログ エントリを削除する場合は、呼び出す<xref:System.Diagnostics.EventLog.Clear%2A>します。 <xref:System.Diagnostics.EventLog.Delete%2A> <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>は`static`メソッド、クラス自体を呼び出すことができるようにします。 インスタンスを作成する必要はありません<xref:System.Diagnostics.EventLog>をいずれかのメソッドを呼び出します。  
  
 呼び出すことによって、ログを削除する<xref:System.Diagnostics.EventLog.Delete%2A>ログに登録されたソースを自動的に削除されます。 そのログ機能を使用して他のアプリケーションがあることがあります。  
  
> [!NOTE]
>  ソースはログに既にマップされて、新しいログにマッピングする場合は、変更を反映するには、コンピューターを再起動する必要があります。  
  
   
  
## Examples  
 次の例では、ローカル コンピューターから、ソースを削除します。 この例では、ソースからログを特定し、ログを削除します。  
  
> [!NOTE]
>  複数のソースは、イベント ログに書き込む可能性があります。 カスタム ログを削除する前にそのログへの書き込み、その他のソースがないになっていることを確認します。  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">ローカル コンピューターのレジストリに <paramref name="source" /> パラメーターがありません。  
  
\- または 
イベント ログのレジストリ キーに対する書き込みアクセス許可がありません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member DeleteEventSource : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.DeleteEventSource (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">イベント ログ システムにアプリケーションを登録するときに使用する名前。</param>
        <param name="machineName">登録を削除するコンピューターの名前。ローカル コンピューターの場合は "."。</param>
        <summary>指定したコンピューターからアプリケーションのイベント ソース登録を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用して、登録を削除する、<xref:System.Diagnostics.EventLog.Source%2A>リモート コンピューターから。 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 指定されたコンピューターのレジストリにアクセスする`machineName`し、有効なイベントのソースとして、アプリケーションの登録を削除します。  
  
 ログにエントリを書き込むことが不要になった場合は、有効なイベントのソースとして、コンポーネントを削除できます。 たとえば、これを行います、コンポーネントを別の 1 つのログに変更する必要がある場合。 ソースを 1 つのログに登録するには、一度に、ため、ログを変更する必要がありますを現在の登録を削除します。  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> ログに登録されているソースのみを削除します。 ログ自体を削除する場合は、呼び出す<xref:System.Diagnostics.EventLog.Delete%2A>します。 ログ エントリを削除する場合は、呼び出す<xref:System.Diagnostics.EventLog.Clear%2A>します。 <xref:System.Diagnostics.EventLog.Delete%2A> <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>は`static`メソッド、クラス自体を呼び出すことができるようにします。 インスタンスを作成する必要はありません<xref:System.Diagnostics.EventLog>をいずれかのメソッドを呼び出します。  
  
 呼び出すことによって、ログを削除する<xref:System.Diagnostics.EventLog.Delete%2A>ログに登録されたソースを自動的に削除されます。 そのログ機能を使用して他のアプリケーションがあることがあります。  
  
> [!NOTE]
>  ソースはログに既にマップされて、新しいログにマッピングする場合は、変更を反映するには、コンピューターを再起動する必要があります。  
  
   
  
## Examples  
 次の例では、指定したコンピューターから、ソースを削除します。 この例では、ソースからログを特定し、ログを削除します。  
  
> [!NOTE]
>  複数のソースは、イベント ログに書き込む可能性があります。 カスタム ログを削除する前にそのログへの書き込み、その他のソースがないになっていることを確認します。  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> パラメーターが無効です。  
  
\- または 
指定したコンピューターのレジストリに <paramref name="source" /> パラメーターがありません。  
  
\- または 
イベント ログのレジストリ キーに対する書き込みアクセス許可がありません。</exception>
        <exception cref="T:System.InvalidOperationException">レジストリで <paramref name="source" /> の親レジストリ キーに同じ名前のサブキーが含まれないため、<paramref name="source" /> は削除できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="eventLog.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">マネージド リソースとアンマネージド リソースの両方を解放する場合は <see langword="true" />。アンマネージド リソースだけを解放する場合は <see langword="false" />。</param>
        <summary>
          <see cref="T:System.Diagnostics.EventLog" /> が使用しているアンマネージド リソースを解放します。オプションとして、マネージド リソースを解放することもできます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、パブリック`Dispose()`メソッドと<xref:System.Object.Finalize%2A>メソッド。 `Dispose()` 保護された起動`Dispose(Boolean)`メソッドを`disposing`パラメーターに設定`true`します。 <xref:System.Object.Finalize%2A> 呼び出す`Dispose`で`disposing`に設定`false`します。  
  
 ときに、`disposing`パラメーターが true の場合、このメソッドは、すべてのマネージ オブジェクトによって保持されているすべてのリソースを解放します。 この<xref:System.Diagnostics.EventLog>参照。 このメソッドは、参照される各オブジェクトの `Dispose()` メソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> 他のオブジェクトで何度も呼び出せます。オーバーライドするときに<see langword="Dispose(Boolean)" />の事前に呼び出したで以前破棄されたオブジェクトを参照しないように注意する<see langword="Dispose" />します。実装する方法についての詳細は<see langword="Dispose(Boolean)" />を参照してください[Dispose メソッドの実装](~/docs/standard/garbage-collection/implementing-dispose.md)します。詳細については<see langword="Dispose" />と<see cref="M:System.Object.Finalize" />を参照してください[アンマネージ リソースのクリーンアップ](~/docs/standard/garbage-collection/unmanaged.md)します。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If enabled raises event when a log is written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogMonitoring")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Diagnostics.EventLog" /> が <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> イベント通知を受信するかどうかを示す値を取得または設定します。</summary>
        <value>エントリがログに書き込まれたときに <see cref="T:System.Diagnostics.EventLog" /> が通知を受信する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A>プロパティを決定するかどうか、<xref:System.Diagnostics.EventLog>エントリがログに書き込まれるときにイベントを発生させます。 プロパティが`true`、コンポーネントを受信する、<xref:System.Diagnostics.EventLog.EntryWritten>イベントはエントリがで指定されているログに書き込まれるたびに通知を受信、<xref:System.Diagnostics.EventLog.Log%2A>プロパティ。 場合<xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A>は`false`イベントは発生しません。  
  
> [!NOTE]
>  ローカル コンピューターのエントリが書き込まれる場合にのみ、イベント通知を受け取ることができます。 リモート コンピューター上で書き込まれたエントリの通知を受信することはできません。  
  
   
  
## Examples  
 次の例のハンドル、<xref:System.Diagnostics.EventLog.EntryWritten>イベント。  
  
 [!code-cpp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">イベント ログは、リモート コンピューター上にあります。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を書き込む。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="eventLog.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>フォームまたは別のコンポーネントで使用される <see cref="T:System.Diagnostics.EventLog" /> の初期化を終了します。 初期化は実行時に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]デザイン環境では、このメソッドを使用して、フォームまたは別のコンポーネントで使用されるコンポーネントの初期化を終了します。 <xref:System.Diagnostics.EventLog.BeginInit%2A>メソッドは、初期化を開始します。 使用して、<xref:System.Diagnostics.EventLog.BeginInit%2A>と<xref:System.Diagnostics.EventLog.EndInit%2A>メソッドにより、コントロールは完全に初期化される前に使用されているからです。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を書き込む。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Entries">
      <MemberSignature Language="C#" Value="public System.Diagnostics.EventLogEntryCollection Entries { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLogEntryCollection Entries" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Entries" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Entries As EventLogEntryCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::EventLogEntryCollection ^ Entries { System::Diagnostics::EventLogEntryCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Entries : System.Diagnostics.EventLogEntryCollection" Usage="System.Diagnostics.EventLog.Entries" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The entries in the log.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogEntries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLogEntryCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベント ログの内容を取得します。</summary>
        <value>イベント ログのエントリを保持している <see cref="T:System.Diagnostics.EventLogEntryCollection" />。 1 つのエントリが <see cref="T:System.Diagnostics.EventLogEntry" /> クラスの 1 つのインスタンスに関連付けられます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Diagnostics.EventLog.Entries%2A>メンバー、イベント ログから読み取るときにします。  
  
 エントリを変更またはを使用してログに書き込むことはできません、プロパティが読み取り専用であるため、<xref:System.Diagnostics.EventLog.Entries%2A>します。 代わりに、指定、<xref:System.Diagnostics.EventLog.Source%2A>を呼び出すと<xref:System.Diagnostics.EventLog.WriteEntry%2A>新しいログ エントリの書き込みにします。 使用することができます<xref:System.Diagnostics.EventLog.Entries%2A>、イベント ログ エントリの数をカウントし、各表示<xref:System.Diagnostics.EventLogEntry>コレクション内で。 使用して、インデックス付き<xref:System.Diagnostics.EventLogEntryCollection.Item%2A>など特定のエントリに関する情報を取得するメンバー <xref:System.Diagnostics.EventLogEntry.Message%2A>、 <xref:System.Diagnostics.EventLogEntry.Category%2A>、 <xref:System.Diagnostics.EventLogEntry.TimeWritten%2A>、または<xref:System.Diagnostics.EventLogEntry.EntryType%2A>します。  
  
 指定する必要はありません、<xref:System.Diagnostics.EventLog.Source%2A>のみをログから読み取るときにします。 のみを指定することができます、<xref:System.Diagnostics.EventLog.Log%2A>名と<xref:System.Diagnostics.EventLog.MachineName%2A>(サーバーのコンピューター名) のプロパティを<xref:System.Diagnostics.EventLog>インスタンス。 どちらの場合、<xref:System.Diagnostics.EventLog.Entries%2A>メンバーはエントリのイベント ログの一覧が設定されます。 個々 のエントリを読み取るには、この一覧では、該当する項目のインデックスを選択できます。  
  
 ログ エントリの読み取りと書き込みの重要な違いを明示的に読み取りメソッドを呼び出す必要はありません。 後に、<xref:System.Diagnostics.EventLog.Log%2A>と<xref:System.Diagnostics.EventLog.MachineName%2A>が指定されて、<xref:System.Diagnostics.EventLog.Entries%2A>プロパティが自動的に設定されます。 値を変更する場合、<xref:System.Diagnostics.EventLog.Log%2A>または<xref:System.Diagnostics.EventLog.MachineName%2A>プロパティ、<xref:System.Diagnostics.EventLog.Entries%2A>プロパティが、次回読むことを再作成します。  
  
> [!NOTE]
>  指定する必要はありません、<xref:System.Diagnostics.EventLog.MachineName%2A>をログに接続している場合。 指定しない場合、 <xref:System.Diagnostics.EventLog.MachineName%2A>、ローカルのコンピューターでは、"."と見なされます。  
  
   
  
## Examples  
 次の例では、ローカル コンピューターのイベント ログ"MyNewLog"のエントリを読み取ります。  
  
 [!code-cpp[Classic EventLog.Entries Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Entries Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Entries Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
      </Docs>
    </Member>
    <Member MemberName="EntryWritten">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.EntryWrittenEventHandler EntryWritten;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.EntryWrittenEventHandler EntryWritten" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.EventLog.EntryWritten" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EntryWritten As EntryWrittenEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::EntryWrittenEventHandler ^ EntryWritten;" />
      <MemberSignature Language="F#" Value="member this.EntryWritten : System.Diagnostics.EntryWrittenEventHandler " Usage="member this.EntryWritten : System.Diagnostics.EntryWrittenEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Raised for each EventLog entry written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogEntryWritten")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EntryWrittenEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ローカル コンピューター上のイベント ログにエントリが書き込まれたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定する必要があります、イベント通知を受信する<xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A>に`true`します。 ローカル コンピューターのエントリが書き込まれるときにのみ、イベント通知を受信できます。 リモート コンピューター上で書き込まれたエントリの通知を受信することはできません。  
  
 <xref:System.Diagnostics.EventLog.EntryWritten> デリゲートを作成する場合は、イベントを処理するメソッドを指定します。 イベントをイベント ハンドラーに関連付けるには、デリゲートのインスタンスをイベントに追加します。 デリゲートを削除するまで、イベントが発生するたびに、イベント ハンドラーが呼び出されます。 デリゲートとイベントの処理についての詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 システムに応答する<xref:System.Diagnostics.EventLog.WriteEntry%2A>最後の書き込みイベントには、少なくとも 6 秒前が発生した場合のみです。 つまり、受信はのみ<xref:System.Diagnostics.EventLog.EntryWritten>イベント通知、6 秒間隔に含まれる場合でも、1 つ以上のイベント ログの変更が発生します。 呼び出しの間で十分に長いスリープ間隔 (約 10 秒) を挿入する場合<xref:System.Diagnostics.EventLog.WriteEntry%2A>イベントを見逃す可能性が少なくします。 ただし、書き込みイベントが頻繁に発生する場合に、次の間隔までのイベント通知を受信しません可能性があります。 通常、見逃されたイベント通知は失われませんが、遅延します。  
  
   
  
## Examples  
 次の例では、エントリ書き込みイベントを処理します。  
  
 [!code-cpp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EntryWritten Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Exists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したログが存在するかどうかを確認します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Diagnostics.EventLog.Exists logName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">検索するログの名前。 指定できる値は、アプリケーション、セキュリティ、システム、アプリケーション固有のその他のログ (Active Directory に関連するログなど)、またはコンピューター上の任意のカスタム ログです。</param>
        <summary>ローカル コンピューター上にログが存在するかどうかを確認します。</summary>
        <returns>ローカル コンピューター上にログが存在する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ローカル コンピューターのログが存在するかどうかを判断するのにには、このメソッドを使用します。 使用して、ローカル コンピューターで、ソースが存在するかどうかを確認する<xref:System.Diagnostics.EventLog.SourceExists%2A>します。  
  
 このメソッドが、レジストリにアクセスするため、ローカル コンピューターに適切なレジストリのアクセス許可が必要クエリを返しますそれ以外の場合、`false`します。  
  
 同じコンピューターに新しいログを既存のログの名前を付けることはできませんは、新しいログを作成する前にこのメソッドをかどうかを使用して、指定した`logName`ローカル コンピューターに既に存在します。 `logName`パラメーターは大文字小文字が区別されません。  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> `static`メソッド、クラス自体で呼び出せるようにします。 インスタンスを作成する必要はありません<xref:System.Diagnostics.EventLog>を呼び出す<xref:System.Diagnostics.EventLog.Exists%2A>します。  
  
   
  
## Examples  
 [!code-cpp[EventLog_Exists_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_Exists_1/CPP/eventlog_exists_1.cpp#1)]
 [!code-csharp[EventLog_Exists_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_Exists_1/CS/eventlog_exists_1.cs#1)]
 [!code-vb[EventLog_Exists_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_Exists_1/VB/eventlog_exists_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">logName が <see langword="null" /> です。または値が空です。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Exists : string * string -&gt; bool" Usage="System.Diagnostics.EventLog.Exists (logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">検索するログ。 指定できる値は、アプリケーション、セキュリティ、システム、アプリケーション固有のその他のログ (Active Directory に関連するログなど)、またはコンピューター上の任意のカスタム ログです。</param>
        <param name="machineName">ログ検索の対象となるコンピューターの名前。ローカル コンピューターの場合は "."。</param>
        <summary>指定したコンピューター上にログが存在するかどうかを確認します。</summary>
        <returns>指定したコンピューター上にログが存在する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ログがリモート コンピューター上に存在するかどうかを判断するのにには、このメソッドを使用します。 リモート コンピューターで、ソースが存在するかどうかを確認する<xref:System.Diagnostics.EventLog.SourceExists%2A>します。  
  
 このメソッドが、レジストリにアクセスするため、適切なレジストリ アクセス許可が必要です。 指定したコンピューター上クエリを返しますそれ以外の場合、`false`します。  
  
 同じコンピューターに新しいログを既存のログの名前を付けることはできませんは、新しいログを作成する前にこのメソッドを 1 つであるかどうかを使用して、指定した`logName`で指定されたサーバーに既に存在する、`machineName`パラメーター。 `logName`と`machineName`パラメーターは大文字小文字が区別されません。  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> `static`メソッド、クラス自体で呼び出せるようにします。 新しいインスタンスを作成する必要はありません<xref:System.Diagnostics.EventLog>を呼び出す<xref:System.Diagnostics.EventLog.Exists%2A>します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> パラメーターの書式が無効です。 検索しているコンピューターに対して正しい構文を使用したかどうかを確認してください。  
  
- または - 
<paramref name="logName" /> が <see langword="null" /> です。または値が空です。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEventLogs">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>イベント ログの配列を作成します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs () As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs();" />
      <MemberSignature Language="F#" Value="static member GetEventLogs : unit -&gt; System.Diagnostics.EventLog[]" Usage="System.Diagnostics.EventLog.GetEventLogs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ローカル コンピューター上のすべてのイベント ログを検索し、リストを格納する <see cref="T:System.Diagnostics.EventLog" /> オブジェクトの配列を作成します。</summary>
        <returns>ローカル コンピューター上のログを表す <see cref="T:System.Diagnostics.EventLog" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 配列<xref:System.Diagnostics.EventLog>オブジェクトは、ローカル コンピューター上のすべてのイベント ログのスナップショットとへの呼び出し<xref:System.Diagnostics.EventLog.GetEventLogs%2A>されます。 これは、動的なコレクションのため、リアルタイムでログの作成または削除は反映されません。 読み取りまたは書き込みを実行する前に、配列内のログが存在することを確認する必要があります。 配列には通常、少なくとも 3 つのログが含まれています。 アプリケーション、システム、およびセキュリティ。 ローカル コンピューターのカスタム ログを作成した場合も、配列に表示されます。  
  
 イベント ログの一覧を取得するには、適切なレジストリ権限が必要です。 これらのアクセス許可が呼び出しに必要なものと同じ<xref:System.Diagnostics.EventLog.Exists%2A>と<xref:System.Diagnostics.EventLog.SourceExists%2A>します。  
  
   
  
## Examples  
 次の例では、ローカル コンピューターでは、定義されたイベント ログを列挙し、各イベント ログの構成の詳細が表示されます。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">レジストリの読み取りアクセス許可がありません。  
  
- または - 
コンピューター上にイベント ログ サービスがありません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs (machineName As String) As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetEventLogs : string -&gt; System.Diagnostics.EventLog[]" Usage="System.Diagnostics.EventLog.GetEventLogs machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">イベント ログの検索対象となるコンピューター。</param>
        <summary>指定したコンピューター上のすべてのイベント ログを検索し、リストを格納する <see cref="T:System.Diagnostics.EventLog" /> オブジェクトの配列を作成します。</summary>
        <returns>指定したコンピューター上のログを表す <see cref="T:System.Diagnostics.EventLog" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 配列<xref:System.Diagnostics.EventLog>オブジェクトで指定されたコンピューター上のすべてのイベント ログのスナップショットは、`machineName`パラメーターと呼び出し<xref:System.Diagnostics.EventLog.GetEventLogs%2A>されます。 これは、動的なコレクションのため、リアルタイムでログの作成または削除は反映されません。 読み取りまたは書き込みを実行する前に、配列内のログが存在することを確認する必要があります。 配列には通常、少なくとも 3 つのログが含まれています。 アプリケーション、システム、およびセキュリティ。 指定したコンピューター上のカスタム ログを作成した場合も、配列に表示されます。  
  
 <xref:System.Diagnostics.EventLog.GetEventLogs%2A> `static`メソッドを呼び出せるように、<xref:System.Diagnostics.EventLog>クラス自体。 インスタンスを作成する必要はありません、<xref:System.Diagnostics.EventLog>メソッドに呼び出しを実行するオブジェクト。  
  
 イベント ログの一覧を取得するには、適切なレジストリ権限が必要です。 これらのアクセス許可が呼び出しに必要なものと同じ<xref:System.Diagnostics.EventLog.Exists%2A>と<xref:System.Diagnostics.EventLog.SourceExists%2A>します。  
  
   
  
## Examples  
 次の例では、"myServer"のコンピューター上のログの一覧を取得します。 各ログの名前が出力されます。  
  
 [!code-cpp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> パラメーターに無効なコンピューター名が指定されています。</exception>
        <exception cref="T:System.InvalidOperationException">レジストリの読み取りアクセス許可がありません。  
  
- または - 
コンピューター上にイベント ログ サービスがありません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public string Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Log" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Log" />
      <MemberSignature Language="VB.NET" Value="Public Property Log As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Log { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Log : string with get, set" Usage="System.Diagnostics.EventLog.Log" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the log that is read and written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogLog")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>読み取るログまたは書き込むログの名前を取得または設定します。</summary>
        <value>ログの名前。 ログ名には、アプリケーション ログ名、システム ログ名、セキュリティ ログ名、またはカスタム ログ名を指定できます。 既定値は、空の文字列 ("") です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定では、サーバーで次の 3 つのログ ファイルが存在します。 アプリケーション、システム、およびセキュリティ。 アプリケーションとサービスは、アプリケーションのログ ファイルを使用します。 デバイス ドライバーは、システム ログ ファイルを使用します。 監査をオンにすると、セキュリティ ログで成功と失敗の監査イベントが生成されます。 Windows のサーバー上の Active Directory のように、インストールされている他のアプリケーションがある場合、その他の既定のログ ファイルがあります。 さらに、ローカルまたはリモート コンピューター上のカスタム ログ ファイルを作成することができます。 カスタム ログは、既定のアプリケーション ログにイベントを書き込むときに許可されているより詳細な方法で、エントリを整理します。  
  
> [!NOTE]
>  ログ名は、8 文字に制限されます。 システムに従って MyLogSample1 と MyLogSample2 は、同じログです。  
  
 イベント ログに記述する場合は指定するのに十分な<xref:System.Diagnostics.EventLog.Log%2A>プロパティ。 関連付ける必要があります、<xref:System.Diagnostics.EventLog.Source%2A>特定のログに接続するようにイベント ログ リソースを持つプロパティです。 指定する必要はありません、<xref:System.Diagnostics.EventLog.Source%2A>ときに、ログがイベント ソースからの読み取りのみがあります、サーバーのレジストリのイベント ログのリソースに関連付けられています。 のみを指定することができます、<xref:System.Diagnostics.EventLog.Log%2A>名と<xref:System.Diagnostics.EventLog.MachineName%2A>からの読み取りに (サーバーのコンピューター名)。  
  
> [!NOTE]
>  指定する必要はありません、<xref:System.Diagnostics.EventLog.MachineName%2A>をログに接続している場合。 指定しない場合、 <xref:System.Diagnostics.EventLog.MachineName%2A>、ローカル コンピューター (".") と見なされます。  
  
 場合、<xref:System.Diagnostics.EventLog.Source%2A>プロパティが指定されていないへの呼び出し<xref:System.Diagnostics.EventLog.Log%2A>場合は、空の文字列を返します<xref:System.Diagnostics.EventLog.Log%2A>明示的に設定されていません (設定して、<xref:System.Diagnostics.EventLog.Log%2A>プロパティ、またはコンス トラクターを使用)。 場合、<xref:System.Diagnostics.EventLog.Source%2A>が指定されている<xref:System.Diagnostics.EventLog.Log%2A>そのソースが登録されているログの名前を返します。  
  
 ソースは、一度に 1 つのログにのみ登録できます。 場合、<xref:System.Diagnostics.EventLog.Source%2A>のインスタンスのプロパティが設定された<xref:System.Diagnostics.EventLog>、変更することはできません、<xref:System.Diagnostics.EventLog.Log%2A>プロパティを<xref:System.Diagnostics.EventLog>の値を変更することがなく<xref:System.Diagnostics.EventLog.Source%2A>呼び出しまたは<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>最初。 変更する場合、<xref:System.Diagnostics.EventLog.Log%2A>プロパティの後、<xref:System.Diagnostics.EventLog.Source%2A>プロパティが設定されて、例外をスローするログ エントリを記述します。  
  
 オペレーティング システムは、イベント ログをファイルとして格納します。 使用すると<xref:System.Diagnostics.EventLogInstaller>または<xref:System.Diagnostics.EventLog.CreateEventSource%2A>指定したコンピューター上の %SystemRoot%\System32\Config ディレクトリに新しいイベント ログを作成する、関連付けられたファイルが格納されています。 最初の 8 文字を付加して、ファイル名が設定されて、 <xref:System.Diagnostics.EventLog.Log%2A> ".evt"ファイル名拡張子を持つプロパティです。  
  
 使用して新しいログを作成することはできません、<xref:System.Diagnostics.EventLog.Log%2A>プロパティ (なし、ログのソースを指定する) だけです。 呼び出すことができます<xref:System.Diagnostics.EventLog.CreateEventSource%2A>、新しいログ名をパラメーターとして渡してを呼び出して<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>します。 ただし、目的は、通常、作成 (および、エントリを書き込む) をアプリケーションに固有の新しいログや、既存のログからの読み取り。  
  
 場合、<xref:System.Diagnostics.EventLog.Log%2A>値の変更は、イベント ログが閉じられ、すべてのイベント ハンドルが解放されます。  
  
> [!CAUTION]
>  設定した場合、<xref:System.Diagnostics.EventLog.Log%2A>プロパティが存在しないログの名前をシステムのアタッチ、<xref:System.Diagnostics.EventLog>アプリケーション ログには、警告ログ以外に指定した 1 つのログが使用されているが、します。  
  
   
  
## Examples  
 次の例では、ローカル コンピューターのイベント ログ"NewEventLog"のエントリを読み取ります。  
  
 [!code-cpp[Classic EventLog.Log Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Log Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Log Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Log Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を書き込む。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
      </Docs>
    </Member>
    <Member MemberName="LogDisplayName">
      <MemberSignature Language="C#" Value="public string LogDisplayName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LogDisplayName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.LogDisplayName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogDisplayName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LogDisplayName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogDisplayName : string" Usage="System.Diagnostics.EventLog.LogDisplayName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベント ログの表示名を取得します。</summary>
        <value>システムのイベント ビューアーのイベント ログを表す名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Windows Vista 以降では、ユーザーには、セキュリティ ログにアクセスする権限はありません。 Windows Vista を実行している場合、get がするユーザーは、後で、<xref:System.Security.SecurityException>しようとすると、セキュリティ ログのイベントの表示名にアクセスします。  
>   
>  Windows Vista 以降では、ユーザー アカウント制御 (UAC: User Account Control) でユーザーの権限が決定されます。 ユーザーが組み込みの Administrators グループのメンバーである場合、そのユーザーには標準ユーザー アクセス トークンおよび管理者アクセス トークンの 2 つのランタイム アクセス トークンが割り当てられています。 既定では、ユーザーは標準ユーザー ロールに所属します。 セキュリティ ログにアクセスするコードを実行するには標準ユーザーから管理者に、特権を昇格する必要があります。 この操作は、アプリケーションの起動時にアプリケーション アイコンを右クリックし、管理者として実行することを指定して行うことができます。  
  
   
  
## Examples  
 次の例は、ローカル コンピューターで定義されたイベント ログを列挙し、表示、<xref:System.Diagnostics.EventLog.LogDisplayName%2A>の各イベント ログ。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">このコンピューターのレジストリに、指定した <see cref="P:System.Diagnostics.EventLog.Log" /> が存在しません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">指定されたレジストリ キーの読み取りに必要なアクセス許可。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">場合は指定されたレジストリ キーにアクセスする機能をリモートのキーになります。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="LogNameFromSourceName">
      <MemberSignature Language="C#" Value="public static string LogNameFromSourceName (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string LogNameFromSourceName(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LogNameFromSourceName (source As String, machineName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LogNameFromSourceName(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member LogNameFromSourceName : string * string -&gt; string" Usage="System.Diagnostics.EventLog.LogNameFromSourceName (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">イベント ソースの名前。</param>
        <param name="machineName">検索対象のコンピューターの名前。ローカル コンピューターの場合は "."。</param>
        <summary>指定したソースが登録されているログの名前を取得します。</summary>
        <returns>レジストリ内で指定したソースに関連付けられているログの名前。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント ソースは、ログのイベントを示します。 これは、アプリケーションが大きい場合多くの場合、アプリケーションの名前またはアプリケーションのサブコンポーネントの名前。 アプリケーションとサービスは、アプリケーション ログまたはカスタムのログに書き込む必要があります。 デバイス ドライバーは、システム ログに書き込む必要があります。  
  
 できますのみログに書き込む 1 つずつ、新しいソースを作成するときに、システムは、有効なエントリのソースとしてイベント ログに、アプリケーションを登録します。 <xref:System.Diagnostics.EventLog.Source%2A>プロパティは、任意の文字列を指定できますが、コンピューター上の他のソースで名前は使用できません。 作成、複製されたしよう<xref:System.Diagnostics.EventLog.Source%2A>値は、例外をスローします。 ただし、1 つのイベント ログには、さまざまなソースを書き込むことができます。  
  
   
  
## Examples  
 次の例では、ローカル コンピューターから、ソースを削除します。 この例では、ソースからログを特定し、ログを削除します。  
  
> [!NOTE]
>  複数のソースは、イベント ログに書き込む可能性があります。 カスタム ログを削除する前にそのログへの書き込み、その他のソースがないになっていることを確認します。  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Diagnostics.EventLog.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(".")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the machine that this log get written to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogMachineName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベントを読み取るコンピューターまたは書き込むコンピューターの名前を取得または設定します。</summary>
        <value>イベント ログが存在するサーバーの名前。 既定値はローカル コンピューター (".") です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント ログに記述する場合に関連付ける必要があります、<xref:System.Diagnostics.EventLog.Source%2A>特定のログに接続するため、イベント ログ オブジェクトを使用します。 指定する必要はありません、<xref:System.Diagnostics.EventLog.Source%2A>プロパティのみをログから読み取るときにします。 のみを指定することができます、<xref:System.Diagnostics.EventLog.Log%2A>名と<xref:System.Diagnostics.EventLog.MachineName%2A>(サーバーのコンピューター名)。  
  
> [!NOTE]
>  指定する必要はありません、<xref:System.Diagnostics.EventLog.MachineName%2A>をログに接続している場合。 指定しない場合、 <xref:System.Diagnostics.EventLog.MachineName%2A>、ローカル コンピューター (".") と見なされます。  
  
 ソースは、一度に 1 つのログにのみ登録できます。 場合、<xref:System.Diagnostics.EventLog.Source%2A>のインスタンスのプロパティが設定された<xref:System.Diagnostics.EventLog>、変更することはできません、<xref:System.Diagnostics.EventLog.MachineName%2A>プロパティを<xref:System.Diagnostics.EventLog>の値を変更することがなく<xref:System.Diagnostics.EventLog.Source%2A>呼び出しまたは<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>最初。 変更した場合、<xref:System.Diagnostics.EventLog.MachineName%2A>プロパティ、<xref:System.Diagnostics.EventLog>すべてのハンドルを閉じ、ログと、新しいコンピューター上のソースに再アタッチします。  
  
 <xref:System.Diagnostics.EventLog.MachineName%2A>値が空の文字列にすることはできません。 明示的に設定されていない場合、ローカル コンピューターに既定値 (".")。  
  
   
  
## Examples  
 次の例では、指定されたコンピューター上のイベント ログ"NewEventLog"のエントリを読み取ります。  
  
 [!code-cpp[Classic EventLog.MachineName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">コンピューター名が無効です。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を書き込む。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.GetEventLogs" />
      </Docs>
    </Member>
    <Member MemberName="MaximumKilobytes">
      <MemberSignature Language="C#" Value="public long MaximumKilobytes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumKilobytes" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumKilobytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumKilobytes { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumKilobytes : int64 with get, set" Usage="System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベント ログの最大サイズを KB 単位で取得または設定します。</summary>
        <value>イベント ログの最大サイズ。単位は KB です。 既定値は、512 KB の最大ファイル サイズを示す 512 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A>プロパティは、イベント ログ ファイルのサイズ制限を表します。 イベント ログが構成されているサイズ制限に達したとき<xref:System.Diagnostics.EventLog.OverflowAction%2A>値が新しいエントリが破棄されたかどうか、または新しいエントリが古いエントリを上書きするかどうかを決定します。  
  
> [!NOTE]
>  このプロパティは、このインスタンスで表される、イベント ログの構成設定を表します。 イベント ログには、最大サイズに達すると、このプロパティは、オペレーティング システムがイベント ログに登録されているすべてのイベント ソースによって書き込まれる新しいエントリを処理する方法を指定します。  
  
   
  
## Examples  
 次の例では、ローカル コンピューターでは、定義されたイベント ログを列挙し、各イベント ログの構成の詳細が表示されます。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">指定した値が 64 未満か、4194240 を超える値です。または、64 の倍数ではありません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.EventLog.Log" /> 値が有効なログ名ではありません。  
  
\- または 
対象のコンピューター上のイベント ログのレジストリ キーを開けませんでした。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MinimumRetentionDays">
      <MemberSignature Language="C#" Value="public int MinimumRetentionDays { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumRetentionDays" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MinimumRetentionDays As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumRetentionDays { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MinimumRetentionDays : int" Usage="System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベント ログ内のエントリを保持する日数を取得します。</summary>
        <value>イベント ログ内のエントリが保持される日数。 既定値は 7 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>プロパティをイベント ログの現在の設定を確認します。 使用<xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>イベント ログ内の各エントリを保持する必要があります最小日数を変更します。  
  
 <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>値は、イベント ログのオーバーフロー動作に依存します。 場合、 <xref:System.Diagnostics.OverflowAction> 、イベント ログのプロパティに設定されて<xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>、<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>値は 0 です。 場合、 <xref:System.Diagnostics.OverflowAction> 、イベント ログのプロパティに設定されて<xref:System.Diagnostics.OverflowAction.DoNotOverwrite>、<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>値は-1 です。 場合、 <xref:System.Diagnostics.OverflowAction> 、イベント ログのプロパティに設定されて<xref:System.Diagnostics.OverflowAction.OverwriteOlder>、<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>値が 0 より大きいと、イベント ログがいっぱいになったときにイベント ログ エントリを保持する日数の数を表します。  
  
 オーバーフロー動作は、イベント ログがそのサイズの上限に達したときにのみ発生します。 ときに、<xref:System.Diagnostics.EventLog>がその<xref:System.Diagnostics.EventLog.OverflowAction%2A>設定<xref:System.Diagnostics.OverflowAction.OverwriteOlder>、し、イベント ログが最大サイズに達すると、新しいエントリとして、年齢を超えるエントリを置き換えることができるかどうかにのみ書き込まれます、<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>期間。 イベント エントリの最低限の期間の保持は、イベント ログを定期的にアーカイブする場合に適しています。 それ以外の場合、イベント ログが、上限に達するときに新しいエントリの損失する可能性があります。 新しいイベント情報の損失を回避するには、特定のイベント ログのアーカイブ スケジュールに基づいたイベントの最小保持日数を設定します。  
  
   
  
## Examples  
 次の例では、ローカル コンピューターでは、定義されたイベント ログを列挙し、各イベント ログの構成の詳細が表示されます。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
      </Docs>
    </Member>
    <Member MemberName="ModifyOverflowPolicy">
      <MemberSignature Language="C#" Value="public void ModifyOverflowPolicy (System.Diagnostics.OverflowAction action, int retentionDays);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ModifyOverflowPolicy(valuetype System.Diagnostics.OverflowAction action, int32 retentionDays) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ModifyOverflowPolicy (action As OverflowAction, retentionDays As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ModifyOverflowPolicy(System::Diagnostics::OverflowAction action, int retentionDays);" />
      <MemberSignature Language="F#" Value="member this.ModifyOverflowPolicy : System.Diagnostics.OverflowAction * int -&gt; unit" Usage="eventLog.ModifyOverflowPolicy (action, retentionDays)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Diagnostics.OverflowAction" />
        <Parameter Name="retentionDays" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="action">イベント ログに新しいエントリを書き込むためのオーバーフロー動作。</param>
        <param name="retentionDays">イベント ログの各エントリが保持される最小日数。 このパラメーターは、<c>action</c> が <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" /> に設定されている場合にのみ使用されます。</param>
        <summary>イベント ログが最大ファイル サイズに達した場合に、新しいエントリを書き込むように構成された動作を変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント ログのオーバーフロー動作では、新しいエントリが最大ファイル サイズに達したログに書き込まれるときの動作を指定します。  
  
> [!NOTE]
>  オーバーフロー動作は、イベント ログが最大ファイル サイズに達した場合にのみ反映されます。 オーバーフロー動作は、追加のイベント ログ エントリに対応できるログに新しいエントリを書き込むには影響しません。  
  
 <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>メソッドは、イベント ログのオーバーフロー動作を構成します。 <xref:System.Diagnostics.EventLog> インスタンス。 指定されたイベント ログにこのメソッドを呼び出した後、<xref:System.Diagnostics.EventLog.Log%2A>プロパティ、<xref:System.Diagnostics.EventLog.OverflowAction%2A>と<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>プロパティの値は、新しく構成されたオーバーフロー動作を反映します。  
  
> [!NOTE]
>  このプロパティは、このインスタンスで表される、イベント ログの構成設定を表します。 イベント ログには、最大サイズに達すると、このプロパティは、オペレーティング システムがイベント ログに登録されているすべてのイベント ソースによって書き込まれる新しいエントリを処理する方法を指定します。  
  
 設定、`action`パラメーターを<xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>を新しいエントリが最も古いエントリを上書きすることを示すときに、<xref:System.Diagnostics.EventLog>最大サイズに達した。 場合、`action`にパラメーターが設定されている<xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>、`retentionDays`パラメーターの値は無視されます。  
  
 設定、`action`パラメーターを<xref:System.Diagnostics.OverflowAction.OverwriteOlder>を新しいエントリが古いエントリを上書きすることを示すときに、<xref:System.Diagnostics.EventLog>最大サイズに達した。 ログを使用して、イベントを保持する日数を指定、`retentionDays`パラメーター。 保有期間の範囲内のイベントは、新しいエントリでは上書きされません。  
  
 設定、`action`パラメーターを<xref:System.Diagnostics.OverflowAction.DoNotOverwrite>最大ログ サイズに達すると、新しいイベントを破棄します。 場合、`action`にパラメーターが設定されている<xref:System.Diagnostics.OverflowAction.DoNotOverwrite>、`retentionDays`パラメーターの値は無視されます。  
  
> [!CAUTION]
>  オーバーフローのポリシーを設定<xref:System.Diagnostics.OverflowAction.DoNotOverwrite>イベント ログがいっぱいになったときに、新しいエントリが破棄されたことを指定します。 この設定を使用する場合は、イベント ログが定期的にアーカイブし、その最大サイズの上限に達しないようにを確認します。  
  
   
  
## Examples  
 次の例では、特定のイベント ログのオーバーフローが構成されているポリシーを表示しを新しいイベント ログのオーバーフロー ポリシー設定を選択できます。  
  
 [!code-cpp[EventLogProperties#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#3)]
 [!code-csharp[EventLogProperties#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#3)]
 [!code-vb[EventLogProperties#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> は有効な <see cref="P:System.Diagnostics.EventLog.OverflowAction" /> 値ではありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="retentionDays" /> が 1 未満であるか、365 を超えています。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.EventLog.Log" /> 値が有効なログ名ではありません。  
  
\- または 
対象のコンピューター上のイベント ログのレジストリ キーを開けませんでした。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="OverflowAction">
      <MemberSignature Language="C#" Value="public System.Diagnostics.OverflowAction OverflowAction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.OverflowAction OverflowAction" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.OverflowAction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OverflowAction As OverflowAction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::OverflowAction OverflowAction { System::Diagnostics::OverflowAction get(); };" />
      <MemberSignature Language="F#" Value="member this.OverflowAction : System.Diagnostics.OverflowAction" Usage="System.Diagnostics.EventLog.OverflowAction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.OverflowAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベント ログが最大ファイル サイズに達した場合に、新しいエントリを格納するように構成された動作を取得します。</summary>
        <value>イベント ログが最大サイズに達した場合に、新しいエントリを格納するために構成された動作を指定する <see cref="T:System.Diagnostics.OverflowAction" /> 値。 既定値は、<see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント ログは、新しいイベントが書き込まれた時に、サイズで拡張します。 各イベント ログが構成されている最大サイズ制限。<xref:System.Diagnostics.EventLog.MaximumKilobytes%2A>プロパティは、イベント ログ ファイルのサイズに許可されているキロバイトの最大数を定義します。  
  
 使用して、<xref:System.Diagnostics.EventLog.OverflowAction%2A>プロパティの値をその最大サイズにイベント ログのオーバーフロー動作を確認します。 使用して、<xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>メソッド、イベント ログのオーバーフロー動作を変更します。  
  
> [!NOTE]
>  オーバーフロー動作は、イベント ログが最大ファイル サイズに達した場合にのみ反映されます。 オーバーフロー動作は、追加のイベント ログ エントリに対応できるログに新しいエントリを書き込むには影響しません。  
  
   
  
## Examples  
 次の例では、ローカル コンピューターでは、定義されたイベント ログを列挙し、各イベント ログの構成の詳細が表示されます。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDisplayName">
      <MemberSignature Language="C#" Value="public void RegisterDisplayName (string resourceFile, long resourceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDisplayName(string resourceFile, int64 resourceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterDisplayName (resourceFile As String, resourceId As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDisplayName(System::String ^ resourceFile, long resourceId);" />
      <MemberSignature Language="F#" Value="member this.RegisterDisplayName : string * int64 -&gt; unit" Usage="eventLog.RegisterDisplayName (resourceFile, resourceId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceFile" Type="System.String" />
        <Parameter Name="resourceId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="resourceFile">ローカライズされたリソース ファイルの完全指定パス。</param>
        <param name="resourceId">リソース ファイル内のローカライズされた文字列のインデックスを示すリソース識別子。</param>
        <summary>イベント ログのローカライズされた名前を指定します。これは、サーバーのイベント ビューアーに表示されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Diagnostics.EventLog.RegisterDisplayName%2A>を登録し、カスタム イベント ログのイベント ビューアーでローカライズされた名前を表示します。  
  
 指定されたリソース識別子は、リソース ファイルで定義されているローカライズされた文字列に対応する必要があります。 イベント ビューアーには、ローカライズされた文字列と現在のカルチャ設定を使用してカスタム イベント ログ名が表示されます。 たとえば、複数のイベント ログ名、リソース ファイル内の異なるカルチャのローカライズを定義できます。 イベント ビューアーには、現在のユーザーのカルチャ設定に対応するローカライズされた文字列が表示されます。  
  
 イベント ビューアーは、リソース ファイルからローカライズされた文字列を読み込むことができませんか、イベント ログの表示名が登録されていない場合、イベント ビューアーに表示されますで定義されているイベント ログ名<xref:System.Diagnostics.EventLog.Log%2A>します。  
  
> [!NOTE]
>  定義済みのイベント ログの表示名を登録する必要はありません。 オペレーティング システムでは、アプリケーション、システム、およびセキュリティ イベント ログのローカライズされた表示名を登録します。  
  
   
  
## Examples  
 次の例は、イベント ソースが名前付きかどうかを判断`SampleApplicationSource`ローカル コンピューターに登録します。 イベント ソースが存在しない場合、例は、ソースのメッセージ リソース ファイルを設定し、新しいイベント ソースを作成します。 最後に、リソース識別子の値を使用して、イベント ログのローカライズされた表示名の設定例では、`DisplayNameMsgId`とリソース ファイルのパスで`messageFile`します。  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 EventLogMsgs.dll リソース ライブラリに組み込まれている次のメッセージのテキスト ファイルを使用します。 メッセージのテキスト ファイルは、メッセージ リソース ファイルの作成元のソースです。 メッセージのテキスト ファイルでは、リソース識別子とカテゴリ、イベント メッセージ、およびパラメーターの挿入文字列のテキストを定義します。 具体的には、イベント ログのローカライズされた名前のリソース識別子 5001 が定義されます。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.EventLog.Log" /> 値が有効なログ名ではありません。  
  
\- または 
対象のコンピューター上のイベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceFile" /> は <see langword="null" />です。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.LogDisplayName" />
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : string with get, set" Usage="System.Diagnostics.EventLog.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The application name that writes the log.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogSource")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベント ログを書き込むときに登録して使用するソース名を取得または設定します。</summary>
        <value>エントリのソースとしてイベント ログに登録される名前。 既定値は、空の文字列 ("") です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント ソースは、ログのイベントを示します。 これは、アプリケーションが大きい場合多くの場合、アプリケーションの名前またはアプリケーションのサブコンポーネントの名前。 アプリケーションとサービスは、アプリケーション ログまたはカスタムのログに書き込む必要があります。 デバイス ドライバーは、システム ログに書き込む必要があります。  
  
 のみ、イベント ログに書き込みを行う場合は、イベント ソースを指定する必要があります。 イベント ログにエントリを書き込む前に、有効なイベントのソースとして、イベント ログにイベント ソースを登録する必要があります。 ログ エントリを記述するときに、システムを使用して、<xref:System.Diagnostics.EventLog.Source%2A>エントリを配置するための適切なログを検索するプロパティ。 かどうか、イベント ログを読んでいるを指定するか、 <xref:System.Diagnostics.EventLog.Source%2A>、または<xref:System.Diagnostics.EventLog.Log%2A>と<xref:System.Diagnostics.EventLog.MachineName%2A>します。  
  
> [!NOTE]
>  指定する必要はありません、<xref:System.Diagnostics.EventLog.MachineName%2A>ローカル コンピューター上のログに接続している場合。 指定しない場合、 <xref:System.Diagnostics.EventLog.MachineName%2A>、ローカル コンピューター (".") と見なされます。  
  
 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>と<xref:System.Diagnostics.EventLog.WriteEntry%2A>イベント ログにイベントを書き込みます。 イベントを書き込むイベント ソースを指定する必要があります。作成し、ソースと最初のエントリを書き込む前に、イベント ソースを構成する必要があります。  
  
 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録済みのイベント ソースの一覧とその構成を更新するオペレーティング システムまでの時間です。 オペレーティング システムでは、イベントのソースの一覧は更新されていない場合は、書き込み操作は失敗、新しいソースを持つイベントを記述しようとしました。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド。 新しいイベント ソースを作成するコンピューターの管理者権限が必要です。  
  
 既存のイベント ログまたは新しいイベント ログのイベント ソースを作成することができます。 新しいイベント ログの新しいソースを作成するときに、システムがそのログのソースを登録しますが、最初のエントリが書き込まれるまで、ログは作成されません。  
  
 ソースは、ローカル コンピューター上で一意である必要があります。新しいソース名には、既存のソース名または既存のイベント ログ名を一致ことはできません。 各ソースは、一度に 1 つだけのイベント ログに書き込むことができます。ただし、アプリケーションでは、複数のソースを使用して、複数のイベント ログに書き込みます。 たとえば、アプリケーションでは、別のイベント ログまたは別のリソース ファイル用に構成された複数のソースを必要があります。  
  
 変更する場合、<xref:System.Diagnostics.EventLog.Source%2A>値、<xref:System.Diagnostics.EventLog>に登録されているが閉じられ、すべてのイベント ハンドルが解放されます。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接の文字列を書き込むように構成する必要があります。 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルでは、1 つのソースを構成およびでは、そのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>メソッドをイベント ログのリソース識別子を使用してエントリを書き込みます。 リソースのファイルがない場合、別のソースを作成しでそのソースを使用し、<xref:System.Diagnostics.EventLog.WriteEntry%2A>そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
 既存のソースの構成の詳細を変更するには、ソースを削除し、新しい構成を使用して作成する必要があります。 他のアプリケーションやコンポーネントは、既存のソースを使用する場合は、既存のソースを削除するのではなく、更新された構成で新しいソースを作成します。  
  
> [!NOTE]
>  ソースはログに既にマップされて、新しいログにマッピングする場合は、変更を反映するには、コンピューターを再起動する必要があります。  
  
   
  
## Examples  
 次の例では、ソース`MySource`が存在しない場合、イベント ログにエントリを書き込みます`MyNewLog`します。  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">ソース名は、254 文字を超えるレジストリ キーのパスになります。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を書き込む。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SourceExists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>コンピューターのレジストリ内で、指定したイベント ソースを検索します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member SourceExists : string -&gt; bool" Usage="System.Diagnostics.EventLog.SourceExists source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">イベント ソースの名前。</param>
        <summary>ローカル コンピューターにイベント ソースが登録されているかどうかを確認します。</summary>
        <returns>ローカル コンピューターにイベント ソースが存在する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、ローカル コンピューターのイベント ソースが存在するかどうかを確認します。 使用して、ローカル コンピューターのログが存在するかどうかを判断する<xref:System.Diagnostics.EventLog.Exists%2A>します。  
  
 このメソッドが、レジストリにアクセスするため、ローカル コンピューターに適切なレジストリのアクセス許可が必要それ以外の場合、<xref:System.Security.SecurityException>がスローされます。  
  
> [!NOTE]
>  Windows Server 2003 または Windows Vista 以降のイベント ソースを検索するには、管理者特権があります。  
>   
>  この要件の理由では、セキュリティを含むすべてのイベント ログを検索して、イベント ソースが一意かどうかを確認する必要があります。 Windows Vista 以降、ユーザー権限がありません。 セキュリティ ログにアクセスするにはそのため、<xref:System.Security.SecurityException>がスローされます。  
>   
>  Windows Vista 以降、ユーザー アカウント制御 (UAC) は、ユーザーの権限を決定します。 ユーザーが組み込みの Administrators グループのメンバーである場合、そのユーザーには標準ユーザー アクセス トークンおよび管理者アクセス トークンの 2 つのランタイム アクセス トークンが割り当てられています。 既定では、ユーザーは標準ユーザー ロールに所属します。 パフォーマンス カウンターにアクセスするコードを実行するには標準ユーザーから管理者に、特権を昇格する必要があります。 この操作は、アプリケーションの起動時にアプリケーション アイコンを右クリックし、管理者として実行することを指定して行うことができます。  
  
> [!NOTE]
>  実行されているサービス、<xref:System.ServiceProcess.ServiceAccount.LocalSystem>アカウントには、このメソッドを実行するための権限はありません。 解決でイベント ソースが存在するかどうかを確認するには、 <xref:System.ServiceProcess.ServiceInstaller>、それが存在しない場合、インストーラーのソースを作成するとします。  
  
 新しいソースには、同じコンピューター上の既存のソースの名前を付けることはできません、ために、試行する前にこのメソッドを使用して、呼び出す<xref:System.Diagnostics.EventLog.CreateEventSource%2A>で指定された名前のソースを確実に`source`ローカル コンピューターに既に存在しません。 `source`パラメーター小文字は区別されません。  
  
   
  
## Examples  
 次の例では、ソース`MySource`が存在しない場合、イベント ログにエントリを書き込みます`MyNewLog`します。  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <paramref name="source" /> が見つかりませんでしたが、イベント ログの一部またはすべてが検索できませんでした。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を書き込む。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member SourceExists : string * string -&gt; bool" Usage="System.Diagnostics.EventLog.SourceExists (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">イベント ソースの名前。</param>
        <param name="machineName">検索対象のコンピューターの名前。ローカル コンピューターの場合は "."。</param>
        <summary>指定したコンピューターにイベント ソースが登録されているかどうかを確認します。</summary>
        <returns>指定したコンピューターにイベント ソースが登録されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定されたコンピューターのイベント ソースが存在するかどうかを確認するには、このメソッドを使用して、`machineName`パラメーター。 ログが使用して、指定したコンピューター上に存在するかどうかを判断する<xref:System.Diagnostics.EventLog.Exists%2A>します。  
  
 このメソッドが、レジストリにアクセスするため、特定のサーバーに適切なレジストリのアクセス許可が必要それ以外の場合、<xref:System.Security.SecurityException>がスローされます。  
  
> [!NOTE]
>  Windows Server 2003 または Windows Vista 以降のイベント ソースを検索するには、管理者特権があります。  
>   
>  この要件の理由では、セキュリティを含むすべてのイベント ログを検索して、イベント ソースが一意かどうかを確認する必要があります。 Windows Vista 以降、ユーザー権限がありません。 セキュリティ ログにアクセスするにはそのため、<xref:System.Security.SecurityException>がスローされます。  
>   
>  Windows Vista 以降、ユーザー アカウント制御 (UAC) は、ユーザーの権限を決定します。 ユーザーが組み込みの Administrators グループのメンバーである場合、そのユーザーには標準ユーザー アクセス トークンおよび管理者アクセス トークンの 2 つのランタイム アクセス トークンが割り当てられています。 既定では、ユーザーは標準ユーザー ロールに所属します。 パフォーマンス カウンターにアクセスするコードを実行するには標準ユーザーから管理者に、特権を昇格する必要があります。 この操作は、アプリケーションの起動時にアプリケーション アイコンを右クリックし、管理者として実行することを指定して行うことができます。  
  
> [!NOTE]
>  実行されているサービス、<xref:System.ServiceProcess.ServiceAccount.LocalSystem>アカウントには、このメソッドを実行するための権限はありません。 解決でイベント ソースが存在するかどうかを確認するには、 <xref:System.ServiceProcess.ServiceInstaller>、それが存在しない場合、インストーラーのソースを作成するとします。  
  
 新しいソースには、同じコンピューター上の既存のソースの名前を付けることはできません、ために、試行する前にこのメソッドを使用して、呼び出す<xref:System.Diagnostics.EventLog.CreateEventSource%2A>で指定された名前のソースを確実に`source`コンピューターに既に存在しません。 `source`と`machineName`パラメーターは大文字小文字が区別されません。  
  
 <xref:System.Diagnostics.EventLog.SourceExists%2A> `static`メソッド、クラス自体で呼び出せるようにします。 インスタンスを作成する必要はありません<xref:System.Diagnostics.EventLog>を呼び出す<xref:System.Diagnostics.EventLog.SourceExists%2A>します。  
  
   
  
## Examples  
 次の例では、ソースを作成します`MySource`コンピューターの`MyServer`、イベント ログにエントリを書き込み、`MyNewLog`します。  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> が無効なコンピューター名です。</exception>
        <exception cref="T:System.Security.SecurityException">
          <paramref name="source" /> が見つかりませんでしたが、イベント ログの一部またはすべてが検索できませんでした。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を書き込む。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("An object that synchronizes event handler calls.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogSynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Diagnostics.EventLog" /> エントリ書き込みイベントの結果として発行されるイベント ハンドラー呼び出しをマーシャリングするために使用するオブジェクトを取得または設定します。</summary>
        <value>イベント ログの <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> イベントの結果として発行されるイベント ハンドラー呼び出しをマーシャリングするために使用する <see cref="T:System.ComponentModel.ISynchronizeInvoke" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>は`null`、処理するメソッド、<xref:System.Diagnostics.EventLog.EntryWritten>イベントは、システム スレッド プールのスレッドで呼び出されます。 システム スレッド プールの詳細については、次を参照してください。<xref:System.Threading.ThreadPool>します。  
  
 ときに、<xref:System.Diagnostics.EventLog.EntryWritten>イベントはビジュアルの Windows フォーム システム スレッド プールを介したコンポーネントへのアクセス、ボタンなどのコンポーネントが動作しないか、例外が発生する可能性があります。 設定してこの問題を回避<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>これにより、Windows フォームのコンポーネントを処理するメソッド、<xref:System.Diagnostics.EventLog.EntryWritten>コンポーネントが作成された同じスレッドで呼び出されるイベント。  
  
 場合、<xref:System.Diagnostics.EventLog>内で使用する[!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]Windows フォーム デザイナーで<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>を含むコントロールに自動的に設定されている、<xref:System.Diagnostics.EventLog>します。 配置する場合など、 <xref:System.Diagnostics.EventLog> Form1 のデザイナーで (から継承される<xref:System.Windows.Forms.Form>)、<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>プロパティの<xref:System.Diagnostics.EventLog>Form1 のインスタンスに設定されています。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を書き込む。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
        <altmember cref="T:System.Threading.ThreadPool" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEntry">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>イベント ログにエントリを書き込みます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string -&gt; unit" Usage="eventLog.WriteEntry message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">イベント ログに書き込む文字列。</param>
        <summary>種類が Information のエントリを、指定したメッセージ テキストと共にイベント ログに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用に関連付けられているイベント ログが information のエントリを書き込む<xref:System.Diagnostics.EventLog>インスタンス。 その他を指定したい場合<xref:System.Diagnostics.EventLogEntryType>の異なるオーバー ロードを使用して、<xref:System.Diagnostics.EventLog.WriteEntry%2A>します。  
  
> [!NOTE]
>  `message`文字列は、% を含めることはできません*n*ここで、 *n*整数値 (たとえば、%1) は、イベント ビューアーは、挿入文字列として扱います。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスはこれを含めることができます、ために、IPv6 アドレスを含むイベント メッセージがログ記録できません。  
  
 設定する必要があります、<xref:System.Diagnostics.EventLog.Source%2A>プロパティを<xref:System.Diagnostics.EventLog>コンポーネントがログにエントリを記述する前にします。 作成し、ソースと最初のエントリを書き込む前に、イベント ソースを構成する必要があります。  
  
 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録済みのイベント ソースの一覧とその構成を更新するオペレーティング システムまでの時間です。 オペレーティング システムでは、イベントのソースの一覧は更新されていない場合は、書き込み操作は失敗、新しいソースを持つイベントを記述しようとしました。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド。 新しいイベント ソースを作成するコンピューターの管理者権限が必要です。  
  
 ソースが指定されている場合、<xref:System.Diagnostics.EventLog.Source%2A>このプロパティ<xref:System.Diagnostics.EventLog>コンポーネントが書き込むコンピューターのインスタンスが登録されていない<xref:System.Diagnostics.EventLog.WriteEntry%2A>呼び出し<xref:System.Diagnostics.EventLog.CreateEventSource%2A>ソースを登録します。  
  
> [!NOTE]
>  指定しない場合、<xref:System.Diagnostics.EventLog.MachineName%2A>の<xref:System.Diagnostics.EventLog>インスタンスを呼び出す前に<xref:System.Diagnostics.EventLog.CreateEventSource%2A>または<xref:System.Diagnostics.EventLog.WriteEntry%2A>、ローカル コンピューター (".") と見なされます。  
  
 システムを登録する必要がある場合、<xref:System.Diagnostics.EventLog.Source%2A>呼び出しを通じて<xref:System.Diagnostics.EventLog.WriteEntry%2A>と<xref:System.Diagnostics.EventLog.Log%2A>プロパティに設定されていない、<xref:System.Diagnostics.EventLog>インスタンス、アプリケーション ログには、ログの既定値します。  
  
> [!NOTE]
>  上記の例外の多くは、登録プロセス中に発生したエラーによって生成される、<xref:System.Diagnostics.EventLog.Source%2A>します。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接の文字列を書き込むように構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドは、イベント ログに直接指定された文字列を書き込みます。 ローカライズ可能なメッセージ リソース ファイルを使用しません。 使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>ローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルでは、1 つのソースを構成およびでは、そのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>メソッドをイベント ログのリソース識別子を使用してエントリを書き込みます。 リソースのファイルがない場合、別のソースを作成しでそのソースを使用し、<xref:System.Diagnostics.EventLog.WriteEntry%2A>そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  リモート コンピューターへのエントリを記述する場合 (文字列)、メッセージの値可能性がありますいない期待どおりでは、リモート コンピューターに .NET Framework が実行されていない場合。  
  
> [!NOTE]
>  場合、`message`パラメーターには、NUL 文字が含まれる、イベント ログにメッセージは、NUL 文字で終了します。  
  
   
  
## Examples  
 次の例では、ソース`MySource`が存在しない場合、イベント ログにエントリを書き込みます`MyNewLog`します。  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> の <see cref="T:System.Diagnostics.EventLog" /> プロパティが設定されていません。  
  
- または - 
メソッドが新しいイベント ソースを登録しようとしましたが、<see cref="P:System.Diagnostics.EventLog.MachineName" /> のコンピューター名が無効です。  
  
\- または 
ソースは既に別のイベント ログに登録されています。  
  
\- または 
メッセージ文字列は 31,839 バイト (Windows Vista より前の Windows オペレーティング システムでは 32,766 バイト) を超えています。  
  
\- または 
ソース名は、254 文字を超えるレジストリ キーのパスになります。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント エントリをイベント ログに書き込むときにオペレーティング システムからエラーが報告されました。 Windows のエラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を書き込む。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType -&gt; unit" Usage="eventLog.WriteEntry (message, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="message">イベント ログに書き込む文字列。</param>
        <param name="type">
          <see cref="T:System.Diagnostics.EventLogEntryType" /> 値のいずれか 1 つ。</param>
        <summary>エラー、警告、情報、監査正常終了、または監査エラー エントリを、指定したメッセージ テキストと共にイベント ログに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、指定したエントリの書き込み<xref:System.Diagnostics.EventLogEntryType>イベント ログにします。 `type`アイコンとテキスト ログのイベント ビューアーの種類 列で示されます。  
  
> [!NOTE]
>  `message`文字列は、% を含めることはできません*n*ここで、 *n*整数値 (たとえば、%1) は、イベント ビューアーは、挿入文字列として扱います。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスはこれを含めることができます、ために、IPv6 アドレスを含むイベント メッセージがログ記録できません。  
  
 設定する必要があります、<xref:System.Diagnostics.EventLog.Source%2A>プロパティを<xref:System.Diagnostics.EventLog>コンポーネントがログにエントリを記述する前にします。 作成し、ソースと最初のエントリを書き込む前に、イベント ソースを構成する必要があります。  
  
 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録済みのイベント ソースの一覧とその構成を更新するオペレーティング システムまでの時間です。 オペレーティング システムでは、イベントのソースの一覧は更新されていない場合は、書き込み操作は失敗、新しいソースを持つイベントを記述しようとしました。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド。 新しいイベント ソースを作成するコンピューターの管理者権限が必要です。  
  
 ソースが指定されている場合、<xref:System.Diagnostics.EventLog.Source%2A>このプロパティ<xref:System.Diagnostics.EventLog>コンポーネントが書き込むコンピューターのインスタンスが登録されていない<xref:System.Diagnostics.EventLog.WriteEntry%2A>呼び出し<xref:System.Diagnostics.EventLog.CreateEventSource%2A>ソースを登録します。  
  
> [!NOTE]
>  指定しない場合、<xref:System.Diagnostics.EventLog.MachineName%2A>の<xref:System.Diagnostics.EventLog>インスタンスを呼び出す前に<xref:System.Diagnostics.EventLog.CreateEventSource%2A>または<xref:System.Diagnostics.EventLog.WriteEntry%2A>、ローカル コンピューター (".") と見なされます。  
  
 システムを登録する必要がある場合、<xref:System.Diagnostics.EventLog.Source%2A>呼び出しを通じて<xref:System.Diagnostics.EventLog.WriteEntry%2A>と<xref:System.Diagnostics.EventLog.Log%2A>プロパティに設定されていない、<xref:System.Diagnostics.EventLog>インスタンス、アプリケーション ログには、ログの既定値します。  
  
> [!NOTE]
>  上に示した多くの例外は、登録プロセス中に発生したエラーによって生成される、<xref:System.Diagnostics.EventLog.Source%2A>します。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接の文字列を書き込むように構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドは、イベント ログに直接指定された文字列を書き込みます。 ローカライズ可能なメッセージ リソース ファイルを使用しません。 使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>ローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルでは、1 つのソースを構成およびでは、そのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>メソッドをイベント ログのリソース識別子を使用してエントリを書き込みます。 リソースのファイルがない場合、別のソースを作成しでそのソースを使用し、<xref:System.Diagnostics.EventLog.WriteEntry%2A>そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  リモート コンピューターへのエントリを記述する場合 (文字列)、メッセージの値可能性がありますいない期待どおりでは、リモート コンピューターに .NET Framework が実行されていない場合。  
  
> [!NOTE]
>  場合、`message`パラメーターには、NUL 文字が含まれる、イベント ログにメッセージは、NUL 文字で終了します。  
  
   
  
## Examples  
 次の例では、ローカル コンピューターの"MyNewLog"イベント ログに警告エントリを書き込みます。  
  
 [!code-cpp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> の <see cref="T:System.Diagnostics.EventLog" /> プロパティが設定されていません。  
  
- または - 
メソッドが新しいイベント ソースを登録しようとしましたが、<see cref="P:System.Diagnostics.EventLog.MachineName" /> のコンピューター名が無効です。  
  
\- または 
ソースは既に別のイベント ログに登録されています。  
  
\- または 
メッセージ文字列は 31,839 バイト (Windows Vista より前の Windows オペレーティング システムでは 32,766 バイト) を超えています。  
  
\- または 
ソース名は、254 文字を超えるレジストリ キーのパスになります。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> は有効な <see cref="T:System.Diagnostics.EventLogEntryType" /> ではありません。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント エントリをイベント ログに書き込むときにオペレーティング システムからエラーが報告されました。 Windows のエラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を書き込む。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">アプリケーションを指定されたコンピューターに登録するために使用されるソース。</param>
        <param name="message">イベント ログに書き込む文字列。</param>
        <summary>指定した登録イベント ソースを使用して、種類が Information のエントリを、指定したメッセージ テキストと共にイベント ログに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用すると、適切なログのイベント ソースとして既に登録されているソースを使用して、イベント ログが information のエントリを記述できます。 その他を指定したい場合<xref:System.Diagnostics.EventLogEntryType>の異なるオーバー ロードを使用して、<xref:System.Diagnostics.EventLog.WriteEntry%2A>します。  
  
 作成し、ソースと最初のエントリを書き込む前に、イベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録済みのイベント ソースの一覧とその構成を更新するオペレーティング システムまでの時間です。 オペレーティング システムでは、イベントのソースの一覧は更新されていない場合は、書き込み操作は失敗、新しいソースを持つイベントを記述しようとしました。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド。 新しいイベント ソースを作成するコンピューターの管理者権限が必要です。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接の文字列を書き込むように構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドは、イベント ログに直接指定された文字列を書き込みます。 ローカライズ可能なメッセージ リソース ファイルを使用しません。 使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>ローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルでは、1 つのソースを構成およびでは、そのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>メソッドをイベント ログのリソース識別子を使用してエントリを書き込みます。 リソースのファイルがない場合、別のソースを作成しでそのソースを使用し、<xref:System.Diagnostics.EventLog.WriteEntry%2A>そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  場合、`message`パラメーターには、NUL 文字が含まれる、イベント ログにメッセージは、NUL 文字で終了します。  
>   
>  `message`文字列は、% を含めることはできません*n*ここで、 *n*整数値 (たとえば、%1) は、イベント ビューアーは、挿入文字列として扱います。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスはこれを含めることができます、ために、IPv6 アドレスを含むイベント メッセージがログ記録できません。  
  
   
  
## Examples  
 次の例では、ソース`MySource`が存在しない場合、イベント ログにエントリを書き込みます`MyNewLog`します。  
  
 [!code-cpp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 値が空の文字列 ("") です。  
  
\- または 
<paramref name="source" /> 値は <see langword="null" /> です。  
  
\- または 
メッセージ文字列は 31,839 バイト (Windows Vista より前の Windows オペレーティング システムでは 32,766 バイト) を超えています。  
  
\- または 
ソース名は、254 文字を超えるレジストリ キーのパスになります。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント エントリをイベント ログに書き込むときにオペレーティング システムからエラーが報告されました。 Windows のエラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を書き込む。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="message">イベント ログに書き込む文字列。</param>
        <param name="type">
          <see cref="T:System.Diagnostics.EventLogEntryType" /> 値のいずれか 1 つ。</param>
        <param name="eventID">イベントの、アプリケーション固有の識別子。</param>
        <summary>エントリを、指定したメッセージ テキストおよびアプリケーション定義のイベント識別子と共にイベント ログに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、アプリケーション定義を持つエントリを書き込む`eventID`イベント ログにします。 `eventID`ソースとイベントを一意に識別します。 各アプリケーションには、番号付きのイベントとマップ先の説明文字列を定義できます。 イベント ビューアーでは、ユーザーの問題点を理解し、実行するアクションを提案するためにこれらの文字列値を表示します。  
  
> [!NOTE]
>  `message`文字列は、% を含めることはできません*n*ここで、 *n*整数値 (たとえば、%1) は、イベント ビューアーは、挿入文字列として扱います。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスはこれを含めることができます、ために、IPv6 アドレスを含むイベント メッセージがログ記録できません。  
  
 イベント識別子、以外を指定できます、<xref:System.Diagnostics.EventLogEntryType>イベント ログに書き込まれるイベント。 `type`アイコンとテキスト ログのイベント ビューアーの種類 列で示されます。 このパラメーターは、イベントの種類がエラー、警告、情報、監査正常終了、または失敗の監査であるかどうかを示します。  
  
 設定する必要があります、<xref:System.Diagnostics.EventLog.Source%2A>プロパティを<xref:System.Diagnostics.EventLog>コンポーネントがログにエントリを記述する前にします。 作成し、ソースと最初のエントリを書き込む前に、イベント ソースを構成する必要があります。  
  
 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録済みのイベント ソースの一覧とその構成を更新するオペレーティング システムまでの時間です。 オペレーティング システムでは、イベントのソースの一覧は更新されていない場合は、書き込み操作は失敗、新しいソースを持つイベントを記述しようとしました。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド。 新しいイベント ソースを作成するコンピューターの管理者権限が必要です。  
  
 ソースが指定されている場合、<xref:System.Diagnostics.EventLog.Source%2A>このプロパティ<xref:System.Diagnostics.EventLog>コンポーネントが書き込むコンピューターのインスタンスが登録されていない<xref:System.Diagnostics.EventLog.WriteEntry%2A>呼び出し<xref:System.Diagnostics.EventLog.CreateEventSource%2A>ソースを登録します。  
  
> [!NOTE]
>  指定しない場合、<xref:System.Diagnostics.EventLog.MachineName%2A>の<xref:System.Diagnostics.EventLog>インスタンスを呼び出す前に<xref:System.Diagnostics.EventLog.CreateEventSource%2A>または<xref:System.Diagnostics.EventLog.WriteEntry%2A>、ローカル コンピューター (".") と見なされます。  
  
 システムを登録する必要がある場合、<xref:System.Diagnostics.EventLog.Source%2A>呼び出しを通じて<xref:System.Diagnostics.EventLog.WriteEntry%2A>と<xref:System.Diagnostics.EventLog.Log%2A>プロパティに設定されていない、<xref:System.Diagnostics.EventLog>インスタンス、アプリケーション ログには、ログの既定値します。  
  
> [!NOTE]
>  上に示した多くの例外は、登録プロセス中に発生したエラーによって生成される、<xref:System.Diagnostics.EventLog.Source%2A>します。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接の文字列を書き込むように構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドは、イベント ログに直接指定された文字列を書き込みます。 ローカライズ可能なメッセージ リソース ファイルを使用しません。 使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>ローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルでは、1 つのソースを構成およびでは、そのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>メソッドをイベント ログのリソース識別子を使用してエントリを書き込みます。 リソースのファイルがない場合、別のソースを作成しでそのソースを使用し、<xref:System.Diagnostics.EventLog.WriteEntry%2A>そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  リモート コンピューターへのエントリを記述する場合 (文字列)、メッセージの値可能性がありますいない期待どおりでは、リモート コンピューターに .NET Framework が実行されていない場合。  
  
> [!NOTE]
>  場合、`message`パラメーターには、NUL 文字が含まれる、イベント ログにメッセージは、NUL 文字で終了します。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> の <see cref="T:System.Diagnostics.EventLog" /> プロパティが設定されていません。  
  
- または - 
メソッドが新しいイベント ソースを登録しようとしましたが、<see cref="P:System.Diagnostics.EventLog.MachineName" /> のコンピューター名が無効です。  
  
\- または 
ソースは既に別のイベント ログに登録されています。  
  
\- または 
 <paramref name="eventID" /> が 0 未満の値か、<see cref="F:System.UInt16.MaxValue" /> より大きい値です。  
  
\- または 
メッセージ文字列は 31,839 バイト (Windows Vista より前の Windows オペレーティング システムでは 32,766 バイト) を超えています。  
  
\- または 
ソース名は、254 文字を超えるレジストリ キーのパスになります。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> は有効な <see cref="T:System.Diagnostics.EventLogEntryType" /> ではありません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント エントリをイベント ログに書き込むときにオペレーティング システムからエラーが報告されました。 Windows のエラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を書き込む。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="source">アプリケーションを指定されたコンピューターに登録するために使用されるソース。</param>
        <param name="message">イベント ログに書き込む文字列。</param>
        <param name="type">
          <see cref="T:System.Diagnostics.EventLogEntryType" /> 値のいずれか 1 つ。</param>
        <summary>指定した登録イベント ソースを使用して、エラー、警告、情報、監査正常終了、または監査エラー エントリを、指定したメッセージ テキストと共にイベント ログに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、指定したエントリの書き込み<xref:System.Diagnostics.EventLogEntryType>をイベント ログ ソースを既に使用して、適切なログのイベント ソースとして登録されています。 `type`アイコンとテキスト ログのイベント ビューアーの種類 列で示されます。  
  
> [!NOTE]
>  `message`文字列は、% を含めることはできません*n*ここで、 *n*整数値 (たとえば、%1) は、イベント ビューアーは、挿入文字列として扱います。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスはこれを含めることができます、ために、IPv6 アドレスを含むイベント メッセージがログ記録できません。  
  
 作成し、ソースと最初のエントリを書き込む前に、イベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録済みのイベント ソースの一覧とその構成を更新するオペレーティング システムまでの時間です。 オペレーティング システムでは、イベントのソースの一覧は更新されていない場合は、書き込み操作は失敗、新しいソースを持つイベントを記述しようとしました。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド。 新しいイベント ソースを作成するコンピューターの管理者権限が必要です。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接の文字列を書き込むように構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドは、イベント ログに直接指定された文字列を書き込みます。 ローカライズ可能なメッセージ リソース ファイルを使用しません。 使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>ローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルでは、1 つのソースを構成およびでは、そのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>メソッドをイベント ログのリソース識別子を使用してエントリを書き込みます。 リソースのファイルがない場合、別のソースを作成しでそのソースを使用し、<xref:System.Diagnostics.EventLog.WriteEntry%2A>そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  場合、`message`パラメーターには、NUL 文字が含まれる、イベント ログにメッセージは、NUL 文字で終了します。  
  
   
  
## Examples  
 次の例では、ローカル コンピューターの"MyNewLog"イベント ログに警告エントリを書き込みます。  
  
 [!code-cpp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 値が空の文字列 ("") です。  
  
\- または 
<paramref name="source" /> 値は <see langword="null" /> です。  
  
\- または 
メッセージ文字列は 31,839 バイト (Windows Vista より前の Windows オペレーティング システムでは 32,766 バイト) を超えています。  
  
\- または 
ソース名は、254 文字を超えるレジストリ キーのパスになります。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> は有効な <see cref="T:System.Diagnostics.EventLogEntryType" /> ではありません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント エントリをイベント ログに書き込むときにオペレーティング システムからエラーが報告されました。 Windows のエラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を書き込む。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int * int16 -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="message">イベント ログに書き込む文字列。</param>
        <param name="type">
          <see cref="T:System.Diagnostics.EventLogEntryType" /> 値のいずれか 1 つ。</param>
        <param name="eventID">イベントの、アプリケーション固有の識別子。</param>
        <param name="category">メッセージと関連付けられた、アプリケーション固有のサブカテゴリ。</param>
        <summary>指定したメッセージ テキスト、アプリケーション定義のイベント識別子、およびアプリケーション定義のカテゴリと共にエントリをイベント ログに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、アプリケーション定義を持つエントリを書き込む`category`イベント ログにします。 イベント ビューアーでは、イベント ソースによって書き込まれたイベントをフィルター処理するカテゴリを使用します。 ローカライズされたカテゴリ文字列を表示するカテゴリ リソース識別子として使用できます。 またはイベント ビューアーは、数値の値として、カテゴリを表示できます。  
  
> [!NOTE]
>  `category`パラメーターは、正の値を指定する必要があります。 負の値のカテゴリの値は、イベント ビューアーの補完的な正の数値として表示します。 たとえば、65,526、65,535 として – 1 – 10 が表示されます。  
  
> [!NOTE]
>  `message`文字列は、% を含めることはできません*n*ここで、 *n*整数値 (たとえば、%1) は、イベント ビューアーは、挿入文字列として扱います。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスはこれを含めることができます、ために、IPv6 アドレスを含むイベント メッセージがログ記録できません。  
  
 イベント ビューアーでは、ローカライズされたカテゴリ文字列を表示するには、イベント ソース、カテゴリ リソース ファイルで構成され、設定を使用する必要があります、`category`カテゴリ リソース ファイル内のリソース識別子。 構成済みのカテゴリ リソース ファイル、または指定したイベント ソースが持っていない場合`category`し、イベント ビューアーでは、そのエントリの数値のカテゴリの値を表示します。 カテゴリ リソース ファイル内の文字列のインデックスはされません。 カテゴリ リソース ファイルのリソース ファイルでカテゴリ文字列の数と構成を使用して、<xref:System.Diagnostics.EventLogInstaller>または<xref:System.Diagnostics.EventSourceCreationData>クラス。  
  
 カテゴリだけでなく、イベント ログに書き込まれるイベントのイベント識別子を指定できます。 イベント識別子、イベント ソースおよびイベントを一意に識別します。 各アプリケーションには、番号付きのイベントとマップ先の説明文字列を定義できます。 イベント ビューアーでは、ユーザーの問題点を理解し、実行するアクションを提案するためにこれらの文字列値を表示します。  
  
 最後に、指定、<xref:System.Diagnostics.EventLogEntryType>イベント ログに書き込まれるイベント。 `type`アイコンとテキスト ログのイベント ビューアーの種類 列で示されます。 このパラメーターは、イベントの種類がエラー、警告、情報、監査正常終了、または失敗の監査であるかどうかを示します。  
  
 設定する必要があります、<xref:System.Diagnostics.EventLog.Source%2A>プロパティを<xref:System.Diagnostics.EventLog>コンポーネントがログにエントリを記述する前にします。 作成し、ソースと最初のエントリを書き込む前に、イベント ソースを構成する必要があります。  
  
 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録済みのイベント ソースの一覧とその構成を更新するオペレーティング システムまでの時間です。 オペレーティング システムでは、イベントのソースの一覧は更新されていない場合は、書き込み操作は失敗、新しいソースを持つイベントを記述しようとしました。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド。 新しいイベント ソースを作成するコンピューターの管理者権限が必要です。  
  
 ソースが指定されている場合、<xref:System.Diagnostics.EventLog.Source%2A>このプロパティ<xref:System.Diagnostics.EventLog>コンポーネントが書き込むコンピューターのインスタンスが登録されていない<xref:System.Diagnostics.EventLog.WriteEntry%2A>呼び出し<xref:System.Diagnostics.EventLog.CreateEventSource%2A>ソースを登録します。  
  
> [!NOTE]
>  指定しない場合、<xref:System.Diagnostics.EventLog.MachineName%2A>の<xref:System.Diagnostics.EventLog>インスタンスを呼び出す前に<xref:System.Diagnostics.EventLog.CreateEventSource%2A>または<xref:System.Diagnostics.EventLog.WriteEntry%2A>、ローカル コンピューター (".") と見なされます。  
  
 システムを登録する必要がある場合、<xref:System.Diagnostics.EventLog.Source%2A>呼び出しを通じて<xref:System.Diagnostics.EventLog.WriteEntry%2A>と<xref:System.Diagnostics.EventLog.Log%2A>プロパティに設定されていない、<xref:System.Diagnostics.EventLog>インスタンス、アプリケーション ログには、ログの既定値します。  
  
> [!NOTE]
>  上に示した多くの例外は、登録プロセス中に発生したエラーによって生成される、<xref:System.Diagnostics.EventLog.Source%2A>します。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接の文字列を書き込むように構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドは、イベント ログに直接指定された文字列を書き込みます。 ローカライズ可能なメッセージ リソース ファイルを使用しません。 使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>ローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルでは、1 つのソースを構成およびでは、そのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>メソッドをイベント ログのリソース識別子を使用してエントリを書き込みます。 リソースのファイルがない場合、別のソースを作成しでそのソースを使用し、<xref:System.Diagnostics.EventLog.WriteEntry%2A>そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  リモート コンピューターへのエントリを記述する場合 (文字列)、メッセージの値可能性がありますいない期待どおりでは、リモート コンピューターに .NET Framework が実行されていない場合。  
  
> [!NOTE]
>  場合、`message`パラメーターには、NUL 文字が含まれる、イベント ログにメッセージは、NUL 文字で終了します。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> の <see cref="T:System.Diagnostics.EventLog" /> プロパティが設定されていません。  
  
- または - 
メソッドが新しいイベント ソースを登録しようとしましたが、<see cref="P:System.Diagnostics.EventLog.MachineName" /> のコンピューター名が無効です。  
  
\- または 
ソースは既に別のイベント ログに登録されています。  
  
\- または 
 <paramref name="eventID" /> が 0 未満の値か、<see cref="F:System.UInt16.MaxValue" /> より大きい値です。  
  
\- または 
メッセージ文字列は 31,839 バイト (Windows Vista より前の Windows オペレーティング システムでは 32,766 バイト) を超えています。  
  
\- または 
ソース名は、254 文字を超えるレジストリ キーのパスになります。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> は有効な <see cref="T:System.Diagnostics.EventLogEntryType" /> ではありません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント エントリをイベント ログに書き込むときにオペレーティング システムからエラーが報告されました。 Windows のエラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を書き込む。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">アプリケーションを指定されたコンピューターに登録するために使用されるソース。</param>
        <param name="message">イベント ログに書き込む文字列。</param>
        <param name="type">
          <see cref="T:System.Diagnostics.EventLogEntryType" /> 値のいずれか 1 つ。</param>
        <param name="eventID">イベントの、アプリケーション固有の識別子。</param>
        <summary>指定した登録イベント ソースを使用して、指定したメッセージ テキストおよびアプリケーション定義のイベント識別子と共にエントリをイベント ログに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、アプリケーション定義を持つエントリを書き込む`eventID`をイベント ログ ソースを既に使用して、適切なログのイベント ソースとして登録されています。 `eventID`ソースとイベントを一意に識別します。 各アプリケーションには、番号付きのイベントとマップ先の説明文字列を定義できます。 イベント ビューアーでは、ユーザーの問題点を理解し、実行するアクションを提案するためにユーザーにこれらの文字列を提示します。  
  
> [!NOTE]
>  `message`文字列は、% を含めることはできません*n*ここで、 *n*整数値 (たとえば、%1) は、イベント ビューアーは、挿入文字列として扱います。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスはこれを含めることができます、ために、IPv6 アドレスを含むイベント メッセージがログ記録できません。  
  
 このオーバー ロードだけでなく、イベント識別子、<xref:System.Diagnostics.EventLog.WriteEntry%2A>を指定することができます、<xref:System.Diagnostics.EventLogEntryType>イベント ログに書き込まれるイベント。 `type`アイコンとテキスト ログのイベント ビューアーの種類 列で示されます。 このパラメーターは、イベントの種類がエラー、警告、情報、監査正常終了、または失敗の監査であるかどうかを示します。  
  
 作成し、ソースと最初のエントリを書き込む前に、イベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録済みのイベント ソースの一覧とその構成を更新するオペレーティング システムまでの時間です。 オペレーティング システムでは、イベントのソースの一覧は更新されていない場合は、書き込み操作は失敗、新しいソースを持つイベントを記述しようとしました。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド。 新しいイベント ソースを作成するコンピューターの管理者権限が必要です。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接の文字列を書き込むように構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドは、イベント ログに直接指定された文字列を書き込みます。 ローカライズ可能なメッセージ リソース ファイルを使用しません。 使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>ローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルでは、1 つのソースを構成およびでは、そのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>メソッドをイベント ログのリソース識別子を使用してエントリを書き込みます。 リソースのファイルがない場合、別のソースを作成しでそのソースを使用し、<xref:System.Diagnostics.EventLog.WriteEntry%2A>そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  場合、`message`パラメーターには、NUL 文字が含まれる、イベント ログにメッセージは、NUL 文字で終了します。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_4#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_4/CPP/eventlog_writeentry_4.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_4#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_4/CS/eventlog_writeentry_4.cs#1)]
 [!code-vb[EventLog_WriteEntry_4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_4/VB/eventlog_writeentry_4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 値が空の文字列 ("") です。  
  
\- または 
<paramref name="source" /> 値は <see langword="null" /> です。  
  
\- または 
 <paramref name="eventID" /> が 0 未満の値か、<see cref="F:System.UInt16.MaxValue" /> より大きい値です。  
  
\- または 
メッセージ文字列は 31,839 バイト (Windows Vista より前の Windows オペレーティング システムでは 32,766 バイト) を超えています。  
  
\- または 
ソース名は、254 文字を超えるレジストリ キーのパスになります。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> は有効な <see cref="T:System.Diagnostics.EventLogEntryType" /> ではありません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント エントリをイベント ログに書き込むときにオペレーティング システムからエラーが報告されました。 Windows のエラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を書き込む。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int * int16 * byte[] -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID, category, rawData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="message">イベント ログに書き込む文字列。</param>
        <param name="type">
          <see cref="T:System.Diagnostics.EventLogEntryType" /> 値のいずれか 1 つ。</param>
        <param name="eventID">イベントの、アプリケーション固有の識別子。</param>
        <param name="category">メッセージと関連付けられた、アプリケーション固有のサブカテゴリ。</param>
        <param name="rawData">エントリに関連付けられているバイナリ データを保持するバイト配列。</param>
        <summary>指定したメッセージ テキスト、アプリケーション定義のイベント識別子、およびアプリケーション定義のカテゴリと共にエントリをイベント ログに書き込み、メッセージにバイナリ データを付加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用すると、イベント ログにイベント固有のデータをアプリケーション定義を記述できます。 イベント ビューアーでこのデータを解釈しません結合の 16 進数およびテキスト形式でのみ、生データを表示します。 だれかが問題のデバッグに役に立つことを確認する場合にだけ、イベントに固有のデータを使用します。 イベント ビューアーとは無関係に、アプリケーションが処理できる情報を格納するのにイベントに固有のデータを使用することもできます。 たとえば、具体的には、イベントのビューアーを記述したり、ログ ファイルをスキャンし、イベントに固有のデータから情報を含むレポートを作成するプログラムを記述します。  
  
 バイナリのデータだけでなく、アプリケーション定義のカテゴリと、アプリケーション定義のイベント識別子を指定できます。 イベント ビューアーでは、イベント ソースによって書き込まれたイベントをフィルター処理するカテゴリを使用します。 ローカライズされたカテゴリ文字列を表示するカテゴリ リソース識別子として使用できます。 またはイベント ビューアーは、数値の値として、カテゴリを表示できます。  
  
> [!NOTE]
>  `message`文字列は、% を含めることはできません*n*ここで、 *n*整数値 (たとえば、%1) は、イベント ビューアーは、挿入文字列として扱います。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスはこれを含めることができます、ために、IPv6 アドレスを含むイベント メッセージがログ記録できません。  
  
> [!NOTE]
>  `category`パラメーターは、正の値を指定する必要があります。 負の値のカテゴリの値は、イベント ビューアーの補完的な正の数値として表示します。 たとえば、65,526、65,535 として – 1 – 10 が表示されます。  
  
 イベント ビューアーでは、ローカライズされたカテゴリ文字列を表示するには、イベント ソース、カテゴリ リソース ファイルで構成され、設定を使用する必要があります、`category`カテゴリ リソース ファイル内のリソース識別子。 構成済みのカテゴリ リソース ファイル、または指定したイベント ソースが持っていない場合`category`し、イベント ビューアーでは、そのエントリの数値のカテゴリの値を表示します。 カテゴリ リソース ファイル内の文字列のインデックスはされません。 カテゴリ リソース ファイルのリソース ファイルでカテゴリ文字列の数と構成を使用して、<xref:System.Diagnostics.EventLogInstaller>または<xref:System.Diagnostics.EventSourceCreationData>クラス。  
  
 イベント識別子、イベント ソースおよびイベントを一意に識別します。 各アプリケーションには、番号付きのイベントとマップ先の説明文字列を定義できます。 イベント ビューアーでは、ユーザーの問題点を理解し、実行するアクションを提案するためにこれらの文字列値を表示します。  
  
 最後に、指定、<xref:System.Diagnostics.EventLogEntryType>イベント ログに書き込まれるイベント。 `type`アイコンとテキスト ログのイベント ビューアーの種類 列で示されます。 このパラメーターは、イベントの種類がエラー、警告、情報、監査正常終了、または失敗の監査であるかどうかを示します。  
  
 設定する必要があります、<xref:System.Diagnostics.EventLog.Source%2A>プロパティを<xref:System.Diagnostics.EventLog>コンポーネントがログにエントリを記述する前にします。 作成し、ソースと最初のエントリを書き込む前に、イベント ソースを構成する必要があります。  
  
 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録済みのイベント ソースの一覧とその構成を更新するオペレーティング システムまでの時間です。 オペレーティング システムでは、イベントのソースの一覧は更新されていない場合は、書き込み操作は失敗、新しいソースを持つイベントを記述しようとしました。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド。 新しいイベント ソースを作成するコンピューターの管理者権限が必要です。  
  
 ソースが指定されている場合、<xref:System.Diagnostics.EventLog.Source%2A>このプロパティ<xref:System.Diagnostics.EventLog>コンポーネントが書き込むコンピューターのインスタンスが登録されていない<xref:System.Diagnostics.EventLog.WriteEntry%2A>呼び出し<xref:System.Diagnostics.EventLog.CreateEventSource%2A>ソースを登録します。  
  
> [!NOTE]
>  指定しない場合、<xref:System.Diagnostics.EventLog.MachineName%2A>の<xref:System.Diagnostics.EventLog>インスタンスを呼び出す前に<xref:System.Diagnostics.EventLog.CreateEventSource%2A>または<xref:System.Diagnostics.EventLog.WriteEntry%2A>、ローカル コンピューター (".") と見なされます。  
  
 システムを登録する必要がある場合、<xref:System.Diagnostics.EventLog.Source%2A>呼び出しを通じて<xref:System.Diagnostics.EventLog.WriteEntry%2A>と<xref:System.Diagnostics.EventLog.Log%2A>プロパティに設定されていない、<xref:System.Diagnostics.EventLog>インスタンス、アプリケーション ログには、ログの既定値します。  
  
> [!NOTE]
>  上に示した多くの例外は、登録プロセス中に発生したエラーによって生成される、<xref:System.Diagnostics.EventLog.Source%2A>します。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接の文字列を書き込むように構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドは、イベント ログに直接指定された文字列を書き込みます。 ローカライズ可能なメッセージ リソース ファイルを使用しません。 使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>ローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルでは、1 つのソースを構成およびでは、そのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>メソッドをイベント ログのリソース識別子を使用してエントリを書き込みます。 リソースのファイルがない場合、別のソースを作成しでそのソースを使用し、<xref:System.Diagnostics.EventLog.WriteEntry%2A>そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  リモート コンピューターへのエントリを記述する場合 (文字列)、メッセージの値可能性がありますいない期待どおりでは、リモート コンピューターに .NET Framework が実行されていない場合。  
  
> [!NOTE]
>  場合、`message`パラメーターには、NUL 文字が含まれる、イベント ログにメッセージは、NUL 文字で終了します。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_5#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_5/CPP/eventlog_writeentry_5.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_5#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_5/CS/eventlog_writeentry_5.cs#1)]
 [!code-vb[EventLog_WriteEntry_5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_5/VB/eventlog_writeentry_5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> の <see cref="T:System.Diagnostics.EventLog" /> プロパティが設定されていません。  
  
- または - 
メソッドが新しいイベント ソースを登録しようとしましたが、<see cref="P:System.Diagnostics.EventLog.MachineName" /> のコンピューター名が無効です。  
  
\- または 
ソースは既に別のイベント ログに登録されています。  
  
\- または 
 <paramref name="eventID" /> が 0 未満の値か、<see cref="F:System.UInt16.MaxValue" /> より大きい値です。  
  
\- または 
メッセージ文字列は 31,839 バイト (Windows Vista より前の Windows オペレーティング システムでは 32,766 バイト) を超えています。  
  
\- または 
ソース名は、254 文字を超えるレジストリ キーのパスになります。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> は有効な <see cref="T:System.Diagnostics.EventLogEntryType" /> ではありません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント エントリをイベント ログに書き込むときにオペレーティング システムからエラーが報告されました。 Windows のエラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を書き込む。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int * int16 -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="source">アプリケーションを指定されたコンピューターに登録するために使用されるソース。</param>
        <param name="message">イベント ログに書き込む文字列。</param>
        <param name="type">
          <see cref="T:System.Diagnostics.EventLogEntryType" /> 値のいずれか 1 つ。</param>
        <param name="eventID">イベントの、アプリケーション固有の識別子。</param>
        <param name="category">メッセージと関連付けられた、アプリケーション固有のサブカテゴリ。</param>
        <summary>指定した登録イベント ソースを使用して、メッセージ テキスト、アプリケーション定義のイベント識別子、およびアプリケーション定義のカテゴリと共にエントリをイベント ログに書き込みます。 <paramref name="category" /> は、イベント ビューアーでログ内のイベントをフィルター処理するときに使用できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、アプリケーション定義を持つエントリを書き込む`category`イベント ログに適切なログのイベント ソースとして既に登録されているソースを使用します。 イベント ビューアーでは、イベント ソースによって書き込まれたイベントをフィルター処理するカテゴリを使用します。 ローカライズされたカテゴリ文字列を表示するカテゴリ リソース識別子として使用できます。 またはイベント ビューアーは、数値の値として、カテゴリを表示できます。  
  
> [!NOTE]
>  `category`パラメーターは、正の値を指定する必要があります。 負の値のカテゴリの値は、イベント ビューアーの補完的な正の数値として表示します。 たとえば、65,526、65,535 として – 1 – 10 が表示されます。  
  
 イベント ビューアーでは、ローカライズされたカテゴリ文字列を表示するには、イベント ソース、カテゴリ リソース ファイルで構成され、設定を使用する必要があります、`category`カテゴリ リソース ファイル内のリソース識別子。 構成済みのカテゴリ リソース ファイル、または指定したイベント ソースが持っていない場合`category`し、イベント ビューアーでは、そのエントリの数値のカテゴリの値を表示します。 カテゴリ リソース ファイル内の文字列のインデックスはされません。 カテゴリ リソース ファイルのリソース ファイルでカテゴリ文字列の数と構成を使用して、<xref:System.Diagnostics.EventLogInstaller>または<xref:System.Diagnostics.EventSourceCreationData>クラス。  
  
 カテゴリだけでなく、イベント ログに書き込まれるイベントのイベント識別子を指定できます。 イベント識別子、イベント ソースおよびイベントを一意に識別します。 各アプリケーションには、番号付きのイベントとマップ先の説明文字列を定義できます。 イベント ビューアーでは、ユーザーの問題点を理解し、実行するアクションを提案するためにこれらの文字列値を表示します。  
  
 最後に、指定、<xref:System.Diagnostics.EventLogEntryType>イベント ログに書き込まれるイベント。 `type`アイコンとテキスト ログのイベント ビューアーの種類 列で示されます。 このパラメーターは、イベントの種類がエラー、警告、情報、監査正常終了、または失敗の監査であるかどうかを示します。  
  
 作成し、ソースと最初のエントリを書き込む前に、イベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録済みのイベント ソースの一覧とその構成を更新するオペレーティング システムまでの時間です。 オペレーティング システムでは、イベントのソースの一覧は更新されていない場合は、書き込み操作は失敗、新しいソースを持つイベントを記述しようとしました。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド。 新しいイベント ソースを作成するコンピューターの管理者権限が必要です。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接の文字列を書き込むように構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドは、イベント ログに直接指定された文字列を書き込みます。 ローカライズ可能なメッセージ リソース ファイルを使用しません。 使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>ローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルでは、1 つのソースを構成およびでは、そのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>メソッドをイベント ログのリソース識別子を使用してエントリを書き込みます。 リソースのファイルがない場合、別のソースを作成しでそのソースを使用し、<xref:System.Diagnostics.EventLog.WriteEntry%2A>そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  場合、`message`パラメーターには、NUL 文字が含まれる、イベント ログにメッセージは、NUL 文字で終了します。  
>   
>  `message`文字列は、% を含めることはできません*n*ここで、 *n*整数値 (たとえば、%1) は、イベント ビューアーは、挿入文字列として扱います。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスはこれを含めることができます、ために、IPv6 アドレスを含むイベント メッセージがログ記録できません。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_1_3#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#1)]
 [!code-vb[EventLog_WriteEntry_1_3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 値が空の文字列 ("") です。  
  
\- または 
<paramref name="source" /> 値は <see langword="null" /> です。  
  
\- または 
 <paramref name="eventID" /> が 0 未満の値か、<see cref="F:System.UInt16.MaxValue" /> より大きい値です。  
  
\- または 
メッセージ文字列は 31,839 バイト (Windows Vista より前の Windows オペレーティング システムでは 32,766 バイト) を超えています。  
  
\- または 
ソース名は、254 文字を超えるレジストリ キーのパスになります。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> は有効な <see cref="T:System.Diagnostics.EventLogEntryType" /> ではありません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント エントリをイベント ログに書き込むときにオペレーティング システムからエラーが報告されました。 Windows のエラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を書き込む。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int * int16 * byte[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID, category, rawData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="source">アプリケーションを指定されたコンピューターに登録するために使用されるソース。</param>
        <param name="message">イベント ログに書き込む文字列。</param>
        <param name="type">
          <see cref="T:System.Diagnostics.EventLogEntryType" /> 値のいずれか 1 つ。</param>
        <param name="eventID">イベントの、アプリケーション固有の識別子。</param>
        <param name="category">メッセージと関連付けられた、アプリケーション固有のサブカテゴリ。</param>
        <param name="rawData">エントリに関連付けられているバイナリ データを保持するバイト配列。</param>
        <summary>指定した登録イベント ソースを使用して、指定したメッセージ テキスト、アプリケーション定義のイベント識別子、およびアプリケーション定義のカテゴリと共にエントリをイベント ログに書き込み、メッセージにバイナリ データを付加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アプリケーションで定義されたイベントに固有のデータを適切なログのイベント ソースとして既に登録されているソースを使用して、イベント ログに書き込むには、このメソッドを使用します。 イベント ビューアーでこのデータを解釈しません結合の 16 進数およびテキスト形式でのみ、生データを表示します。 イベントに固有のデータを多用します。役に立つことを確認する場合にのみ含めます。 イベント ビューアーとは無関係に、アプリケーションが処理できる情報を格納するのにイベントに固有のデータを使用することもできます。 たとえば、具体的には、イベントのビューアーを記述したり、ログ ファイルをスキャンし、イベントに固有のデータから情報を含むレポートを作成するプログラムを記述します。  
  
 バイナリのデータだけでなく、アプリケーション定義のカテゴリと、アプリケーション定義のイベント識別子を指定できます。 イベント ビューアーでは、イベント ソースによって書き込まれたイベントをフィルター処理するカテゴリを使用します。 ローカライズされたカテゴリ文字列を表示するカテゴリ リソース識別子として使用できます。 またはイベント ビューアーは、数値の値として、カテゴリを表示できます。  
  
> [!NOTE]
>  `category`パラメーターは、正の値を指定する必要があります。 負の値のカテゴリの値は、イベント ビューアーの補完的な正の数値として表示します。 たとえば、– 10 は、65,526、65,535 として – 1 として表示されます。  
  
 イベント ビューアーでは、ローカライズされたカテゴリ文字列を表示するには、イベント ソース、カテゴリ リソース ファイルで構成され、設定を使用する必要があります、`category`カテゴリ リソース ファイル内のリソース識別子。 構成済みのカテゴリ リソース ファイル、または指定したイベント ソースが持っていない場合`category`し、イベント ビューアーでは、そのエントリの数値のカテゴリの値を表示します。 カテゴリ リソース ファイル内の文字列のインデックスはされません。 カテゴリ リソース ファイルのリソース ファイルでカテゴリ文字列の数と構成を使用して、<xref:System.Diagnostics.EventLogInstaller>または<xref:System.Diagnostics.EventSourceCreationData>クラス。  
  
 イベント識別子、と共に、イベント ソースは、イベントを一意に識別します。 各アプリケーションには、番号付きのイベントとマップ先の説明文字列を定義できます。 イベント ビューアーでは、ユーザーの問題点を理解し、実行するアクションを提案するためにこれらの文字列値を表示します。  
  
 最後に、指定、<xref:System.Diagnostics.EventLogEntryType>イベント ログに書き込まれるイベント。 `type`アイコンとテキスト ログのイベント ビューアーの種類 列で示されます。 このパラメーターは、イベントの種類がエラー、警告、情報、監査正常終了、または失敗の監査であるかどうかを示します。  
  
 作成し、ソースと最初のエントリを書き込む前に、イベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録済みのイベント ソースの一覧とその構成を更新するオペレーティング システムまでの時間です。 オペレーティング システムでは、イベントのソースの一覧は更新されていない場合は、書き込み操作は失敗、新しいソースを持つイベントを記述しようとしました。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド。 新しいイベント ソースを作成するコンピューターの管理者権限が必要です。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接の文字列を書き込むように構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドは、イベント ログに直接指定された文字列を書き込みます。 ローカライズ可能なメッセージ リソース ファイルを使用しません。 使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>ローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルでは、1 つのソースを構成およびでは、そのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>メソッドをイベント ログのリソース識別子を使用してエントリを書き込みます。 リソースのファイルがない場合、別のソースを作成しでそのソースを使用し、<xref:System.Diagnostics.EventLog.WriteEntry%2A>そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  場合、`message`パラメーターには、NUL 文字が含まれる、イベント ログにメッセージは、NUL 文字で終了します。  
>   
>  `message`文字列は、% を含めることはできません*n*ここで、 *n*整数値 (たとえば、%1) は、イベント ビューアーは、挿入文字列として扱います。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスはこれを含めることができます、ために、IPv6 アドレスを含むイベント メッセージがログ記録できません。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#2)]
 [!code-csharp[EventLog_WriteEntry_1_3#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#2)]
 [!code-vb[EventLog_WriteEntry_1_3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 値が空の文字列 ("") です。  
  
\- または 
<paramref name="source" /> 値は <see langword="null" /> です。  
  
\- または 
 <paramref name="eventID" /> が 0 未満の値か、<see cref="F:System.UInt16.MaxValue" /> より大きい値です。  
  
\- または 
メッセージ文字列は 31,839 バイト (Windows Vista より前の Windows オペレーティング システムでは 32,766 バイト) を超えています。  
  
\- または 
ソース名は、254 文字を超えるレジストリ キーのパスになります。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> は有効な <see cref="T:System.Diagnostics.EventLogEntryType" /> ではありません。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント エントリをイベント ログに書き込むときにオペレーティング システムからエラーが報告されました。 Windows のエラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を書き込む。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEvent">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ローカライズされたイベント エントリをイベント ログに書き込みます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : System.Diagnostics.EventInstance * obj[] -&gt; unit" Usage="eventLog.WriteEvent (instance, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">ローカライズされたイベント ログ エントリを表す <see cref="T:System.Diagnostics.EventInstance" /> インスタンス。</param>
        <param name="values">イベント ログ エントリのメッセージ テキストにマージする文字列の配列。</param>
        <summary>ローカライズされたエントリをイベント ログに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ローカライズされたエントリをイベント ログに書き込むには、このメソッドを使用します。 文字列値ではなく、リソース識別子では、イベントのプロパティを指定します。 イベント ビューアーでは、リソース識別子を使用して、ローカライズされたリソース ファイルから対応する文字列を表示、<xref:System.Diagnostics.EventLog.Source%2A>します。 リソース識別子を使用してイベントを記述する前に、対応するリソース ファイルとソースを登録する必要があります。  
  
 入力`instance`インスタンスは、イベント メッセージとプロパティを指定します。 設定、<xref:System.Diagnostics.EventInstance.InstanceId%2A>の`instance`ソース メッセージ リソース ファイルで定義されたメッセージを入力します。 必要に応じて設定することができます、<xref:System.Diagnostics.EventInstance.CategoryId%2A>と<xref:System.Diagnostics.EventInstance.EntryType%2A>の`instance`イベント エントリのカテゴリとイベントの種類を定義する入力。 ローカライズされたメッセージ テキストに挿入する言語に依存しない文字列の配列を指定することもできます。 設定`values`に`null`イベント メッセージに置換文字列の書式設定プレース ホルダーが含まれていない場合。  
  
 設定する必要があります、<xref:System.Diagnostics.EventLog.Source%2A>プロパティを<xref:System.Diagnostics.EventLog>コンポーネントを使用する前に<xref:System.Diagnostics.EventLog.WriteEvent%2A>します。 指定したソースは、ローカライズされたエントリをログに書き込むように構成する必要があります。ソースには少なくとも必要メッセージ リソース ファイルの定義です。  
  
 作成し、ソースと最初のエントリを書き込む前に、イベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録済みのイベント ソースの一覧とその構成を更新するオペレーティング システムまでの時間です。 オペレーティング システムでは、イベントのソースの一覧は更新されていない場合は、書き込み操作は失敗、新しいソースを持つイベントを記述しようとしました。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド。 新しいイベント ソースを作成するコンピューターの管理者権限が必要です。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接の文字列を書き込むように構成する必要があります。 使用して、<xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドの場合は、アプリケーション イベント ログに直接文字列値を書き込みます。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルでは、1 つのソースを構成およびでは、そのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>メソッドをイベント ログのリソース識別子を使用してエントリを書き込みます。 リソースのファイルがない場合、別のソースを作成しでそのソースを使用し、<xref:System.Diagnostics.EventLog.WriteEntry%2A>そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  リモート コンピューターの値には、エントリを記述するかどうか、`message`文字列は、リモート コンピューターに .NET Framework が実行されていない場合に期待はない可能性があります。 また、`message`文字列は、% を含めることはできません*n*ここで、 *n*整数値 (たとえば、%1) は、イベント ビューアーは、挿入文字列として扱います。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスはこれを含めることができます、ために、IPv6 アドレスを含むイベント メッセージがログ記録できません。  
  
   
  
## Examples  
 次の例は、2 つの監査イベント ログにエントリを書き込みます`myNewLog`します。 ローカル コンピューターに存在しない場合は、例では、新しいイベント ソースおよび新しいイベント ログを作成します。 リソース ファイル内のリソース識別子を使用してイベントのメッセージ テキストを指定します。  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 EventLogMsgs.dll リソース ライブラリに組み込まれている次のメッセージのテキスト ファイルを使用します。 メッセージのテキスト ファイルは、メッセージ リソース ファイルの作成元のソースです。 メッセージのテキスト ファイルでは、リソース識別子とカテゴリ、イベント メッセージ、およびパラメーターの挿入文字列のテキストを定義します。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> の <see cref="T:System.Diagnostics.EventLog" /> プロパティが設定されていません。  
  
- または - 
メソッドが新しいイベント ソースを登録しようとしましたが、<see cref="P:System.Diagnostics.EventLog.MachineName" /> のコンピューター名が無効です。  
  
\- または 
ソースは既に別のイベント ログに登録されています。  
  
\- または 
 <paramref name="instance.InstanceId" /> が 0 未満の値か、<see cref="F:System.UInt16.MaxValue" /> より大きい値です。  
  
\- または 
 <paramref name="values" /> には 256 を超える要素が格納されています。  
  
\- または 
<paramref name="values" /> 要素の 1 つが 32766 バイトを超えています。  
  
\- または 
ソース名は、254 文字を超えるレジストリ キーのパスになります。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント エントリをイベント ログに書き込むときにオペレーティング システムからエラーが報告されました。 Windows のエラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を書き込む。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : System.Diagnostics.EventInstance * byte[] * obj[] -&gt; unit" Usage="eventLog.WriteEvent (instance, data, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">ローカライズされたイベント ログ エントリを表す <see cref="T:System.Diagnostics.EventInstance" /> インスタンス。</param>
        <param name="data">エントリに関連付けられているバイナリ データを保持するバイト配列。</param>
        <param name="values">イベント ログ エントリのメッセージ テキストにマージする文字列の配列。</param>
        <summary>指定したイベント データ、メッセージ置換文字列、および関連するバイナリ データと共にイベント ログ エントリを書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用すると、イベント ログに追加のイベントに固有のデータのローカライズされたエントリを記述できます。 文字列値ではなく、リソース識別子では、イベントのプロパティを指定します。 イベント ビューアーでは、リソース識別子を使用して、ローカライズされたリソース ファイルから対応する文字列を表示、<xref:System.Diagnostics.EventLog.Source%2A>します。 リソース識別子を使用してイベントを記述する前に、対応するリソース ファイルとソースを登録する必要があります。  
  
 入力`instance`インスタンスは、イベント メッセージとプロパティを指定します。 設定、<xref:System.Diagnostics.EventInstance.InstanceId%2A>の`instance`ソース メッセージ リソース ファイルで定義されたメッセージを入力します。 必要に応じて設定することができます、<xref:System.Diagnostics.EventInstance.CategoryId%2A>と<xref:System.Diagnostics.EventInstance.EntryType%2A>の`instance`イベント エントリのカテゴリとイベントの種類を定義する入力。 ローカライズされたメッセージ テキストに挿入する言語に依存しない文字列の配列を指定することもできます。 設定`values`に`null`イベント メッセージに置換文字列の書式設定プレース ホルダーが含まれていない場合。  
  
 イベントのイベントの追加の詳細を提供する必要がある場合に、バイナリ データを指定します。 たとえば、使用して、`data`パラメーターは、特定のエラーに関する情報を含めます。 イベント ビューアーでは、関連付けられたイベント データを解釈しません16 進数およびテキストを組み合わせた形式でデータを表示します。 イベントに固有のデータを多用します。役に立つことを確認する場合にのみ含めます。 イベント ビューアーとは無関係に、アプリケーションが処理できる情報を格納するのにイベントに固有のデータを使用することもできます。 たとえば、具体的には、イベントのビューアーを記述したり、イベント ログをスキャンし、イベントに固有のデータから情報を含むレポートを作成するプログラムを記述します。  
  
 設定する必要があります、<xref:System.Diagnostics.EventLog.Source%2A>プロパティを<xref:System.Diagnostics.EventLog>コンポーネントを使用する前にコンポーネントの前に<xref:System.Diagnostics.EventLog.WriteEvent%2A>します。 指定したソースは、ローカライズされたエントリをログに書き込むように構成する必要があります。ソースには少なくとも必要メッセージ リソース ファイルの定義です。  
  
 作成し、ソースと最初のエントリを書き込む前に、イベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録済みのイベント ソースの一覧とその構成を更新するオペレーティング システムまでの時間です。 オペレーティング システムでは、イベントのソースの一覧は更新されていない場合は、書き込み操作は失敗、新しいソースを持つイベントを記述しようとしました。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド。 新しいイベント ソースを作成するコンピューターの管理者権限が必要です。  
  
> [!NOTE]
>  指定しない場合、<xref:System.Diagnostics.EventLog.MachineName%2A>の<xref:System.Diagnostics.EventLog>インスタンスを呼び出す前に<xref:System.Diagnostics.EventLog.WriteEvent%2A>、ローカル コンピューター (".") と見なされます。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接の文字列を書き込むように構成する必要があります。 使用して、<xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドの場合は、アプリケーション イベント ログに直接文字列値を書き込みます。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルでは、1 つのソースを構成およびでは、そのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>メソッドをイベント ログのリソース識別子を使用してエントリを書き込みます。 リソースのファイルがない場合、別のソースを作成しでそのソースを使用し、<xref:System.Diagnostics.EventLog.WriteEntry%2A>そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  リモート コンピューターの値には、エントリを記述するかどうか、`message`文字列は、リモート コンピューターに .NET Framework が実行されていない場合に期待はない可能性があります。 また、`message`文字列は、% を含めることはできません*n*ここで、 *n*整数値 (たとえば、%1) は、イベント ビューアーは、挿入文字列として扱います。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスはこれを含めることができます、ために、IPv6 アドレスを含むイベント メッセージがログ記録できません。  
  
   
  
## Examples  
 次の例は、2 つの監査イベント ログにエントリを書き込みます`myNewLog`します。 ローカル コンピューターに存在しない場合は、例では、新しいイベント ソースおよび新しいイベント ログを作成します。 リソース ファイル内のリソース識別子を使用してイベントのメッセージ テキストを指定します。  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 EventLogMsgs.dll リソース ライブラリに組み込まれている次のメッセージのテキスト ファイルを使用します。 メッセージのテキスト ファイルは、メッセージ リソース ファイルの作成元のソースです。 メッセージのテキスト ファイルでは、リソース識別子とカテゴリ、イベント メッセージ、およびパラメーターの挿入文字列のテキストを定義します。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> の <see cref="T:System.Diagnostics.EventLog" /> プロパティが設定されていません。  
  
- または - 
メソッドが新しいイベント ソースを登録しようとしましたが、<see cref="P:System.Diagnostics.EventLog.MachineName" /> のコンピューター名が無効です。  
  
\- または 
ソースは既に別のイベント ログに登録されています。  
  
\- または 
 <paramref name="instance.InstanceId" /> が 0 未満の値か、<see cref="F:System.UInt16.MaxValue" /> より大きい値です。  
  
\- または 
 <paramref name="values" /> には 256 を超える要素が格納されています。  
  
\- または 
<paramref name="values" /> 要素の 1 つが 32766 バイトを超えています。  
  
\- または 
ソース名は、254 文字を超えるレジストリ キーのパスになります。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント エントリをイベント ログに書き込むときにオペレーティング システムからエラーが報告されました。 Windows のエラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を書き込む。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member WriteEvent : string * System.Diagnostics.EventInstance * obj[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEvent (source, instance, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">指定したコンピューター上のアプリケーションに登録されるイベント ソースの名前。</param>
        <param name="instance">ローカライズされたイベント ログ エントリを表す <see cref="T:System.Diagnostics.EventInstance" /> インスタンス。</param>
        <param name="values">イベント ログ エントリのメッセージ テキストにマージする文字列の配列。</param>
        <summary>指定した登録イベント ソースを使用して、指定したイベント データとメッセージ置換文字列と共にイベント ログ エントリを書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ローカライズされたエントリを適切なログのイベント ソースとして既に登録されているソースを使用して、イベント ログに書き込むには、このメソッドを使用します。 文字列値ではなく、リソース識別子では、イベントのプロパティを指定します。 イベント ビューアーでは、リソース識別子を使用して、ソースのローカライズされたリソース ファイルから対応する文字列を表示します。 リソース識別子を使用してイベントを記述する前に、対応するリソース ファイルとソースを登録する必要があります。  
  
 入力`instance`インスタンスは、イベント メッセージとプロパティを指定します。 設定、<xref:System.Diagnostics.EventInstance.InstanceId%2A>の`instance`ソース メッセージ リソース ファイルで定義されたメッセージを入力します。 必要に応じて設定することができます、<xref:System.Diagnostics.EventInstance.CategoryId%2A>と<xref:System.Diagnostics.EventInstance.EntryType%2A>の`instance`イベント エントリのカテゴリとイベントの種類を定義する入力。 ローカライズされたメッセージ テキストに挿入する言語に依存しない文字列の配列を指定することもできます。 設定`values`に`null`イベント メッセージに置換文字列の書式設定プレース ホルダーが含まれていない場合。  
  
 使用する前に、イベント ログの指定したソースを登録する必要があります<xref:System.Diagnostics.EventLog.WriteEvent%2A>します。 指定したソースは、ローカライズされたエントリをログに書き込むように構成する必要があります。ソースには少なくとも必要メッセージ リソース ファイルの定義です。  
  
 作成し、ソースと最初のエントリを書き込む前に、イベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録済みのイベント ソースの一覧とその構成を更新するオペレーティング システムまでの時間です。 オペレーティング システムでは、イベントのソースの一覧は更新されていない場合は、書き込み操作は失敗、新しいソースを持つイベントを記述しようとしました。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド。 新しいイベント ソースを作成するコンピューターの管理者権限が必要です。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接の文字列を書き込むように構成する必要があります。 使用して、<xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドの場合は、アプリケーション イベント ログに直接文字列値を書き込みます。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルでは、1 つのソースを構成およびでは、そのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>メソッドをイベント ログのリソース識別子を使用してエントリを書き込みます。 リソースのファイルがない場合、別のソースを作成しでそのソースを使用し、<xref:System.Diagnostics.EventLog.WriteEntry%2A>そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
   
  
## Examples  
 次の例では、既存のイベント ログに情報イベントのエントリと警告イベント エントリを書き込みます。 リソース ファイル内のリソース識別子を使用してイベントのメッセージ テキストを指定します。 例では、対応するリソース ファイルがソースの登録されたと仮定します。  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 EventLogMsgs.dll リソース ライブラリに組み込まれている次のメッセージのテキスト ファイルを使用します。 メッセージのテキスト ファイルは、メッセージ リソース ファイルの作成元のソースです。 メッセージのテキスト ファイルでは、リソース識別子とカテゴリ、イベント メッセージ、およびパラメーターの挿入文字列のテキストを定義します。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 値が空の文字列 ("") です。  
  
\- または 
<paramref name="source" /> 値は <see langword="null" /> です。  
  
\- または 
 <paramref name="instance.InstanceId" /> が 0 未満の値か、<see cref="F:System.UInt16.MaxValue" /> より大きい値です。  
  
\- または 
 <paramref name="values" /> には 256 を超える要素が格納されています。  
  
\- または 
<paramref name="values" /> 要素の 1 つが 32766 バイトを超えています。  
  
\- または 
ソース名は、254 文字を超えるレジストリ キーのパスになります。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント エントリをイベント ログに書き込むときにオペレーティング システムからエラーが報告されました。 Windows のエラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を書き込む。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member WriteEvent : string * System.Diagnostics.EventInstance * byte[] * obj[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEvent (source, instance, data, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">指定したコンピューター上のアプリケーションに登録されるイベント ソースの名前。</param>
        <param name="instance">ローカライズされたイベント ログ エントリを表す <see cref="T:System.Diagnostics.EventInstance" /> インスタンス。</param>
        <param name="data">エントリに関連付けられているバイナリ データを保持するバイト配列。</param>
        <param name="values">イベント ログ エントリのメッセージ テキストにマージする文字列の配列。</param>
        <summary>指定した登録イベント ソースを使用して、指定したイベント データ、メッセージ置換文字列、および関連するバイナリ データと共にイベント ログ エントリを書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用すると、適切なログのイベント ソースとして既に登録されているソースを使用して、イベント ログに追加のイベントに固有のデータのローカライズされたエントリを記述できます。 文字列値ではなく、リソース識別子では、イベントのプロパティを指定します。 イベント ビューアーでは、リソース識別子を使用して、ソースのローカライズされたリソース ファイルから対応する文字列を表示します。 リソース識別子を使用してイベントを記述する前に、対応するリソース ファイルとソースを登録する必要があります。  
  
 入力`instance`インスタンスは、イベント メッセージとプロパティを指定します。 設定、<xref:System.Diagnostics.EventInstance.InstanceId%2A>の`instance`ソース メッセージ リソース ファイルで定義されたメッセージを入力します。 必要に応じて設定することができます、<xref:System.Diagnostics.EventInstance.CategoryId%2A>と<xref:System.Diagnostics.EventInstance.EntryType%2A>の`instance`イベント エントリのカテゴリとイベントの種類を定義する入力。 ローカライズされたメッセージ テキストに挿入する言語に依存しない文字列の配列を指定することもできます。 設定`values`に`null`イベント メッセージに置換文字列の書式設定プレース ホルダーが含まれていない場合。  
  
 イベントのイベントの追加の詳細を提供する必要がある場合に、バイナリ データを指定します。 たとえば、使用して、`data`パラメーターは、特定のエラーに関する情報を含めます。 イベント ビューアーでは、関連付けられたイベント データを解釈しません16 進数およびテキストを組み合わせた形式でデータを表示します。 イベントに固有のデータを多用します。役に立つことを確認する場合にのみ含めます。 イベント ビューアーとは無関係に、アプリケーションが処理できる情報を格納するのにイベントに固有のデータを使用することもできます。 たとえば、具体的には、イベントのビューアーを記述したり、イベント ログをスキャンし、イベントに固有のデータから情報を含むレポートを作成するプログラムを記述します。  
  
 使用する前に、イベント ログの指定したソースを登録する必要があります<xref:System.Diagnostics.EventLog.WriteEvent%2A>します。 指定したソースは、ローカライズされたエントリをログに書き込むように構成する必要があります。ソースには少なくとも必要メッセージ リソース ファイルの定義です。  
  
 作成し、ソースと最初のエントリを書き込む前に、イベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録済みのイベント ソースの一覧とその構成を更新するオペレーティング システムまでの時間です。 オペレーティング システムでは、イベントのソースの一覧は更新されていない場合は、書き込み操作は失敗、新しいソースを持つイベントを記述しようとしました。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド。 新しいイベント ソースを作成するコンピューターの管理者権限が必要です。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接の文字列を書き込むように構成する必要があります。 使用して、<xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドの場合は、アプリケーション イベント ログに直接文字列値を書き込みます。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルでは、1 つのソースを構成およびでは、そのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>メソッドをイベント ログのリソース識別子を使用してエントリを書き込みます。 リソースのファイルがない場合、別のソースを作成しでそのソースを使用し、<xref:System.Diagnostics.EventLog.WriteEntry%2A>そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
   
  
## Examples  
 次の例では、既存のイベント ログに情報イベントのエントリと警告イベント エントリを書き込みます。 リソース ファイル内のリソース識別子を使用してイベントのメッセージ テキストを指定します。 例では、対応するリソース ファイルがソースの登録されたと仮定します。  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 EventLogMsgs.dll リソース ライブラリに組み込まれている次のメッセージのテキスト ファイルを使用します。 メッセージのテキスト ファイルは、メッセージ リソース ファイルの作成元のソースです。 メッセージのテキスト ファイルでは、リソース識別子とカテゴリ、イベント メッセージ、およびパラメーターの挿入文字列のテキストを定義します。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 値が空の文字列 ("") です。  
  
\- または 
<paramref name="source" /> 値は <see langword="null" /> です。  
  
\- または 
 <paramref name="instance.InstanceId" /> が 0 未満の値か、<see cref="F:System.UInt16.MaxValue" /> より大きい値です。  
  
\- または 
 <paramref name="values" /> には 256 を超える要素が格納されています。  
  
\- または 
<paramref name="values" /> 要素の 1 つが 32766 バイトを超えています。  
  
\- または 
ソース名は、254 文字を超えるレジストリ キーのパスになります。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント エントリをイベント ログに書き込むときにオペレーティング システムからエラーが報告されました。 Windows のエラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を書き込む。 関連付けられた列挙体。 <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
  </Members>
</Type>