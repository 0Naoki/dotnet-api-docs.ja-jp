<Type Name="HttpContext" FullName="System.Web.HttpContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="89381694149c6783ea59e91d2ae890826502a5b5" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30610596" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpContext : IServiceProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpContext extends System.Object implements class System.IServiceProvider" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpContext" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpContext&#xA;Implements IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpContext sealed : IServiceProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>それぞれの HTTP 要求に関する HTTP 固有のすべての情報をカプセル化します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 継承するクラス、<xref:System.Web.IHttpModule>と<xref:System.Web.IHttpHandler>への参照を提供するインターフェイス、<xref:System.Web.HttpContext>の現在の HTTP 要求オブジェクト。 このオブジェクトが、組み込みへのアクセスを提供<xref:System.Web.HttpContext.Request%2A>、 <xref:System.Web.HttpContext.Response%2A>、および<xref:System.Web.HttpContext.Server%2A>要求のプロパティです。  
  
   
  
## Examples  
 Visual Studio の Web サイト プロジェクトとソース コードは、このトピックで使用可能な:[ダウンロード](http://go.microsoft.com/fwlink/?LinkId=192422)です。  
  
 次の例では、アクセスのプロパティを表示する方法、<xref:System.Web.HttpContext>オブジェクト。 使用して現在の HTTP 要求のコンテキストにアクセス、<xref:System.Web.UI.Page.Context%2A>のプロパティ、<xref:System.Web.UI.Page>オブジェクト。  
  
 [!code-aspx-csharp[System.Web.HttpContext#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext/cs/httpcontextcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpContext#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext/vb/httpcontextvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.IHttpModule" />
    <altmember cref="T:System.Web.IHttpHandler" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Web.HttpContext" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpWorkerRequest wr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpWorkerRequest wr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpWorkerRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (wr As HttpWorkerRequest)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpWorkerRequest ^ wr);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="wr" Type="System.Web.HttpWorkerRequest" />
      </Parameters>
      <Docs>
        <param name="wr">現在の HTTP 要求に対する <see cref="T:System.Web.HttpWorkerRequest" /> オブジェクト。</param>
        <summary>指定したワーカー要求オブジェクトを使用する <see cref="T:System.Web.HttpContext" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpRequest request, System.Web.HttpResponse response);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpRequest request, class System.Web.HttpResponse response) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpRequest,System.Web.HttpResponse)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (request As HttpRequest, response As HttpResponse)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpRequest ^ request, System::Web::HttpResponse ^ response);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="request" Type="System.Web.HttpRequest" />
        <Parameter Name="response" Type="System.Web.HttpResponse" />
      </Parameters>
      <Docs>
        <param name="request">現在の HTTP 要求に対する <see cref="T:System.Web.HttpRequest" /> オブジェクト。</param>
        <param name="response">現在の HTTP 要求に対する <see cref="T:System.Web.HttpResponse" /> オブジェクト。</param>
        <summary>指定した要求オブジェクトと応答オブジェクトを使用して、<see cref="T:System.Web.HttpContext" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcceptWebSocketRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 要求を受け入れます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="userFunc">ユーザー関数。</param>
        <summary>指定されたユーザー関数を使用して <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 要求を受け入れます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出すことと同じではこのメソッドを呼び出す、<xref:System.Web.HttpContext.AcceptWebSocketRequest%2A>メソッドのオーバー ロードを渡して`null`の`options`パラメーター。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="userFunc" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">この要求は <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 要求ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc, System.Web.WebSockets.AspNetWebSocketOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc, class System.Web.WebSockets.AspNetWebSocketOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task},System.Web.WebSockets.AspNetWebSocketOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task), options As AspNetWebSocketOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc, System::Web::WebSockets::AspNetWebSocketOptions ^ options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" />
        <Parameter Name="options" Type="System.Web.WebSockets.AspNetWebSocketOptions" />
      </Parameters>
      <Docs>
        <param name="userFunc">ユーザー関数。</param>
        <param name="options">オプションのオブジェクト。</param>
        <summary>指定されたユーザー関数とオプション オブジェクトを使用して <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 要求を受け入れます。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="userFunc" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">この要求は <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 要求ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="AddError">
      <MemberSignature Language="C#" Value="public void AddError (Exception errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddError(class System.Exception errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddError(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddError (errorInfo As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddError(Exception ^ errorInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorInfo" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="errorInfo">例外コレクションに追加する <see cref="T:System.Exception" />。</param>
        <summary>現在の HTTP 要求に対する例外コレクションに例外を追加します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnRequestCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnRequestCompleted (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnRequestCompleted(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddOnRequestCompleted(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnRequestCompleted (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnRequestCompleted(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" />
      </Parameters>
      <Docs>
        <param name="callback">HTTP コンテキスト オブジェクト。</param>
        <summary>要求の HTTP 部分が終了するときに発生する仮想イベントを発生させます。</summary>
        <returns>サブスクリプション トークン。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントが発生する前に、<xref:System.Web.WebSockets.AspNetWebSocket>接続を開始します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callback" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="AllErrors">
      <MemberSignature Language="C#" Value="public Exception[] AllErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception[] AllErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllErrors As Exception()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Exception ^&gt; ^ AllErrors { cli::array &lt;Exception ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP 要求の処理中に蓄積されたエラーの配列を取得します。</summary>
        <value>現在の HTTP 要求に対する <see cref="T:System.Exception" /> オブジェクトの配列。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAsyncDuringSyncStages">
      <MemberSignature Language="C#" Value="public bool AllowAsyncDuringSyncStages { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAsyncDuringSyncStages" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllowAsyncDuringSyncStages" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowAsyncDuringSyncStages As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowAsyncDuringSyncStages { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ASP.NET 要求の一部の処理中に、それが予期されていない場合、非同期操作が許可されるかどうかを示す値を取得または設定します。</summary>
        <value>
          予期しない時期に非同期 API が使用されると ASP.NET が例外をスローする場合は <see langword="false" />、それ以外の場合は <see langword="true" />。 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このフラグは設定されていない場合`true`ASP.NET、非同期 API を悪用して、アプリケーションを検出した場合に例外がスローされます。 これは、要求処理パイプラインでの非同期操作は必要ありませんの一部の中に、非同期メソッドを呼び出すしようとする場合、または非同期のモジュールとハンドラー完了を通知するときにまだ保留中の非同期操作がある場合に発生することができます。 この動作は安全策としてために収まらない非同期コード パターンを想定し、悪影響が出る場合がありますを記述しているかどうかを早い段階で確認できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplicationState Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplicationState Application" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Application" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Application As HttpApplicationState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplicationState ^ Application { System::Web::HttpApplicationState ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求に対する <see cref="T:System.Web.HttpApplicationState" /> オブジェクトを取得します。</summary>
        <value>現在の HTTP 要求に対する <see cref="T:System.Web.HttpApplicationState" />。  
  
 現在の HTTP 要求に対する <see cref="T:System.Web.HttpApplication" /> オブジェクトを取得するには、<see cref="P:System.Web.HttpContext.ApplicationInstance" /> を使用します。 (ASP.NET と従来の ASP との混同を避けるために、ASP.NET は <see langword="Application" /> の代わりに <see langword="ApplicationInstance" /> をプロパティ名として使用して、現在の <see cref="T:System.Web.HttpApplication" /> インスタンスを参照します。 従来の ASP では、<see langword="Application" /> はグローバル アプリケーション状態のディクショナリを参照します)。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.ApplicationInstance" />
      </Docs>
    </Member>
    <Member MemberName="ApplicationInstance">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplication ApplicationInstance { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplication ApplicationInstance" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ApplicationInstance" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationInstance As HttpApplication" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplication ^ ApplicationInstance { System::Web::HttpApplication ^ get(); void set(System::Web::HttpApplication ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplication</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求に対する <see cref="T:System.Web.HttpApplication" /> オブジェクトを取得または設定します。</summary>
        <value>現在の HTTP 要求に対する <see cref="T:System.Web.HttpApplication" />。  
  
 ASP.NET と従来の ASP との混同を避けるために、ASP.NET は <see langword="Application" /> の代わりに <see langword="ApplicationInstance" /> をプロパティ名として使用して、現在の <see cref="T:System.Web.HttpApplication" /> インスタンスを参照します。 従来の ASP では、<see langword="Application" /> はグローバル アプリケーション状態のディクショナリを参照します。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Web アプリケーションを IIS 7.0 の統合モードで実行しており、プロパティの値を、null 以外の値から　<see langword="null" /> に変更しようとしました。</exception>
        <altmember cref="P:System.Web.HttpContext.Application" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPreloadMode">
      <MemberSignature Language="C#" Value="public System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AsyncPreloadMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPreloadMode As AsyncPreloadModeFlags" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Configuration::AsyncPreloadModeFlags AsyncPreloadMode { System::Web::Configuration::AsyncPreloadModeFlags get(); void set(System::Web::Configuration::AsyncPreloadModeFlags value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Configuration.AsyncPreloadModeFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>非同期プリロード モードに関係するフラグを含むオブジェクトを取得または設定します。</summary>
        <value>非同期プリロード モードに関係するフラグを含むオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティにアクセスすると、最初に、オブジェクトを非同期プリロード モードのフラグを含むが読み込まれてから、<xref:System.Web.Configuration.HttpRuntimeSection.AsyncPreloadMode%2A>構成ファイルで設定します。  
  
 このプロパティはプログラムで設定できますが、プロパティ値の変更が有効なのは、ASP.NET の要求パイプラインの `ExecuteRequestHandler` の手順の前にプロパティが設定されている場合のみです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.Caching.Cache Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Caching.Cache Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As Cache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Caching::Cache ^ Cache { System::Web::Caching::Cache ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Caching.Cache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のアプリケーション ドメインに対する <see cref="T:System.Web.Caching.Cache" /> オブジェクトを取得します。</summary>
        <value>現在のアプリケーション ドメインに対する <see cref="T:System.Web.Caching.Cache" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インスタンスは 1 つ、<xref:System.Web.Caching.Cache>アプリケーション ドメインごとのクラスです。 その結果、<xref:System.Web.Caching.Cache>によって返されるオブジェクト、<xref:System.Web.HttpContext.Cache%2A>プロパティは、<xref:System.Web.Caching.Cache>アプリケーション ドメイン内のすべての要求オブジェクト。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.ClearError" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearError ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearError();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の HTTP 要求に対するすべてのエラーをクリアします。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.Error" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Web.HttpContext Current { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.HttpContext Current" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Current As HttpContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::HttpContext ^ Current { System::Web::HttpContext ^ get(); void set(System::Web::HttpContext ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求に対する <see cref="T:System.Web.HttpContext" /> オブジェクトを取得または設定します。</summary>
        <value>現在の HTTP リクエストに対する <see cref="T:System.Web.HttpContext" /> インスタンス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティはの静的プロパティ、<xref:System.Web.HttpContext>クラスです。 プロパティ ストア、<xref:System.Web.HttpContext>インスタンスを現在の要求に適用されます。 このインスタンスのプロパティは、の非静的プロパティ、<xref:System.Web.HttpContext>クラスです。  
  
 使用することも、<xref:System.Web.UI.Page.Context%2A?displayProperty=nameWithType>プロパティへのアクセスを<xref:System.Web.HttpContext>の現在の HTTP 要求オブジェクト。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Web.HttpContext.Current%2A>プロパティへのアクセスを<xref:System.Web.HttpContext.AddError%2A?displayProperty=nameWithType>と<xref:System.Web.HttpContext.ClearError%2A?displayProperty=nameWithType>メソッドおよび<xref:System.Web.HttpContext.AllErrors%2A?displayProperty=nameWithType>プロパティです。 使用して 3 つのカスタム例外を作成、<xref:System.Web.HttpContext.AddError%2A>メソッドを使用して、<xref:System.Web.HttpContext.AllErrors%2A>プロパティ配列へのこれらの例外を読み込めません。 次に、配列を含むページに書き込み、使用して、<xref:System.Web.HttpContext.ClearError%2A>からすべてのエラーをクリアする方法、<xref:System.Web.UI.Page.Context%2A>プロパティです。  
  
```csharp  
protected void Page_Load(object sender, EventArgs e)  
{  
    HttpContext context = HttpContext.Current;  
    Response.Write("<p>HttpContext.Current Example:</p>");  
  
    // Add three custom exceptions.  
    context.AddError(new Exception("New Exception #1"));  
    context.AddError(new Exception("New Exception #2"));  
    context.AddError(new Exception("New Exception #3"));  
  
    // Capture all the new Exceptions in an array.  
    Exception[] errs = context.AllErrors;  
  
    foreach (Exception ex in errs)  
    {  
        Response.Write("<p>" + Server.HtmlEncode(ex.ToString()) + "</p>");  
    }  
  
    // Clear the exceptions so ASP.NET won't handle them.  
    context.ClearError();  
}  
```  
  
```vb  
Protected Sub Page_Load(sender As Object, e As EventArgs)  
Dim context As HttpContext = HttpContext.Current  
Response.Write("<p>HttpContext.Current Example:</p>")  
  
' Add three custom exceptions.  
context.AddError(New Exception("New Exception #1"))  
context.AddError(New Exception("New Exception #2"))  
context.AddError(New Exception("New Exception #3"))  
  
' Capture all the new Exceptions in an array.  
Dim errs As Exception() = context.AllErrors  
  
For Each ex As Exception In errs  
Response.Write("<p>" & Server.HtmlEncode(ex.ToString()) & "</p>")  
Next  
  
' Clear the exceptions so ASP.NET won't handle them.  
context.ClearError()  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Response" />
        <altmember cref="P:System.Web.HttpContext.Request" />
      </Docs>
    </Member>
    <Member MemberName="CurrentHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler CurrentHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler CurrentHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ CurrentHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在実行中のハンドラーを表す <see cref="T:System.Web.IHttpHandler" /> オブジェクトを取得します。</summary>
        <value>現在実行中のハンドラーを表す <see cref="T:System.Web.IHttpHandler" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 によって参照されている現在実行中のハンドラー、<xref:System.Web.HttpContext.CurrentHandler%2A>プロパティによって参照されているハンドラーとは異なる場合があります、<xref:System.Web.HttpContext.Handler%2A>プロパティです。 これを使用して別のハンドラーが要求されたときに発生することができます、<xref:System.Web.HttpServerUtility.Execute%2A>メソッドまたは<xref:System.Web.HttpServerUtility.Transfer%2A>メソッドです。 現在実行中のハンドラーには、処理が完了すると、事前に決定されたハンドラーが復元されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
      </Docs>
    </Member>
    <Member MemberName="CurrentNotification">
      <MemberSignature Language="C#" Value="public System.Web.RequestNotification CurrentNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.RequestNotification CurrentNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentNotification As RequestNotification" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::RequestNotification CurrentNotification { System::Web::RequestNotification get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.RequestNotification</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>処理中の現在の <see cref="T:System.Web.HttpApplication" /> イベントを示す <see cref="T:System.Web.RequestNotification" /> 値を取得します。</summary>
        <value>
          <see cref="T:System.Web.RequestNotification" /> 値のいずれか 1 つ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.CurrentNotification%2A>プロパティには、統合パイプライン モードが必要です。[!INCLUDE[iisver](~/includes/iisver-md.md)]と、少なくとも .NET Framework バージョン 3.0。 プロパティが返す利用可能であれば、<xref:System.Web.RequestNotification>値。 値、<xref:System.Web.HttpContext.CurrentNotification%2A>プロパティでイベントを示す、<xref:System.Web.HttpApplication>インスタンスが現在の要求を処理します。  
  
 <xref:System.Web.HttpContext.CurrentNotification%2A>プロパティを設定する必要はありません。 設定されます。 代わりに、 [!INCLUDE[iisver](~/includes/iisver-md.md)] ASP.NET パイプライン内の要求の処理中にします。 設定、<xref:System.Web.HttpContext.CurrentNotification%2A>プロパティは、コンパイル エラーになります。  
  
 <xref:System.Web.HttpContext.CurrentNotification%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework のバージョンおよび依存関係](~/docs/framework/migration-guide/versions-and-dependencies.md)」を参照してください。  
  
   
  
## Examples  
 次の例で使用する方法、<xref:System.Web.HttpContext.CurrentNotification%2A>プロパティをどのようなイベントの<xref:System.Web.HttpApplication>現在の要求を処理しているオブジェクトが処理されています。 例では、イベント ハンドラーの複数のイベント、<xref:System.Web.HttpApplication>オブジェクト、および<xref:System.Web.HttpContext.CurrentNotification%2A>プロパティは、どのようなコードが処理される各イベントに対して呼び出されるを決定します。  
  
 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">この操作を実行するには、[!INCLUDE[iisver](~/includes/iisver-md.md)] の統合パイプライン モードおよび .NET Framework Version 3.0 以降が必要です。</exception>
        <altmember cref="P:System.Web.HttpContext.IsPostNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="DisposeOnPipelineCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken DisposeOnPipelineCompleted (IDisposable target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken DisposeOnPipelineCompleted(class System.IDisposable target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.DisposeOnPipelineCompleted(System.IDisposable)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisposeOnPipelineCompleted (target As IDisposable) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ DisposeOnPipelineCompleted(IDisposable ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.IDisposable" />
      </Parameters>
      <Docs>
        <param name="target">要求の <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 接続部分が完了したときに、<see cref="M:System.IDisposable.Dispose" /> メソッドを呼び出す必要のあるオブジェクト。</param>
        <summary>この要求の <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 接続部分が完了したときに、オブジェクトの <see cref="M:System.IDisposable.Dispose" /> メソッドを呼び出すことができるようにします。</summary>
        <returns>サブスクリプション トークン。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IDisposable.Dispose%2A>要求の HTTP 部分の後に、ターゲット オブジェクトのメソッドが呼び出されて、<xref:System.Web.WebSockets.AspNetWebSocket>の接続が終了しました。 <xref:System.Web.HttpContext>オブジェクトは検査に使用できません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public Exception Error { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception Error" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Error" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Error As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ Error { Exception ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP 要求の処理中にエラーが蓄積された場合は、その最初のエラーを取得します。</summary>
        <value>現在の HTTP 要求または HTTP 応答の処理に対する最初の <see cref="T:System.Exception" />。HTTP 要求処理中にエラーが 1 つも蓄積されなかった場合は、<see langword="null" />。 既定値は、<see langword="null" /> です。</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.HttpContext.ClearError" />
      </Docs>
    </Member>
    <Member MemberName="GetAppConfig">
      <MemberSignature Language="C#" Value="public static object GetAppConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetAppConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetAppConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAppConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetAppConfig(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">情報が要求されたアプリケーションの構成タグ。</param>
        <summary>現在のアプリケーションに対して要求された構成情報を返します。</summary>
        <returns>構成情報を格納するオブジェクト。 (返された構成セクションは、適切な構成型にキャストしてから使用してください。)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.GetAppConfig%2A> メソッドの使用は推奨されていません。 使用して、<xref:System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection%2A>のメソッド、<xref:System.Web.Configuration.WebConfigurationManager>クラスを現在のアプリケーションの構成情報を取得します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Configuration.WebConfigurationManager" />
      </Docs>
    </Member>
    <Member MemberName="GetConfig">
      <MemberSignature Language="C#" Value="public object GetConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetConfig(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.HttpContext.GetSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">情報が要求された構成タグ。</param>
        <summary>現在の HTTP 要求に対して要求された構成情報を返します。</summary>
        <returns>指定した <see cref="T:System.Configuration.ConfigurationSection" />。このセクションが存在しない場合は <see langword="null" />。このセクションに実行時にアクセスできない場合は内部オブジェクト。 (返されたオブジェクトは、適切な構成型にキャストしてから使用してください。)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.GetConfig%2A> メソッドの使用は推奨されていません。 使用して、<xref:System.Web.HttpContext.GetSection%2A>現在の HTTP 要求の構成情報を取得します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpContext.GetSection(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGlobalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>アプリケーション レベル リソースを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="classKey">要求されたリソース オブジェクトの <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> プロパティを表す文字列。</param>
        <param name="resourceKey">要求されたリソース オブジェクトの <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティを表す文字列。</param>
        <summary>アプリケーション レベル リソース オブジェクトを、指定した <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> プロパティおよび <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティに基づいて取得します。</summary>
        <returns>要求されたアプリケーション レベル リソース オブジェクトを表す <see cref="T:System.Object" />。リソース オブジェクトが見つからない場合、またはリソース オブジェクトが見つかってもそれが要求されたプロパティを持っていない場合は null。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.GetGlobalResourceObject%2A>メソッドで指定されているカルチャを使用してグローバル リソースが返されます、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A>プロパティです。  
  
> [!NOTE]
>  編集環境などいくつかの[!INCLUDE[vwprvw](~/includes/vwprvw-md.md)]、エディターがデザイン時をスロー<xref:System.Resources.MissingManifestResourceException>グローバル リソース キー名にピリオド (.) を使用する場合に例外です。 ただし、これには影響しません、機能を編集またはファイルを保存して、エラーを無視することができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">指定した <paramref name="classKey" /> パラメーターのリソース オブジェクトが見つかりませんでした。  
  
 \- または  
  
 メイン アセンブリにニュートラル カルチャのリソースが含まれていません。適切なサテライト アセンブリが見つからないためこれらのリソースが必要です。</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </Member>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="classKey">要求されたリソース オブジェクトの <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> プロパティを表す文字列。</param>
        <param name="resourceKey">要求されたリソース オブジェクトの <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティを表す文字列。</param>
        <param name="culture">要求されたリソースの <see cref="T:System.Globalization.CultureInfo" /> オブジェクトを表す文字列。</param>
        <summary>アプリケーション レベル リソース オブジェクトを、指定した <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> プロパティおよび <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティ、および <see cref="T:System.Globalization.CultureInfo" /> オブジェクトに基づいて取得します。</summary>
        <returns>要求されたアプリケーション レベル リソース オブジェクトを表す <see cref="T:System.Object" />。これは、特定のカルチャにローカライズされます。リソース オブジェクトが見つからない場合、またはリソース オブジェクトが見つかってもそれが要求されたプロパティを持っていない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Globalization.CultureInfo>オブジェクトは、リソースのローカライズ対象のカルチャを表します。 リソースは、このカルチャにローカライズされていない、参照は、適切なリソースを検索するフォールバック プロセスを行います。 詳細については、「[リソースのパッケージ化と配置](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)」を参照してください。  
  
> [!NOTE]
>  エディターは Visual Web Developer など、一部の編集環境でデザイン時をスローする可能性があります<xref:System.Resources.MissingManifestResourceException>グローバル リソース キー名にピリオド (.) を使用する場合に例外です。 ただし、これには影響しません、機能を編集またはファイルを保存して、エラーを無視することができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">指定した <paramref name="classKey" /> パラメーターが見つからなかったリソース オブジェクト。  
  
 \- または  
  
 メイン アセンブリにニュートラル カルチャのリソースが含まれていません。適切なサテライト アセンブリが見つからないためこれらのリソースが必要です。</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLocalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ページ レベル リソースを取得します。</summary>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">ローカル リソース オブジェクトのための <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> プロパティ。</param>
        <param name="resourceKey">要求されたリソース オブジェクトの <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティを表す文字列。</param>
        <summary>ページ レベル リソース オブジェクトを、指定した <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> プロパティおよび <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティに基づいて取得します。</summary>
        <returns>要求されたページ レベル リソース オブジェクトを表す <see cref="T:System.Object" />。一致するリソース オブジェクトが見つかっても <paramref name="resourceKey" /> パラメーターではない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.GetLocalResourceObject%2A>メソッドで指定されているカルチャを使用して、ローカル リソースが返されます、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A>プロパティです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">指定した <paramref name="virtualPath" /> パラメーターのリソース オブジェクトが見つかりませんでした。</exception>
        <exception cref="T:System.ArgumentException">指定した <paramref name="virtualPath" /> パラメーターが、現在のアプリケーションのルート ディレクトリ内にありません。</exception>
        <exception cref="T:System.InvalidOperationException">目的のページのリソース クラスが見つかりませんでした。</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </Member>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="virtualPath">ローカル リソース オブジェクトのための <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> プロパティ。</param>
        <param name="resourceKey">要求されたリソース オブジェクトの <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティを表す文字列。</param>
        <param name="culture">要求されたリソース オブジェクトの <see cref="T:System.Globalization.CultureInfo" /> オブジェクトを表す文字列。</param>
        <summary>ページ レベル リソース オブジェクトを、指定した <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> プロパティおよび <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティ、および <see cref="T:System.Globalization.CultureInfo" /> オブジェクトに基づいて取得します。</summary>
        <returns>要求されたローカル リソース オブジェクトを表す <see cref="T:System.Object" />。これは、特定のカルチャにローカライズされます。一致するリソース オブジェクトが見つかっても <paramref name="resourceKey" /> パラメーターではない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 リソースは、このカルチャにローカライズされていない、参照は、適切なリソースを検索するフォールバック プロセスを行います。 詳細については、「[リソースのパッケージ化と配置](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">指定した <paramref name="virtualPath" /> パラメーターのリソース オブジェクトが見つかりませんでした。</exception>
        <exception cref="T:System.ArgumentException">指定した <paramref name="virtualPath" /> パラメーターが、現在のアプリケーションのルート ディレクトリ内にありません。</exception>
        <exception cref="T:System.InvalidOperationException">目的のページのリソース クラスが見つかりませんでした。</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </Member>
    <Member MemberName="GetSection">
      <MemberSignature Language="C#" Value="public object GetSection (string sectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSection(string sectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetSection(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSection (sectionName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSection(System::String ^ sectionName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sectionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sectionName">構成セクション パス (XPath 形式) および構成要素名。</param>
        <summary>現在のアプリケーションの既定構成の、指定した構成セクションを取得します。</summary>
        <returns>指定した <see cref="T:System.Configuration.ConfigurationSection" />。このセクションが存在しない場合は <see langword="null" />。このセクションに実行時にアクセスできない場合は内部オブジェクト。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Configuration.ConfigurationManager.GetSection(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Handler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler Handler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler Handler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Handler" />
      <MemberSignature Language="VB.NET" Value="Public Property Handler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ Handler { System::Web::IHttpHandler ^ get(); void set(System::Web::IHttpHandler ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP 要求の処理を実行する <see cref="T:System.Web.IHttpHandler" /> オブジェクトを取得または設定します。</summary>
        <value>HTTP 要求の処理を実行する <see cref="T:System.Web.IHttpHandler" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.Handler%2A>プロパティには、HTTP 要求を処理するハンドラーへの参照が含まれています。 ハンドラーは、要素を使用して、またはユーザー コードで定義されているカスタム ハンドラーを使用して指定できます。 ハンドラーの詳細については、次を参照してください。 [HTTP ハンドラーと HTTP モジュールの概要](http://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b)です。  
  
 参照、<xref:System.Web.HttpContext.Handler%2A>プロパティは同じサーバー側のメソッドによって、現在のページがなどに変更した後も、<xref:System.Web.HttpServerUtility.Execute%2A>メソッドまたは<xref:System.Web.HttpServerUtility.Transfer%2A>メソッドです。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
      </Docs>
    </Member>
    <Member MemberName="IsCustomErrorEnabled">
      <MemberSignature Language="C#" Value="public bool IsCustomErrorEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomErrorEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsCustomErrorEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCustomErrorEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCustomErrorEnabled { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求に対してカスタム エラーが有効かどうかを示す値を取得します。</summary>
        <value>
          カスタム エラーが有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDebuggingEnabled">
      <MemberSignature Language="C#" Value="public bool IsDebuggingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDebuggingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsDebuggingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDebuggingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDebuggingEnabled { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求がデバッグ モードかどうかを示す値を取得します。</summary>
        <value>
          要求がデバッグ モードである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPostNotification">
      <MemberSignature Language="C#" Value="public bool IsPostNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsPostNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPostNotification As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPostNotification { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.HttpApplication" /> イベントが処理を終了した直後の ASP.NET パイプライン内の現在の処理ポイントである値を取得します。</summary>
        <value>
          カスタム エラーが有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.IsPostNotification%2A>プロパティは、統合モードでのみサポート[!INCLUDE[iisver](~/includes/iisver-md.md)]と、少なくとも .NET Framework 3.0。 プロパティを示すブール値を返す、使用可能な場合のイベントかどうか、<xref:System.Web.HttpApplication>オブジェクトの処理が完了します。  
  
 <xref:System.Web.HttpContext.IsPostNotification%2A>プロパティを設定する必要はありません。 によって提供される代わりに、[!INCLUDE[iisver](~/includes/iisver-md.md)]通知ごとに、ASP.NET ランタイムにします。 設定、<xref:System.Web.HttpContext.IsPostNotification%2A>プロパティは、コンパイル エラーになります。  
  
 シナリオでここでの複数のイベント、<xref:System.Web.HttpApplication>オブジェクトは、1 つのイベント ハンドラーによって処理される、使用することができます、<xref:System.Web.HttpContext.IsPostNotification%2A>プロパティと組み合わせて、<xref:System.Web.RequestNotification>列挙体をアプリケーション ライフ サイクルにおける現在の要求が正確に判断します。  
  
 <xref:System.Web.HttpContext.IsPostNotification%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework のバージョンおよび依存関係](~/docs/framework/migration-guide/versions-and-dependencies.md)」を参照してください。  
  
   
  
## Examples  
 次の例で使用する方法、<xref:System.Web.HttpContext.IsPostNotification%2A>時点のイベントを決定するプロパティ、<xref:System.Web.HttpApplication>オブジェクトのすべての関連するイベント ハンドラーの処理が完了します。 この例では、カスタム イベント ハンドラーの複数のイベントを処理する、<xref:System.Web.HttpApplication>オブジェクト、および<xref:System.Web.HttpContext.IsPostNotification%2A>プロパティを使用して、どのようなコードを呼び出すを決定特定のイベントが処理された後です。  
  
 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">この操作を実行するには、[!INCLUDE[iisver](~/includes/iisver-md.md)] の統合パイプライン モードおよび .NET Framework 3.0 以降が必要です。</exception>
        <altmember cref="P:System.Web.HttpContext.CurrentNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequest">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequest { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequest" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequest" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequest As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequest { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求が <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 要求かどうかを示す値を取得します。</summary>
        <value>
          要求が <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 要求である場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが戻る`true`初期が要求に含まれている場合<xref:System.Web.WebSockets.AspNetWebSocket>ハンドシェイクと`WebSocket`IIS のモジュールがアクティブです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequestUpgrading">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequestUpgrading { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequestUpgrading" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequestUpgrading" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequestUpgrading As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequestUpgrading { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>接続が HTTP 接続から <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 接続にアップグレードされるかどうかを示す値を取得します。</summary>
        <value>
          接続がアップグレード中の場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Items" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Items { System::Collections::IDictionary ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP 要求時に <see cref="T:System.Web.IHttpModule" /> インターフェイスと <see cref="T:System.Web.IHttpHandler" /> インターフェイスとの間でデータを編成および共有するために使用できるキー/値のコレクションを取得します。</summary>
        <value>キーの指定によるコレクションの個々の値へのアクセスを実現する <see cref="T:System.Collections.IDictionary" /> キー/値のコレクション。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PageInstrumentation">
      <MemberSignature Language="C#" Value="public System.Web.Instrumentation.PageInstrumentationService PageInstrumentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Instrumentation.PageInstrumentationService PageInstrumentation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PageInstrumentation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PageInstrumentation As PageInstrumentationService" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Instrumentation::PageInstrumentationService ^ PageInstrumentation { System::Web::Instrumentation::PageInstrumentationService ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Instrumentation.PageInstrumentationService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要求のページ インストルメンテーション サービス インスタンスへの参照を取得します。</summary>
        <value>この要求のページ インストルメンテーション サービス インスタンス。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviousHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler PreviousHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler PreviousHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PreviousHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreviousHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ PreviousHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>親ハンドラーの <see cref="T:System.Web.IHttpHandler" /> オブジェクトを取得します。</summary>
        <value>
          <see cref="T:System.Web.IHttpHandler" /> インスタンス。以前のハンドラーが見つからなかった場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.PreviousHandler%2A>プロパティは、対応する最後のハンドラー、現在の要求が実行される前にします。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
      </Docs>
    </Member>
    <Member MemberName="Profile">
      <MemberSignature Language="C#" Value="public System.Web.Profile.ProfileBase Profile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Profile.ProfileBase Profile" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Profile" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Profile As ProfileBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Profile::ProfileBase ^ Profile { System::Web::Profile::ProfileBase ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Profile.ProfileBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のユーザー プロファイルの <see cref="T:System.Web.Profile.ProfileBase" /> オブジェクトを取得します。</summary>
        <value>アプリケーションの構成ファイルにプロファイルのプロパティが定義されている場合は <see cref="T:System.Web.Profile.ProfileBase" />。それ以外の場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Web.HttpContext.Profile%2A>プロパティがタイプ セーフな API を使用して構造化データの永続的な記憶域に使用します。 ときに、<xref:System.Web.HttpContext.Profile%2A>プロパティへのアクセスが、値が存在しない、空のインスタンスが返されます。`null`は返されません。  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Web.Profile" />
      </Docs>
    </Member>
    <Member MemberName="RemapHandler">
      <MemberSignature Language="C#" Value="public void RemapHandler (System.Web.IHttpHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemapHandler(class System.Web.IHttpHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemapHandler (handler As IHttpHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemapHandler(System::Web::IHttpHandler ^ handler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" />
      </Parameters>
      <Docs>
        <param name="handler">要求を処理するオブジェクト。</param>
        <summary>要求のハンドラーを指定できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定した場合`handler`に`null`既定のハンドラーが要求を処理するために使用します。 設定することができます`handler`非同期ハンドラーまたは同期ハンドラー。 ハンドラーを実装する必要があります、<xref:System.Web.IHttpHandler>インターフェイスです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" /> メソッドが、<see cref="E:System.Web.HttpApplication.MapRequestHandler" /> イベントの発生後に呼び出されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.Web.HttpRequest Request { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpRequest Request" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Request" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Request As HttpRequest" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpRequest ^ Request { System::Web::HttpRequest ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpRequest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求に対する <see cref="T:System.Web.HttpRequest" /> オブジェクトを取得します。</summary>
        <value>現在の HTTP 要求に対する <see cref="T:System.Web.HttpRequest" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.Request%2A>プロパティは、のプロパティおよびメソッドにプログラムでアクセスを提供、<xref:System.Web.HttpRequest>クラスです。 ASP.NET ページへの参照を既定値が含まれているため、<xref:System.Web>名前空間 (が含まれている、<xref:System.Web.HttpContext>クラス) のメンバーを参照できます<xref:System.Web.HttpRequest>.aspx ページへの参照を完全修飾クラスを使用せずに<xref:System.Web.HttpContext>です。 たとえば、使用することができます`Request.Browser`クライアントのブラウザーの機能を取得します。 ただしのメンバーを使用する場合は、 <xref:System.Web.HttpRequest> ASP.NET 分離コード モジュールからへの参照を含める必要があります、<xref:System.Web>モジュールで現在アクティブな要求/応答のコンテキストと内のクラス名の両方への参照を完全修飾名前空間<xref:System.Web>を使用します。 たとえば、分離コード ページである必要がありますを指定する完全修飾名`HttpContext.Current.Request.Browser`です。  
  
> [!NOTE]
>  このプロパティを使用しようとする場合に ASP.NET が例外をスロー時に、<xref:System.Web.HttpRequest>オブジェクトは使用できません。 たとえば、Global.asax ファイルでは、Application_Start メソッドまたは Application_Start メソッドから呼び出されるメソッドの場合は true になります。 その時点での HTTP 要求がまだ作成されていません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Web アプリケーションは IIS 7 の統合モードで実行されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Response">
      <MemberSignature Language="C#" Value="public System.Web.HttpResponse Response { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpResponse Response" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Response" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Response As HttpResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpResponse ^ Response { System::Web::HttpResponse ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpResponse</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 応答に対する <see cref="T:System.Web.HttpResponse" /> オブジェクトを取得します。</summary>
        <value>現在の HTTP 応答の <see cref="T:System.Web.HttpResponse" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.Response%2A>プロパティは、のプロパティおよびメソッドにプログラムでアクセスを提供、<xref:System.Web.HttpResponse>クラスです。 ASP.NET ページへの参照を既定値が含まれているため、<xref:System.Web>名前空間 (が含まれている、<xref:System.Web.HttpContext>クラス) のメンバーを参照できます<xref:System.Web.HttpContext>.aspx ページへの参照を完全修飾クラスを使用せずに<xref:System.Web.HttpContext>です。 たとえば、使用することができます`Response.Write("some output")`HTTP 出力ストリームに出力を書き込む。 ただしのメンバーを使用する場合は、 <xref:System.Web.HttpResponse> ASP.NET 分離コード モジュールからへの参照を含める必要があります、<xref:System.Web>モジュールで現在アクティブな要求/応答のコンテキストと内のクラスへの参照を完全修飾名前空間<xref:System.Web>を使用します。 たとえば、分離コード ページである必要がありますを指定する完全修飾名`HttpContext.Current.Response.Write("some output")`です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Web アプリケーションは IIS 7 の統合モードで実行されています。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RewritePath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>リソースの要求を、要求された URL で示されているものとは別のパスにリダイレクトします。 <see cref="Overload:System.Web.HttpContext.RewritePath" /> は、Cookie を使用しないセッション状態において、URL からセッション ID を取り除くために使用されます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">内部リライト パス。</param>
        <summary>指定されたパスを使用して URL をリライトします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.RewritePath%28System.String%29>メソッドが要求された URL で示されているものとは異なるパスに、リソースの要求をリダイレクトします。 パスをリセットする、仮想サーバー リソースのクライアントからの要求が正しく解決されるようにした場合は、このメソッドのオーバー ロードを使用して、`rebaseClientPath`パラメーター、パラメーターを設定および`false`です。  
  
 Web アプリケーションでページを再構築して、古い Url をブックマークしている人ように使用できますのページに移動した後かどうかを確認する場合は、URL の書き換えと便利です。 URL 書き換えには、透過的に新しいページの場所への要求を転送することができます。  
  
 検索エンジンがわかりやすいとは、最適化されている Url を使用するサイトを有効にする場合より堅牢な代替手段は、ASP.NET のルーティングを使用するです。 詳細については、次を参照してください。 [ASP.NET ルーティング](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a)です。  
  
   
  
## Examples  
 次の例を使用する方法を示しています、<xref:System.Web.HttpContext.RewritePath%2A>メソッドを Web サイトのファイル構造を反映しない Url に応答する Web サイトを有効にします。 コードの最初のブロックは、RewritePath.aspx という ASP.NET Web ページです。 クエリ文字列が必要です。 かどうか、サイトの名前は、URL により、WebSite1`http://localhost/WebSite1/RewritePath.aspx?page=1`ブラウザーに「ページ 1」を表示します。 Web ページを次のコード ブロックは、 `Application_BeginRequest` Global.asax ファイル内のイベント ハンドラー。 このコードをインターセプト要求の Url など`http://localhost/WebSite1/page1`され、処理される前に RewritePath.aspx に必要な形式に変換します。 そのため、URL`http://localhost/WebSite1/page1`ブラウザーに「ページ 1」を表示するクエリ文字列パラメーターを持つ RewritePath.aspx を呼び出します。 場合など、URL`http://localhost/WebSite1/page1`受信されるのオーバー ロード<xref:System.Web.HttpContext.RewritePath%2A>が呼び出される値を指定することができます、<xref:System.Web.HttpRequest.PathInfo%2A>プロパティだけでなく、クエリ文字列パラメーター。  
  
 [!code-aspx-csharp[HttpContext_RewritePath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/rewritepath.aspx#2)]
 [!code-aspx-vb[HttpContext_RewritePath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/rewritepath.aspx#2)]  
  
 [!code-csharp[HttpContext_RewritePath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/global.asax#1)]
 [!code-vb[HttpContext_RewritePath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/global.asax#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Web.HttpException">
          <paramref name="path" /> パラメーターが、現在のアプリケーションのルート ディレクトリ内にありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path, bool rebaseClientPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path, bool rebaseClientPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String, rebaseClientPath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path, bool rebaseClientPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="rebaseClientPath" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">内部リライト パス。</param>
        <param name="rebaseClientPath">
          仮想パスをリセットする場合は <see langword="true" />。仮想パスを変更しない場合は <see langword="false" />。</param>
        <summary>指定したパスおよびサーバー リソースの仮想パスが変更されるかどうかを指定するブール値を使用して、URL をリライトします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.RewritePath%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType>メソッドによって呼び出されます、<xref:System.Web.HttpContext.RewritePath%28System.String%29?displayProperty=nameWithType>メソッドを`rebaseClientPath`パラメーターに設定`true`です。 リソースへのパスを構築するために使用される仮想パスが変更されていないようにするには、設定、`rebaseClientPath`パラメーターを`false`です。 設定する一般的なシナリオ`rebaseClientPath`に`false`は、URL の書き換えする必要があるあり、テーマを使用して、要求されたリソースとは異なるフォルダーにあるリソースへの URL をリダイレクトするときにします。  
  
 Web アプリケーションでページを再構築して、古い Url をブックマークしている人ように使用できますのページに移動した後かどうかを確認する場合は、URL の書き換えと便利です。 URL 書き換えには、透過的に新しいページの場所への要求を転送することができます。  
  
 検索エンジンがわかりやすいとは、最適化されている Url を使用するサイトを有効にする場合より堅牢な代替手段は、ASP.NET のルーティングを使用するです。 詳細については、次を参照してください。 [ASP.NET ルーティング](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a)です。  
  
   
  
## Examples  
 コード例は、次を参照してください。、<xref:System.Web.HttpContext.RewritePath%28System.String%29>メソッドのオーバー ロードします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Web.HttpException">
          <paramref name="path" /> パラメーターが、現在のアプリケーションのルート ディレクトリ内にありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="pathInfo" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filePath">内部リライト パス。</param>
        <param name="pathInfo">リソースの追加パス情報。 詳細については、「<see cref="P:System.Web.HttpRequest.PathInfo" />」を参照してください。</param>
        <param name="queryString">要求クエリ文字列。</param>
        <summary>指定されたパス、パス情報、およびクエリ文字列情報を使用して、URL をリライトします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.RewritePath%2A>メソッドは、URL を変更することがなく別のリソースにリソースの要求をリダイレクトします。  
  
 `filePath`パラメーターを含まない、`pathInfo`パラメーター コンテンツ。 URL のhttp://www.microsoft.com/virdir/page.html/tail、`filePath`パラメーターがhttp://www.microsoft.com/virdir/page.html、および`pathInfo`パラメーターがの末尾。  
  
 Web アプリケーションでページを再構築して、古い Url をブックマークしている人ように使用できますのページに移動した後かどうかを確認する場合は、URL の書き換えと便利です。 URL 書き換えには、透過的に新しいページの場所への要求を転送することができます。  
  
 検索エンジンがわかりやすいとは、最適化されている Url を使用するサイトを有効にする場合より堅牢な代替手段は、ASP.NET のルーティングを使用するです。 詳細については、次を参照してください。 [ASP.NET ルーティング](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a)です。  
  
   
  
## Examples  
 このメソッドのオーバー ロードの例を含むコード例は、次を参照してください。、<xref:System.Web.HttpContext.RewritePath%28System.String%29>メソッドのオーバー ロードします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> パラメーターが、現在のアプリケーションのルート ディレクトリ内にありません。</exception>
        <exception cref="T:System.Web.HttpException">
          <paramref name="filePath" /> パラメーターが、現在のアプリケーションのルート ディレクトリ内にありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString, bool setClientFilePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString, bool setClientFilePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String, setClientFilePath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString, bool setClientFilePath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="pathInfo" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
        <Parameter Name="setClientFilePath" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filePath">要求を処理するリソースへの仮想パス。</param>
        <param name="pathInfo">URL リダイレクトで使用する追加のパス情報。 詳細については、「<see cref="P:System.Web.HttpRequest.PathInfo" />」を参照してください。</param>
        <param name="queryString">URL リダイレクトで使用する要求クエリ文字列。</param>
        <param name="setClientFilePath">
          クライアント リソースで使用されるファイル パスを <c>filePath</c> パラメーターの値に設定する場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</param>
        <summary>指定した仮想パス、パス情報、クエリ文字列、およびクライアント ファイル パスをリライト パスに設定するかどうかを指定するブール値を使用して、URL をリライトします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `filePath`パラメーターの内容を含まない、`pathInfo`パラメーター。 URL のhttp://www.microsoft.com/virdir/page.html/tail、`filePath`パラメーターがhttp://www.microsoft.com/virdir/page.html、および`pathInfo`パラメーターがの末尾。  
  
 リソースへのパスを構築するために使用される仮想パスが変更されていないようにするには、設定、`setClientFilePath`パラメーターを`false`です。 設定する一般的なシナリオ`setClientFilePath`に`false`は、URL の書き換えする必要があるあり、テーマを使用して、要求されたリソースとは異なるフォルダーにあるリソースへの URL をリダイレクトするときにします。  
  
 Web アプリケーションでページを再構築して、古い Url をブックマークしている人ように使用できますのページに移動した後かどうかを確認する場合は、URL の書き換えと便利です。 URL 書き換えには、透過的に新しいページの場所への要求を転送することができます。  
  
 検索エンジンがわかりやすいとは、最適化されている Url を使用するサイトを有効にする場合より堅牢な代替手段は、ASP.NET のルーティングを使用するです。 詳細については、次を参照してください。 [ASP.NET ルーティング](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a)です。  
  
   
  
## Examples  
 コード例は、次を参照してください。、<xref:System.Web.HttpContext.RewritePath%28System.String%29>メソッドのオーバー ロードします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> パラメーターが、現在のアプリケーションのルート ディレクトリ内にありません。</exception>
        <exception cref="T:System.Web.HttpException">
          <paramref name="filePath" /> パラメーターが、現在のアプリケーションのルート ディレクトリ内にありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Web.HttpServerUtility Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpServerUtility Server" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Server" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Server As HttpServerUtility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpServerUtility ^ Server { System::Web::HttpServerUtility ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpServerUtility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web 要求の処理で使用されるメソッドを提供する <see cref="T:System.Web.HttpServerUtility" /> オブジェクトを取得します。</summary>
        <value>現在の HTTP 要求に対する <see cref="T:System.Web.HttpServerUtility" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.Server%2A>プロパティは、のプロパティおよびメソッドにプログラムでアクセスを提供、<xref:System.Web.HttpServerUtility>クラスです。 ASP.NET ページへの参照を既定値が含まれているため、<xref:System.Web>名前空間 (が含まれている、<xref:System.Web.HttpContext>クラス) のメンバーを参照できます<xref:System.Web.HttpContext>.aspx ページへの参照を完全修飾クラスを使用せずに<xref:System.Web.HttpContext>です。 たとえば、使用することができます`Server.CreateObject("MyCOMComponent")`サーバー上の COM オブジェクトのインスタンスを作成します。 ただしのメンバーを使用する場合は、 <xref:System.Web.HttpServerUtility> ASP.NET 分離コード モジュールからへの参照を含める必要があります、<xref:System.Web>モジュールで現在アクティブな要求/応答のコンテキストと内のクラス名の両方への参照を完全修飾名前空間<xref:System.Web>を使用します。 たとえば、分離コード ページである必要がありますを指定する完全修飾名`HttpContext.Current.Server.CreateObject("MyCOMComponent")`です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public System.Web.SessionState.HttpSessionState Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.SessionState.HttpSessionState Session" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Session" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Session As HttpSessionState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::SessionState::HttpSessionState ^ Session { System::Web::SessionState::HttpSessionState ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.SessionState.HttpSessionState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求に対する <see cref="T:System.Web.SessionState.HttpSessionState" /> オブジェクトを取得します。</summary>
        <value>現在の HTTP 要求に対する <see cref="T:System.Web.SessionState.HttpSessionState" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.Session%2A>プロパティは、のプロパティおよびメソッドにプログラムでアクセスを提供、<xref:System.Web.SessionState.HttpSessionState>クラスです。  
  
 セッション状態を使用するためには、これを有効にする必要です。 セッション状態を有効にする方法については、次を参照してください。**構成セッション状態**で[ASP.NET セッション状態の概要](http://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc)です。  
  
 セッション状態の値を保存する方法については、次を参照してください。[する方法: セッション状態の保存値](http://msdn.microsoft.com/library/a6cb2e3a-df49-4b12-9d9a-eed45541c165)です。 セッション状態から値を読み取る方法については、次を参照してください。[する方法: セッションの状態からの読み取り値](http://msdn.microsoft.com/library/2ef449bc-5c17-4785-b7cf-378c601af8f5)です。  
  
   
  
## Examples  
 次の例では、セッション状態の値を保存する方法とセッション状態の値を読み取る方法を示します。  
  
 これらの例には次の項目が必要です。  
  
-   有効になっているセッション状態を持つ ASP.NET アプリケーション。  
  
-   Web フォーム ページを持つクラスへのアクセス、<xref:System.Web.UI.Page.Session%2A?displayProperty=nameWithType>プロパティ、またはアクセス権を持つ任意のクラス、<xref:System.Web.HttpContext.Current%2A?displayProperty=nameWithType>プロパティです。  
  
```csharp  
string firstName = "Jeff";  
string lastName = "Smith";  
string city = "Seattle";  
  
// Save to session state in a Web Forms page class.  
Session["FirstName"] = firstName;  
Session["LastName"] = lastName;  
Session["City"] = city;  
  
// Read from session state in a Web Forms page class.  
firstName = (string)(Session["FirstName"]);  
lastName = (string)(Session["LastName"]);  
city = (string)(Session["City"]);  
  
// Outside of Web Forms page class, use HttpContext.Current.  
HttpContext context = HttpContext.Current;  
context.Session["FirstName"] = firstName;  
firstName = (string)(context.Session["FirstName"]);  
  
```  
  
```vb  
Dim firstName As String = "Jeff"  
Dim lastName As String = "Smith"  
Dim city As String = "Seattle"  
  
' Save to session state in a Web Forms page class.  
Session("FirstName") = firstName  
Session("LastName") = lastName  
Session("City") = city  
  
' Read from session state in a Web Forms page class.  
firstName = DirectCast(Session("FirstName"), String)  
lastName = DirectCast(Session("LastName"), String)  
city = DirectCast(Session("City"), String)  
  
' Outside of Web Forms page class, use HttpContext.Current.  
Dim context As HttpContext = HttpContext.Current  
context.Session("FirstName") = firstName  
firstName = DirectCast(context.Session("FirstName"), String)  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSessionStateBehavior">
      <MemberSignature Language="C#" Value="public void SetSessionStateBehavior (System.Web.SessionState.SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSessionStateBehavior(valuetype System.Web.SessionState.SessionStateBehavior sessionStateBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSessionStateBehavior(System::Web::SessionState::SessionStateBehavior sessionStateBehavior);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionStateBehavior" Type="System.Web.SessionState.SessionStateBehavior" />
      </Parameters>
      <Docs>
        <param name="sessionStateBehavior">必要なセッション状態の動作の種類を指定する列挙値の 1 つ。</param>
        <summary>HTTP 要求をサポートするために必要なセッション状態の動作の種類を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要求の HTTP ハンドラーが実装することでセッション状態が必要とするかどうかを示す ASP.NET の既定の実装で、<xref:System.Web.SessionState.IRequiresSessionState>インターフェイスまたは<xref:System.Web.SessionState.IReadOnlySessionState>インターフェイスです。 <xref:System.Web.HttpContext.SetSessionStateBehavior%2A>メソッドおよび<xref:System.Web.SessionState.SessionStateBehavior>列挙体を使用して、要求を処理するために必要なセッション状態サポートの種類についての詳細を提供できます。 詳細については、<xref:System.Web.SessionState.SessionStateBehavior> 列挙型のページをご覧ください。  
  
 <xref:System.Web.HttpContext.SetSessionStateBehavior%2A>する前にメソッドを呼び出す必要があります、<xref:System.Web.HttpApplication.AcquireRequestState>パイプライン イベント。 呼び出し時に、またはこのイベントの後に発生すると、<xref:System.InvalidOperationException>例外。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メソッドは、<see cref="E:System.Web.HttpApplication.AcquireRequestState" /> イベントの発生後に呼び出されました。</exception>
        <altmember cref="T:System.Web.SessionState.SessionStateBehavior" />
      </Docs>
    </Member>
    <Member MemberName="SkipAuthorization">
      <MemberSignature Language="C#" Value="public bool SkipAuthorization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipAuthorization" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.SkipAuthorization" />
      <MemberSignature Language="VB.NET" Value="Public Property SkipAuthorization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SkipAuthorization { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.Security.UrlAuthorizationModule" /> オブジェクトが現在の要求に対する承認チェックをスキップするかどうかを指定する値を取得または設定します。</summary>
        <value>
          <see cref="T:System.Web.Security.UrlAuthorizationModule" /> が承認チェックをスキップする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.SkipAuthorization%2A>プロパティは高度な用途に匿名接続を許可するページにリダイレクトする必要がある認証モジュールで対象とします。 両方の設定、フォーム認証モジュールと Passport 認証モジュール<xref:System.Web.HttpContext.SkipAuthorization%2A>構成済みのログオン ページにリダイレクトするときにします。 設定<xref:System.Web.HttpContext.SkipAuthorization%2A>が必要です、`ControlPrincipal`フラグが設定されます。 については、`ControlPrincipal`フラグを参照してください<xref:System.Security.Permissions.SecurityPermissionFlag>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IServiceProvider.GetService">
      <MemberSignature Language="C#" Value="object IServiceProvider.GetService (Type service);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IServiceProvider.GetService(class System.Type service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.System#IServiceProvider#GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function GetService (service As Type) As Object Implements IServiceProvider.GetService" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IServiceProvider.GetService(Type ^ service) = IServiceProvider::GetService;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="service">
          <see cref="T:System.Web.HttpContext" /> サービスの型。サービス プロバイダーをこの型に設定します。</param>
        <summary>現在のサービス型のオブジェクトを返します。</summary>
        <returns>
          <see cref="T:System.Web.HttpContext" />。サービスが見つからない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、基にアクセスするために役立ちます<xref:System.Web.HttpWorkerRequest>オブジェクト。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThreadAbortOnTimeout">
      <MemberSignature Language="C#" Value="public bool ThreadAbortOnTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ThreadAbortOnTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ThreadAbortOnTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ThreadAbortOnTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ThreadAbortOnTimeout { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求がタイムアウトしたときにこの要求に対処していたスレッド上で ASP.NET ランタイムが <see cref="M:System.Threading.Thread.Abort" /> を呼び出す必要があるかどうかを指定する値を取得または設定します。</summary>
        <value>
          スレッドのタイムアウト時に <see cref="M:System.Threading.Thread.Abort" /> が呼び出される場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ハンドラーおよびを使用しているモジュールで、 <xref:System.Web.HttpRequest.TimedOutToken%2A?displayProperty=nameWithType> 、連携によるキャンセル処理を実装するプロパティを無効にしておくことも、<xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>要求がタイムアウトしたときに、既定では ASP.NET を実行する動作です。このプロパティを設定`false`のキャンセル機能とクリーンアップ ルーチンが ASP.NET によって中断されることがなく実行されるかどうかを確認できます。  
  
 このプロパティを設定する場合`false`ASP.NET は自動的に表示されない、「要求がタイムアウトしました。」のエラー ページ、タイムアウトが発生したときにします。 アプリケーションは、応答コンテンツを適切に設定します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timestamp">
      <MemberSignature Language="C#" Value="public DateTime Timestamp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Timestamp" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Timestamp" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Timestamp As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Timestamp { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求の初期タイムスタンプを取得します。</summary>
        <value>現在の HTTP 要求のタイムスタンプ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返されたタイムスタンプ、<xref:System.Web.HttpContext.Timestamp%2A>プロパティは、サーバーのローカル時刻でありのインスタンス化時に設定され、<xref:System.Web.HttpContext>オブジェクト。 ローカル時刻は UTC 時刻と UTC のオフセットになります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trace">
      <MemberSignature Language="C#" Value="public System.Web.TraceContext Trace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.TraceContext Trace" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Trace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Trace As TraceContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::TraceContext ^ Trace { System::Web::TraceContext ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.TraceContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 応答に対する <see cref="T:System.Web.TraceContext" /> オブジェクトを取得します。</summary>
        <value>現在の HTTP 応答の <see cref="T:System.Web.TraceContext" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="User">
      <MemberSignature Language="C#" Value="public System.Security.Principal.IPrincipal User { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IPrincipal User" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.User" />
      <MemberSignature Language="VB.NET" Value="Public Property User As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::IPrincipal ^ User { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求のセキュリティ情報を取得または設定します。</summary>
        <value>現在の HTTP 要求のセキュリティ情報。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.User%2A>プロパティは、のプロパティおよびメソッドにプログラムでアクセスを提供、<xref:System.Security.Principal.IPrincipal>インターフェイスです。  
  
 ASP.NET ページへの参照を既定値が含まれているため、<xref:System.Web>名前空間 (が含まれている、<xref:System.Web.HttpContext>クラス) のメンバーを参照できます<xref:System.Web.HttpContext>.aspx ページへの参照を完全修飾クラスを使用せずに<xref:System.Web.HttpContext>です。 たとえば、使用することができます`User.Identity.Name`を実行して、現在のプロセスの代わりに、ユーザーの名前を取得します。 ただしのメンバーを使用する場合は、 <xref:System.Security.Principal.IPrincipal> ASP.NET 分離コード モジュールからへの参照を含める必要があります、<xref:System.Web>モジュールで現在アクティブな要求/応答のコンテキストと内のクラス名の両方への参照を完全修飾名前空間<xref:System.Web>を使用します。 たとえば、分離コード ページである必要がありますを指定する完全修飾名`HttpContext.Current.User.Identity.Name`です。  
  
   
  
## Examples  
 次の例を現在のユーザーのプロパティにアクセスする方法を示しています、<xref:System.Web.HttpContext.User%2A>プロパティです。 これらのプロパティは、Web ページのタイトルの設定に使用されます。  
  
 アプリケーションでは、Windows 認証を使用する場合、ユーザー名には、ドメインが含まれます。 たとえば、ページのタイトルは、「ドメイン \ ユーザー名のホーム ページ」になります。  
  
 [!code-csharp[System.Web.HttpContext.User#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext.User/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.HttpContext.User#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext.User/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WebSocketNegotiatedProtocol">
      <MemberSignature Language="C#" Value="public string WebSocketNegotiatedProtocol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebSocketNegotiatedProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketNegotiatedProtocol" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketNegotiatedProtocol As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WebSocketNegotiatedProtocol { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバーからクライアントに <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 接続のために送信されたネゴシエートされたプロトコルを取得します。</summary>
        <value>ネゴシエートされたプロトコル。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WebSocketRequestedProtocols">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;string&gt; WebSocketRequestedProtocols { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;string&gt; WebSocketRequestedProtocols" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketRequestedProtocols" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketRequestedProtocols As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::String ^&gt; ^ WebSocketRequestedProtocols { System::Collections::Generic::IList&lt;System::String ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアントから要求されたプロトコルの順序付きリストを取得します。</summary>
        <value>要求されたプロトコル。<see cref="T:System.Web.WebSockets.AspNetWebSocket" /> の要求でないか、リストがない場合は、<see langword="null" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>