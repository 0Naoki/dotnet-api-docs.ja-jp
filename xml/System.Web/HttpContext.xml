<Type Name="HttpContext" FullName="System.Web.HttpContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7ef623ac3971f5c1d08e051bf6b5d44769b36dee" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53506691" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpContext : IServiceProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpContext extends System.Object implements class System.IServiceProvider" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpContext" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpContext&#xA;Implements IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpContext sealed : IServiceProvider" />
  <TypeSignature Language="F#" Value="type HttpContext = class&#xA;    interface IServiceProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>それぞれの HTTP 要求に関する HTTP 固有のすべての情報をカプセル化します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 継承するクラス、<xref:System.Web.IHttpModule>と<xref:System.Web.IHttpHandler>への参照を提供するインターフェイス、<xref:System.Web.HttpContext>の現在の HTTP 要求オブジェクト。 オブジェクトは、組み込みへのアクセスを提供します。 <xref:System.Web.HttpContext.Request%2A>、 <xref:System.Web.HttpContext.Response%2A>、および<xref:System.Web.HttpContext.Server%2A>要求のプロパティ。  
  
> [!IMPORTANT] 
> このオブジェクトはガベージ コレクションの準備がときに、<xref:System.Web.HttpRequest>が完了します。 要求が完了したら、その使用になる可能性が未定義の動作など、<xref:System.NullReferenceException>します。
>
> このオブジェクトは、ASP.NET によって制御されるスレッドにできるだけです。 バック グラウンド スレッドでの使用状況は、未定義の動作をする可能性があります。

## Examples  
 次の例では、アクセスのプロパティを表示する方法、<xref:System.Web.HttpContext>オブジェクト。 現在の HTTP 要求のコンテキストを使用してアクセス、<xref:System.Web.UI.Page.Context%2A>のプロパティ、<xref:System.Web.UI.Page>オブジェクト。  
  
 [!code-aspx-csharp[System.Web.HttpContext#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext/cs/httpcontextcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpContext#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext/vb/httpcontextvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.IHttpModule" />
    <altmember cref="T:System.Web.IHttpHandler" />
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=196730">コンテキストの問題</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Web.HttpContext" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpWorkerRequest wr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpWorkerRequest wr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpWorkerRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (wr As HttpWorkerRequest)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpWorkerRequest ^ wr);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpContext : System.Web.HttpWorkerRequest -&gt; System.Web.HttpContext" Usage="new System.Web.HttpContext wr" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="wr" Type="System.Web.HttpWorkerRequest" />
      </Parameters>
      <Docs>
        <param name="wr">現在の HTTP 要求に対する <see cref="T:System.Web.HttpWorkerRequest" /> オブジェクト。</param>
        <summary>指定したワーカー要求オブジェクトを使用する <see cref="T:System.Web.HttpContext" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpRequest request, System.Web.HttpResponse response);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpRequest request, class System.Web.HttpResponse response) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpRequest,System.Web.HttpResponse)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (request As HttpRequest, response As HttpResponse)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpRequest ^ request, System::Web::HttpResponse ^ response);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpContext : System.Web.HttpRequest * System.Web.HttpResponse -&gt; System.Web.HttpContext" Usage="new System.Web.HttpContext (request, response)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="request" Type="System.Web.HttpRequest" />
        <Parameter Name="response" Type="System.Web.HttpResponse" />
      </Parameters>
      <Docs>
        <param name="request">現在の HTTP 要求に対する <see cref="T:System.Web.HttpRequest" /> オブジェクト。</param>
        <param name="response">現在の HTTP 要求に対する <see cref="T:System.Web.HttpResponse" /> オブジェクト。</param>
        <summary>指定した要求オブジェクトと応答オブジェクトを使用して、<see cref="T:System.Web.HttpContext" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcceptWebSocketRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 要求を受け入れます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc);" />
      <MemberSignature Language="F#" Value="member this.AcceptWebSocketRequest : Func&lt;System.Web.WebSockets.AspNetWebSocketContext, System.Threading.Tasks.Task&gt; -&gt; unit" Usage="httpContext.AcceptWebSocketRequest userFunc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="userFunc">ユーザー関数。</param>
        <summary>指定されたユーザー関数を使用して <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 要求を受け入れます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを呼び出すことは、呼び出しに相当、<xref:System.Web.HttpContext.AcceptWebSocketRequest%2A>メソッドのオーバー ロードを渡して`null`の`options`パラメーター。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="userFunc" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">この要求は <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 要求ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc, System.Web.WebSockets.AspNetWebSocketOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc, class System.Web.WebSockets.AspNetWebSocketOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task},System.Web.WebSockets.AspNetWebSocketOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task), options As AspNetWebSocketOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc, System::Web::WebSockets::AspNetWebSocketOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.AcceptWebSocketRequest : Func&lt;System.Web.WebSockets.AspNetWebSocketContext, System.Threading.Tasks.Task&gt; * System.Web.WebSockets.AspNetWebSocketOptions -&gt; unit" Usage="httpContext.AcceptWebSocketRequest (userFunc, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" />
        <Parameter Name="options" Type="System.Web.WebSockets.AspNetWebSocketOptions" />
      </Parameters>
      <Docs>
        <param name="userFunc">ユーザー関数。</param>
        <param name="options">オプションのオブジェクト。</param>
        <summary>指定されたユーザー関数とオプション オブジェクトを使用して <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 要求を受け入れます。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="userFunc" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">この要求は <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 要求ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="AddError">
      <MemberSignature Language="C#" Value="public void AddError (Exception errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddError(class System.Exception errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddError(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddError (errorInfo As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddError(Exception ^ errorInfo);" />
      <MemberSignature Language="F#" Value="member this.AddError : Exception -&gt; unit" Usage="httpContext.AddError errorInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorInfo" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="errorInfo">例外コレクションに追加する <see cref="T:System.Exception" />。</param>
        <summary>現在の HTTP 要求に対する例外コレクションに例外を追加します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnRequestCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnRequestCompleted (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnRequestCompleted(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddOnRequestCompleted(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnRequestCompleted (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnRequestCompleted(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.AddOnRequestCompleted : Action&lt;System.Web.HttpContext&gt; -&gt; System.Web.ISubscriptionToken" Usage="httpContext.AddOnRequestCompleted callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" />
      </Parameters>
      <Docs>
        <param name="callback">HTTP コンテキスト オブジェクト。</param>
        <summary>要求の HTTP 部分が終了するときに発生する仮想イベントを発生させます。</summary>
        <returns>サブスクリプション トークン。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントが発生する前に、<xref:System.Web.WebSockets.AspNetWebSocket>接続を開始します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="callback" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="AllErrors">
      <MemberSignature Language="C#" Value="public Exception[] AllErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception[] AllErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllErrors As Exception()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Exception ^&gt; ^ AllErrors { cli::array &lt;Exception ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllErrors : Exception[]" Usage="System.Web.HttpContext.AllErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP 要求の処理中に蓄積されたエラーの配列を取得します。</summary>
        <value>現在の HTTP 要求に対する <see cref="T:System.Exception" /> オブジェクトの配列。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAsyncDuringSyncStages">
      <MemberSignature Language="C#" Value="public bool AllowAsyncDuringSyncStages { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAsyncDuringSyncStages" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllowAsyncDuringSyncStages" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowAsyncDuringSyncStages As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowAsyncDuringSyncStages { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowAsyncDuringSyncStages : bool with get, set" Usage="System.Web.HttpContext.AllowAsyncDuringSyncStages" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ASP.NET 要求の一部の処理中に、それが予期されていない場合、非同期操作が許可されるかどうかを示す値を取得または設定します。</summary>
        <value>予期しない時期に非同期 API が使用されると ASP.NET が例外をスローする場合は <see langword="false" />、それ以外の場合は <see langword="true" />。 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このフラグは設定されていない場合`true`ASP.NET、非同期 API を悪用してアプリケーションを検出した場合に例外がスローされます。 これは、処理パイプラインでの非同期操作は必要ありません、要求の一部の中に、非同期メソッドを呼び出すしようとする場合、または、非同期のモジュールとハンドラー完了を通知するときにまだ保留中の非同期操作がある場合に発生することができます。 この動作は、セーフティ ネットとしてものでは収まらない非同期コード パターンを予想し、悪影響が出る場合がありますを記述しているかどうかを早い段階で確認できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplicationState Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplicationState Application" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Application" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Application As HttpApplicationState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplicationState ^ Application { System::Web::HttpApplicationState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Application : System.Web.HttpApplicationState" Usage="System.Web.HttpContext.Application" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求に対する <see cref="T:System.Web.HttpApplicationState" /> オブジェクトを取得します。</summary>
        <value>現在の HTTP 要求に対する <see cref="T:System.Web.HttpApplicationState" />。  
  
現在の HTTP 要求に対する <see cref="T:System.Web.HttpApplication" /> オブジェクトを取得するには、<see cref="P:System.Web.HttpContext.ApplicationInstance" /> を使用します。 (ASP.NET と従来の ASP との混同を避けるために、ASP.NET は <see langword="Application" /> の代わりに <see langword="ApplicationInstance" /> をプロパティ名として使用して、現在の <see cref="T:System.Web.HttpApplication" /> インスタンスを参照します。 従来の ASP では、<see langword="Application" /> はグローバル アプリケーション状態のディクショナリを参照します)。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.ApplicationInstance" />
      </Docs>
    </Member>
    <Member MemberName="ApplicationInstance">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplication ApplicationInstance { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplication ApplicationInstance" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ApplicationInstance" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationInstance As HttpApplication" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplication ^ ApplicationInstance { System::Web::HttpApplication ^ get(); void set(System::Web::HttpApplication ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationInstance : System.Web.HttpApplication with get, set" Usage="System.Web.HttpContext.ApplicationInstance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplication</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求に対する <see cref="T:System.Web.HttpApplication" /> オブジェクトを取得または設定します。</summary>
        <value>現在の HTTP 要求に対する <see cref="T:System.Web.HttpApplication" />。  
  
ASP.NET と従来の ASP との混同を避けるために、ASP.NET は <see langword="Application" /> の代わりに <see langword="ApplicationInstance" /> をプロパティ名として使用して、現在の <see cref="T:System.Web.HttpApplication" /> インスタンスを参照します。 従来の ASP では、<see langword="Application" /> はグローバル アプリケーション状態のディクショナリを参照します。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Web アプリケーションを IIS 7.0 の統合モードで実行しており、プロパティの値を、null 以外の値から　<see langword="null" /> に変更しようとしました。</exception>
        <altmember cref="P:System.Web.HttpContext.Application" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPreloadMode">
      <MemberSignature Language="C#" Value="public System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AsyncPreloadMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPreloadMode As AsyncPreloadModeFlags" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Configuration::AsyncPreloadModeFlags AsyncPreloadMode { System::Web::Configuration::AsyncPreloadModeFlags get(); void set(System::Web::Configuration::AsyncPreloadModeFlags value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPreloadMode : System.Web.Configuration.AsyncPreloadModeFlags with get, set" Usage="System.Web.HttpContext.AsyncPreloadMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Configuration.AsyncPreloadModeFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>非同期プリロード モードに関係するフラグを含むオブジェクトを取得または設定します。</summary>
        <value>非同期プリロード モードに関係するフラグを含むオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティにアクセスすると、初めて非同期プリロード モードのフラグを格納しているオブジェクトはから読み込まれた、<xref:System.Web.Configuration.HttpRuntimeSection.AsyncPreloadMode%2A>構成ファイルで設定します。  
  
 このプロパティはプログラムで設定できますが、プロパティ値の変更が有効なのは、ASP.NET の要求パイプラインの `ExecuteRequestHandler` の手順の前にプロパティが設定されている場合のみです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.Caching.Cache Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Caching.Cache Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As Cache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Caching::Cache ^ Cache { System::Web::Caching::Cache ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cache : System.Web.Caching.Cache" Usage="System.Web.HttpContext.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Caching.Cache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のアプリケーション ドメインに対する <see cref="T:System.Web.Caching.Cache" /> オブジェクトを取得します。</summary>
        <value>現在のアプリケーション ドメインに対する <see cref="T:System.Web.Caching.Cache" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インスタンスは 1 つ、<xref:System.Web.Caching.Cache>アプリケーション ドメインごとにクラス。 結果として、<xref:System.Web.Caching.Cache>によって返されるオブジェクト、<xref:System.Web.HttpContext.Cache%2A>プロパティは、<xref:System.Web.Caching.Cache>アプリケーション ドメイン内のすべての要求オブジェクト。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.ClearError" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearError ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearError();" />
      <MemberSignature Language="F#" Value="member this.ClearError : unit -&gt; unit" Usage="httpContext.ClearError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の HTTP 要求に対するすべてのエラーをクリアします。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.Error" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Web.HttpContext Current { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.HttpContext Current" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Current As HttpContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::HttpContext ^ Current { System::Web::HttpContext ^ get(); void set(System::Web::HttpContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Web.HttpContext with get, set" Usage="System.Web.HttpContext.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求に対する <see cref="T:System.Web.HttpContext" /> オブジェクトを取得または設定します。</summary>
        <value>現在の HTTP リクエストに対する <see cref="T:System.Web.HttpContext" /> インスタンス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、静的プロパティの<xref:System.Web.HttpContext>クラス。 プロパティ ストア、<xref:System.Web.HttpContext>インスタンスを現在の要求に適用されます。 このインスタンスのプロパティは次の非静的プロパティ、<xref:System.Web.HttpContext>クラス。  
  
 使用することも、<xref:System.Web.UI.Page.Context%2A?displayProperty=nameWithType>プロパティにアクセスする、<xref:System.Web.HttpContext>の現在の HTTP 要求オブジェクト。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Web.HttpContext.Current%2A>プロパティにアクセスする、<xref:System.Web.HttpContext.AddError%2A?displayProperty=nameWithType>と<xref:System.Web.HttpContext.ClearError%2A?displayProperty=nameWithType>メソッドと<xref:System.Web.HttpContext.AllErrors%2A?displayProperty=nameWithType>プロパティ。 例を使用して 3 つのカスタム例外を作成する、<xref:System.Web.HttpContext.AddError%2A>メソッドを使用して、<xref:System.Web.HttpContext.AllErrors%2A>プロパティを配列にこれらの例外を読み込めません。 次に、配列を含むページを書き込み、を使用して、<xref:System.Web.HttpContext.ClearError%2A>からすべてのエラーをクリアする方法、<xref:System.Web.UI.Page.Context%2A>プロパティ。  
  
```csharp  
protected void Page_Load(object sender, EventArgs e)  
{  
    HttpContext context = HttpContext.Current;  
    Response.Write("<p>HttpContext.Current Example:</p>");  
  
    // Add three custom exceptions.  
    context.AddError(new Exception("New Exception #1"));  
    context.AddError(new Exception("New Exception #2"));  
    context.AddError(new Exception("New Exception #3"));  
  
    // Capture all the new Exceptions in an array.  
    Exception[] errs = context.AllErrors;  
  
    foreach (Exception ex in errs)  
    {  
        Response.Write("<p>" + Server.HtmlEncode(ex.ToString()) + "</p>");  
    }  
  
    // Clear the exceptions so ASP.NET won't handle them.  
    context.ClearError();  
}  
```  
  
```vb  
Protected Sub Page_Load(sender As Object, e As EventArgs)  
Dim context As HttpContext = HttpContext.Current  
Response.Write("<p>HttpContext.Current Example:</p>")  
  
' Add three custom exceptions.  
context.AddError(New Exception("New Exception #1"))  
context.AddError(New Exception("New Exception #2"))  
context.AddError(New Exception("New Exception #3"))  
  
' Capture all the new Exceptions in an array.  
Dim errs As Exception() = context.AllErrors  
  
For Each ex As Exception In errs  
Response.Write("<p>" & Server.HtmlEncode(ex.ToString()) & "</p>")  
Next  
  
' Clear the exceptions so ASP.NET won't handle them.  
context.ClearError()  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Response" />
        <altmember cref="P:System.Web.HttpContext.Request" />
      </Docs>
    </Member>
    <Member MemberName="CurrentHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler CurrentHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler CurrentHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ CurrentHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentHandler : System.Web.IHttpHandler" Usage="System.Web.HttpContext.CurrentHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在実行中のハンドラーを表す <see cref="T:System.Web.IHttpHandler" /> オブジェクトを取得します。</summary>
        <value>現在実行中のハンドラーを表す <see cref="T:System.Web.IHttpHandler" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在実行中のハンドラーによって参照される、<xref:System.Web.HttpContext.CurrentHandler%2A>プロパティによって参照されているハンドラーとは異なる場合があります、<xref:System.Web.HttpContext.Handler%2A>プロパティ。 これを使用して別のハンドラーが要求されたときに発生することができます、<xref:System.Web.HttpServerUtility.Execute%2A>メソッドまたは<xref:System.Web.HttpServerUtility.Transfer%2A>メソッド。 現在実行中のハンドラーには、処理が完了すると、事前に決定されたハンドラーが復元されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b">HTTP ハンドラーと HTTP モジュールの概要</related>
      </Docs>
    </Member>
    <Member MemberName="CurrentNotification">
      <MemberSignature Language="C#" Value="public System.Web.RequestNotification CurrentNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.RequestNotification CurrentNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentNotification As RequestNotification" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::RequestNotification CurrentNotification { System::Web::RequestNotification get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentNotification : System.Web.RequestNotification" Usage="System.Web.HttpContext.CurrentNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.RequestNotification</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>処理中の現在の <see cref="T:System.Web.HttpApplication" /> イベントを示す <see cref="T:System.Web.RequestNotification" /> 値を取得します。</summary>
        <value><see cref="T:System.Web.RequestNotification" /> 値のいずれか。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.CurrentNotification%2A>プロパティには、統合パイプライン モードが必要です。[!INCLUDE[iisver](~/includes/iisver-md.md)]と、少なくとも .NET Framework バージョン 3.0。 プロパティを返す、使用可能な場合、<xref:System.Web.RequestNotification>値。 値、<xref:System.Web.HttpContext.CurrentNotification%2A>プロパティでイベントを示す、<xref:System.Web.HttpApplication>インスタンスが現在の要求を処理します。  
  
 <xref:System.Web.HttpContext.CurrentNotification%2A>プロパティを設定する必要はありません。 代わりに、によって設定された[!INCLUDE[iisver](~/includes/iisver-md.md)]ASP.NET パイプラインで要求を処理中にします。 設定、<xref:System.Web.HttpContext.CurrentNotification%2A>プロパティは、コンパイル エラーになります。  
  
 <xref:System.Web.HttpContext.CurrentNotification%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework のバージョンおよび依存関係](~/docs/framework/migration-guide/versions-and-dependencies.md)」を参照してください。  
  
   
  
## Examples  
 次の例では、使用する方法、<xref:System.Web.HttpContext.CurrentNotification%2A>のどのようなイベントを決定するプロパティ、<xref:System.Web.HttpApplication>現在の要求を処理しているオブジェクトが処理されています。 複数のイベントを処理するイベント ハンドラーの例で、<xref:System.Web.HttpApplication>オブジェクト、および<xref:System.Web.HttpContext.CurrentNotification%2A>プロパティは、どのようなコードが処理される各イベントに対して呼び出されるを決定します。  
  
 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">この操作を実行するには、[!INCLUDE[iisver](~/includes/iisver-md.md)] の統合パイプライン モードおよび .NET Framework Version 3.0 以降が必要です。</exception>
        <altmember cref="P:System.Web.HttpContext.IsPostNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="DisposeOnPipelineCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken DisposeOnPipelineCompleted (IDisposable target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken DisposeOnPipelineCompleted(class System.IDisposable target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.DisposeOnPipelineCompleted(System.IDisposable)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisposeOnPipelineCompleted (target As IDisposable) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ DisposeOnPipelineCompleted(IDisposable ^ target);" />
      <MemberSignature Language="F#" Value="member this.DisposeOnPipelineCompleted : IDisposable -&gt; System.Web.ISubscriptionToken" Usage="httpContext.DisposeOnPipelineCompleted target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.IDisposable" />
      </Parameters>
      <Docs>
        <param name="target">要求の <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 接続部分が完了したときに、<see cref="M:System.IDisposable.Dispose" /> メソッドを呼び出す必要のあるオブジェクト。</param>
        <summary>この要求の <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 接続部分が完了したときに、オブジェクトの <see cref="M:System.IDisposable.Dispose" /> メソッドを呼び出すことができるようにします。</summary>
        <returns>サブスクリプション トークン。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IDisposable.Dispose%2A>要求の HTTP 部分後、ターゲット オブジェクトのメソッドが呼び出された、<xref:System.Web.WebSockets.AspNetWebSocket>の接続が終了しました。 <xref:System.Web.HttpContext>オブジェクトは検査のために使用できません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public Exception Error { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception Error" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Error" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Error As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ Error { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Error : Exception" Usage="System.Web.HttpContext.Error" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP 要求の処理中にエラーが蓄積された場合は、その最初のエラーを取得します。</summary>
        <value>現在の HTTP 要求または HTTP 応答の処理に対する最初の <see cref="T:System.Exception" />。HTTP 要求処理中にエラーが 1 つも蓄積されなかった場合は、<see langword="null" />。 既定値は、<see langword="null" /> です。</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.HttpContext.ClearError" />
      </Docs>
    </Member>
    <Member MemberName="GetAppConfig">
      <MemberSignature Language="C#" Value="public static object GetAppConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetAppConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetAppConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAppConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetAppConfig(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetAppConfig : string -&gt; obj" Usage="System.Web.HttpContext.GetAppConfig name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">情報が要求されたアプリケーションの構成タグ。</param>
        <summary>現在のアプリケーションに対して要求された構成情報を返します。</summary>
        <returns>構成情報を格納するオブジェクト。 (返された構成セクションは、適切な構成型にキャストしてから使用してください。)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.GetAppConfig%2A> メソッドの使用は非推奨とされました。 使用して、<xref:System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection%2A>のメソッド、<xref:System.Web.Configuration.WebConfigurationManager>クラスは、現在のアプリケーションの構成情報を取得します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Configuration.WebConfigurationManager" />
      </Docs>
    </Member>
    <Member MemberName="GetConfig">
      <MemberSignature Language="C#" Value="public object GetConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetConfig(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetConfig : string -&gt; obj" Usage="httpContext.GetConfig name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.HttpContext.GetSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">情報が要求された構成タグ。</param>
        <summary>現在の HTTP 要求に対して要求された構成情報を返します。</summary>
        <returns>指定した <see cref="T:System.Configuration.ConfigurationSection" />。このセクションが存在しない場合は <see langword="null" />。このセクションに実行時にアクセスできない場合は内部オブジェクト。 (返されたオブジェクトは、適切な構成型にキャストしてから使用してください。)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.GetConfig%2A> メソッドの使用は非推奨とされました。 使用して、<xref:System.Web.HttpContext.GetSection%2A>現在の HTTP 要求の構成情報を取得します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpContext.GetSection(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGlobalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>アプリケーション レベル リソースを取得します。</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">アプリケーションのリソース</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">ASP.NET Web サイトのレイアウト</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey);" />
      <MemberSignature Language="F#" Value="static member GetGlobalResourceObject : string * string -&gt; obj" Usage="System.Web.HttpContext.GetGlobalResourceObject (classKey, resourceKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="classKey">要求されたリソース オブジェクトの <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> プロパティを表す文字列。</param>
        <param name="resourceKey">要求されたリソース オブジェクトの <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティを表す文字列。</param>
        <summary>アプリケーション レベル リソース オブジェクトを、指定した <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> プロパティおよび <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティに基づいて取得します。</summary>
        <returns>要求されたアプリケーション レベル リソース オブジェクトを表す <see cref="T:System.Object" />。リソース オブジェクトが見つからない場合、またはリソース オブジェクトが見つかってもそれが要求されたプロパティを持っていない場合は null。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.GetGlobalResourceObject%2A>メソッドで指定されているカルチャを使用してグローバル リソースを返します、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A>プロパティ。  
  
> [!NOTE]
>  編集環境などのいくつか[!INCLUDE[vwprvw](~/includes/vwprvw-md.md)]、デザイン時エディターをスローする可能性<xref:System.Resources.MissingManifestResourceException>グローバルのリソース キー名にピリオド (.) を使用する場合は例外です。 ただし、これには影響しません編集したり、ファイルを保存できると、エラーを無視することができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">指定した <paramref name="classKey" /> パラメーターのリソース オブジェクトが見つかりませんでした。  
  
または 
メイン アセンブリにニュートラル カルチャのリソースが含まれていません。適切なサテライト アセンブリが見つからないためこれらのリソースが必要です。</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">アプリケーションのリソース</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">ASP.NET Web サイトのレイアウト</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">リソースのパッケージ化と配置</related>
      </Docs>
    </Member>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member GetGlobalResourceObject : string * string * System.Globalization.CultureInfo -&gt; obj" Usage="System.Web.HttpContext.GetGlobalResourceObject (classKey, resourceKey, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="classKey">要求されたリソース オブジェクトの <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> プロパティを表す文字列。</param>
        <param name="resourceKey">要求されたリソース オブジェクトの <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティを表す文字列。</param>
        <param name="culture">要求されたリソースの <see cref="T:System.Globalization.CultureInfo" /> オブジェクトを表す文字列。</param>
        <summary>アプリケーション レベル リソース オブジェクトを、指定した <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> プロパティおよび <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティ、および <see cref="T:System.Globalization.CultureInfo" /> オブジェクトに基づいて取得します。</summary>
        <returns>要求されたアプリケーション レベル リソース オブジェクトを表す <see cref="T:System.Object" />。これは、特定のカルチャにローカライズされます。リソース オブジェクトが見つからない場合、またはリソース オブジェクトが見つかってもそれが要求されたプロパティを持っていない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Globalization.CultureInfo>オブジェクトは、リソースのローカライズ対象のカルチャを表します。 リソースがこのカルチャのローカライズされていない場合、検索には、適切なリソースを検索するフォールバック プロセスに従います。 詳細については、「[リソースのパッケージ化と配置](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)」を参照してください。  
  
> [!NOTE]
>  Visual Web Developer など、一部の編集環境で、エディターのデザイン時がスロー<xref:System.Resources.MissingManifestResourceException>グローバルのリソース キー名にピリオド (.) を使用する場合は例外です。 ただし、これには影響しません編集したり、ファイルを保存できると、エラーを無視することができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">指定した <paramref name="classKey" /> パラメーターが見つからなかったリソース オブジェクト。  
  
または 
メイン アセンブリにニュートラル カルチャのリソースが含まれていません。適切なサテライト アセンブリが見つからないためこれらのリソースが必要です。</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">アプリケーションのリソース</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">リソースのパッケージ化と配置</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLocalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ページ レベル リソースを取得します。</summary>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">アプリケーションのリソース</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">ASP.NET Web サイトのレイアウト</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">リソースのパッケージ化と配置</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey);" />
      <MemberSignature Language="F#" Value="static member GetLocalResourceObject : string * string -&gt; obj" Usage="System.Web.HttpContext.GetLocalResourceObject (virtualPath, resourceKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">ローカル リソース オブジェクトのための <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> プロパティ。</param>
        <param name="resourceKey">要求されたリソース オブジェクトの <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティを表す文字列。</param>
        <summary>ページ レベル リソース オブジェクトを、指定した <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> プロパティおよび <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティに基づいて取得します。</summary>
        <returns>要求されたページ レベル リソース オブジェクトを表す <see cref="T:System.Object" />。一致するリソース オブジェクトが見つかっても <paramref name="resourceKey" /> パラメーターではない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.GetLocalResourceObject%2A>メソッドで指定されているカルチャを使用してローカル リソースを返します、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A>プロパティ。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">指定した <paramref name="virtualPath" /> パラメーターのリソース オブジェクトが見つかりませんでした。</exception>
        <exception cref="T:System.ArgumentException">指定した <paramref name="virtualPath" /> パラメーターが、現在のアプリケーションのルート ディレクトリ内にありません。</exception>
        <exception cref="T:System.InvalidOperationException">目的のページのリソース クラスが見つかりませんでした。</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">アプリケーションのリソース</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">ASP.NET Web サイトのレイアウト</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">リソースのパッケージ化と配置</related>
        <related type="Article" href="https://msdn.microsoft.com/library/7a06d512-6fc3-40ca-9cb6-7f41d1a9fa28">方法: プログラムでリソースの値を取得します。</related>
      </Docs>
    </Member>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member GetLocalResourceObject : string * string * System.Globalization.CultureInfo -&gt; obj" Usage="System.Web.HttpContext.GetLocalResourceObject (virtualPath, resourceKey, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="virtualPath">ローカル リソース オブジェクトのための <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> プロパティ。</param>
        <param name="resourceKey">要求されたリソース オブジェクトの <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティを表す文字列。</param>
        <param name="culture">要求されたリソース オブジェクトの <see cref="T:System.Globalization.CultureInfo" /> オブジェクトを表す文字列。</param>
        <summary>ページ レベル リソース オブジェクトを、指定した <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> プロパティおよび <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティ、および <see cref="T:System.Globalization.CultureInfo" /> オブジェクトに基づいて取得します。</summary>
        <returns>要求されたローカル リソース オブジェクトを表す <see cref="T:System.Object" />。これは、特定のカルチャにローカライズされます。一致するリソース オブジェクトが見つかっても <paramref name="resourceKey" /> パラメーターではない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 リソースがこのカルチャのローカライズされていない場合、検索には、適切なリソースを検索するフォールバック プロセスに従います。 詳細については、「[リソースのパッケージ化と配置](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">指定した <paramref name="virtualPath" /> パラメーターのリソース オブジェクトが見つかりませんでした。</exception>
        <exception cref="T:System.ArgumentException">指定した <paramref name="virtualPath" /> パラメーターが、現在のアプリケーションのルート ディレクトリ内にありません。</exception>
        <exception cref="T:System.InvalidOperationException">目的のページのリソース クラスが見つかりませんでした。</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">アプリケーションのリソース</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">ASP.NET Web サイトのレイアウト</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">リソースのパッケージ化と配置</related>
        <related type="Article" href="https://msdn.microsoft.com/library/7a06d512-6fc3-40ca-9cb6-7f41d1a9fa28">方法: プログラムでリソースの値を取得します。</related>
      </Docs>
    </Member>
    <Member MemberName="GetSection">
      <MemberSignature Language="C#" Value="public object GetSection (string sectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSection(string sectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetSection(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSection (sectionName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSection(System::String ^ sectionName);" />
      <MemberSignature Language="F#" Value="member this.GetSection : string -&gt; obj" Usage="httpContext.GetSection sectionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sectionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sectionName">構成セクション パス (XPath 形式) および構成要素名。</param>
        <summary>現在のアプリケーションの既定構成の、指定した構成セクションを取得します。</summary>
        <returns>指定した <see cref="T:System.Configuration.ConfigurationSection" />。このセクションが存在しない場合は <see langword="null" />。このセクションに実行時にアクセスできない場合は内部オブジェクト。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Configuration.ConfigurationManager.GetSection(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Handler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler Handler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler Handler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Handler" />
      <MemberSignature Language="VB.NET" Value="Public Property Handler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ Handler { System::Web::IHttpHandler ^ get(); void set(System::Web::IHttpHandler ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Handler : System.Web.IHttpHandler with get, set" Usage="System.Web.HttpContext.Handler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP 要求の処理を実行する <see cref="T:System.Web.IHttpHandler" /> オブジェクトを取得または設定します。</summary>
        <value>HTTP 要求の処理を実行する <see cref="T:System.Web.IHttpHandler" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.Handler%2A>プロパティには、HTTP 要求を処理するハンドラーへの参照が含まれています。 ハンドラーは、要素を使用して、またはユーザー コードで定義されているカスタム ハンドラーを使用して指定できます。 ハンドラーの詳細については、次を参照してください。 [HTTP ハンドラーと HTTP モジュールの概要](https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b)します。  
  
 参照、<xref:System.Web.HttpContext.Handler%2A>プロパティは同じままでは、サーバー側のメソッドでは、現在のページがなどに変更後も、<xref:System.Web.HttpServerUtility.Execute%2A>メソッドまたは<xref:System.Web.HttpServerUtility.Transfer%2A>メソッド。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b">HTTP ハンドラーと HTTP モジュールの概要</related>
      </Docs>
    </Member>
    <Member MemberName="IsCustomErrorEnabled">
      <MemberSignature Language="C#" Value="public bool IsCustomErrorEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomErrorEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsCustomErrorEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCustomErrorEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCustomErrorEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCustomErrorEnabled : bool" Usage="System.Web.HttpContext.IsCustomErrorEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求に対してカスタム エラーが有効かどうかを示す値を取得します。</summary>
        <value>カスタム エラーが有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDebuggingEnabled">
      <MemberSignature Language="C#" Value="public bool IsDebuggingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDebuggingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsDebuggingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDebuggingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDebuggingEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDebuggingEnabled : bool" Usage="System.Web.HttpContext.IsDebuggingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求がデバッグ モードかどうかを示す値を取得します。</summary>
        <value>要求がデバッグ モードである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPostNotification">
      <MemberSignature Language="C#" Value="public bool IsPostNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsPostNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPostNotification As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPostNotification { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPostNotification : bool" Usage="System.Web.HttpContext.IsPostNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.HttpApplication" /> イベントが処理を終了した直後の ASP.NET パイプライン内の現在の処理ポイントである値を取得します。</summary>
        <value>カスタム エラーが有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.IsPostNotification%2A>プロパティは、統合モードでのみサポート[!INCLUDE[iisver](~/includes/iisver-md.md)]と、少なくとも .NET Framework 3.0。 示すブール値を返します、使用可能な場合、イベントであるかどうか、<xref:System.Web.HttpApplication>オブジェクトの処理が完了します。  
  
 <xref:System.Web.HttpContext.IsPostNotification%2A>プロパティを設定する必要はありません。 によって提供される代わりに、[!INCLUDE[iisver](~/includes/iisver-md.md)]通知ごとに、ASP.NET ランタイムにします。 設定、<xref:System.Web.HttpContext.IsPostNotification%2A>プロパティは、コンパイル エラーになります。  
  
 シナリオの複数のイベント、<xref:System.Web.HttpApplication>オブジェクトが 1 つのイベント ハンドラーによって処理される、使用することができます、<xref:System.Web.HttpContext.IsPostNotification%2A>プロパティと組み合わせて、<xref:System.Web.RequestNotification>現在のアプリケーション ライフ サイクルのどこを正確に決める列挙型要求は次のとおりです。  
  
 <xref:System.Web.HttpContext.IsPostNotification%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework のバージョンおよび依存関係](~/docs/framework/migration-guide/versions-and-dependencies.md)」を参照してください。  
  
   
  
## Examples  
 次の例を使用する方法を示します、<xref:System.Web.HttpContext.IsPostNotification%2A>ときのイベントを決定するプロパティ、<xref:System.Web.HttpApplication>オブジェクトには、すべての関連するイベント ハンドラーの処理が完了しました。 この例では、カスタム イベント ハンドラーの複数のイベントを処理する、<xref:System.Web.HttpApplication>オブジェクト、および<xref:System.Web.HttpContext.IsPostNotification%2A>プロパティを使用して、どのようなコードが呼び出されるかを判断、特定のイベントが処理された後です。  
  
 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">この操作を実行するには、[!INCLUDE[iisver](~/includes/iisver-md.md)] の統合パイプライン モードおよび .NET Framework 3.0 以降が必要です。</exception>
        <altmember cref="P:System.Web.HttpContext.CurrentNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequest">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequest { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequest" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequest" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequest As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequest { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWebSocketRequest : bool" Usage="System.Web.HttpContext.IsWebSocketRequest" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求が <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 要求かどうかを示す値を取得します。</summary>
        <value>要求が <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 要求である場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが戻る`true`初期が要求に含まれている場合<xref:System.Web.WebSockets.AspNetWebSocket>ハンドシェイクと`WebSocket`IIS のモジュールがアクティブです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequestUpgrading">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequestUpgrading { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequestUpgrading" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequestUpgrading" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequestUpgrading As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequestUpgrading { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWebSocketRequestUpgrading : bool" Usage="System.Web.HttpContext.IsWebSocketRequestUpgrading" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>接続が HTTP 接続から <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 接続にアップグレードされるかどうかを示す値を取得します。</summary>
        <value>接続がアップグレード中の場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Items" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Items { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Collections.IDictionary" Usage="System.Web.HttpContext.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP 要求時に <see cref="T:System.Web.IHttpModule" /> インターフェイスと <see cref="T:System.Web.IHttpHandler" /> インターフェイスとの間でデータを編成および共有するために使用できるキー/値のコレクションを取得します。</summary>
        <value>キーの指定によるコレクションの個々の値へのアクセスを実現する <see cref="T:System.Collections.IDictionary" /> キー/値のコレクション。</value>
        <remarks>To be added.</remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms972109.aspx">コンテキストの問題</related>
      </Docs>
    </Member>
    <Member MemberName="PageInstrumentation">
      <MemberSignature Language="C#" Value="public System.Web.Instrumentation.PageInstrumentationService PageInstrumentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Instrumentation.PageInstrumentationService PageInstrumentation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PageInstrumentation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PageInstrumentation As PageInstrumentationService" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Instrumentation::PageInstrumentationService ^ PageInstrumentation { System::Web::Instrumentation::PageInstrumentationService ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageInstrumentation : System.Web.Instrumentation.PageInstrumentationService" Usage="System.Web.HttpContext.PageInstrumentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Instrumentation.PageInstrumentationService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要求のページ インストルメンテーション サービス インスタンスへの参照を取得します。</summary>
        <value>この要求のページ インストルメンテーション サービス インスタンス。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviousHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler PreviousHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler PreviousHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PreviousHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreviousHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ PreviousHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreviousHandler : System.Web.IHttpHandler" Usage="System.Web.HttpContext.PreviousHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>親ハンドラーの <see cref="T:System.Web.IHttpHandler" /> オブジェクトを取得します。</summary>
        <value><see cref="T:System.Web.IHttpHandler" /> インスタンス。以前のハンドラーが見つからなかった場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.PreviousHandler%2A>プロパティは、対応最後のハンドラーが、現在の要求の実行前にします。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b">HTTP ハンドラーと HTTP モジュールの概要</related>
      </Docs>
    </Member>
    <Member MemberName="Profile">
      <MemberSignature Language="C#" Value="public System.Web.Profile.ProfileBase Profile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Profile.ProfileBase Profile" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Profile" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Profile As ProfileBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Profile::ProfileBase ^ Profile { System::Web::Profile::ProfileBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Profile : System.Web.Profile.ProfileBase" Usage="System.Web.HttpContext.Profile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Profile.ProfileBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のユーザー プロファイルの <see cref="T:System.Web.Profile.ProfileBase" /> オブジェクトを取得します。</summary>
        <value>アプリケーションの構成ファイルにプロファイルのプロパティが定義されている場合は <see cref="T:System.Web.Profile.ProfileBase" />。それ以外の場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Web.HttpContext.Profile%2A>プロパティがタイプ セーフな API を使用して構造化データの永続的ストレージに使用します。 ときに、<xref:System.Web.HttpContext.Profile%2A>プロパティにアクセスしますが、値が存在しない、空のインスタンスが返されます。`null`は返されません。  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Web.Profile" />
      </Docs>
    </Member>
    <Member MemberName="RemapHandler">
      <MemberSignature Language="C#" Value="public void RemapHandler (System.Web.IHttpHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemapHandler(class System.Web.IHttpHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemapHandler (handler As IHttpHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemapHandler(System::Web::IHttpHandler ^ handler);" />
      <MemberSignature Language="F#" Value="member this.RemapHandler : System.Web.IHttpHandler -&gt; unit" Usage="httpContext.RemapHandler handler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" />
      </Parameters>
      <Docs>
        <param name="handler">要求を処理するオブジェクト。</param>
        <summary>要求のハンドラーを指定できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定した場合`handler`に`null`既定のハンドラーは要求を処理するために使用します。 設定できる`handler`非同期ハンドラーまたは同期のハンドラー。 ハンドラーを実装する必要があります、<xref:System.Web.IHttpHandler>インターフェイス。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" /> メソッドが、<see cref="E:System.Web.HttpApplication.MapRequestHandler" /> イベントの発生後に呼び出されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.Web.HttpRequest Request { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpRequest Request" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Request" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Request As HttpRequest" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpRequest ^ Request { System::Web::HttpRequest ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Request : System.Web.HttpRequest" Usage="System.Web.HttpContext.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpRequest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求に対する <see cref="T:System.Web.HttpRequest" /> オブジェクトを取得します。</summary>
        <value>現在の HTTP 要求に対する <see cref="T:System.Web.HttpRequest" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.Request%2A>プロパティのメソッドとプロパティにプログラムでアクセスを提供する、<xref:System.Web.HttpRequest>クラス。 ASP.NET ページには、既定値への参照が含まれているため、<xref:System.Web>名前空間 (が含まれています、<xref:System.Web.HttpContext>クラス) のメンバーを参照する<xref:System.Web.HttpRequest>.aspx ページへの参照を完全修飾クラスを使用せずに<xref:System.Web.HttpContext>します。 たとえば、使用することができます`Request.Browser`クライアントのブラウザーの機能を取得します。 ただしのメンバーを使用する場合<xref:System.Web.HttpRequest>ASP.NET 分離コード モジュールからへの参照を含める必要があります、<xref:System.Web>モジュールで現在アクティブな要求/応答コンテキストへの参照を完全修飾名前空間およびクラスの<xref:System.Web>を使用します。 たとえば、分離コード ページにする必要があります名を指定する、完全修飾`HttpContext.Current.Request.Browser`します。  
  
> [!NOTE]
>  このプロパティを使用しようとする場合に ASP.NET が例外をスロー時に、<xref:System.Web.HttpRequest>オブジェクトは使用できません。 たとえば、global.asax の Application_Start メソッドまたは Application_Start メソッドから呼び出されるメソッドは true。 これになります。 その時点で HTTP 要求がまだ作成されていません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Web アプリケーションは IIS 7 の統合モードで実行されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Response">
      <MemberSignature Language="C#" Value="public System.Web.HttpResponse Response { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpResponse Response" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Response" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Response As HttpResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpResponse ^ Response { System::Web::HttpResponse ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Response : System.Web.HttpResponse" Usage="System.Web.HttpContext.Response" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpResponse</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 応答に対する <see cref="T:System.Web.HttpResponse" /> オブジェクトを取得します。</summary>
        <value>現在の HTTP 応答の <see cref="T:System.Web.HttpResponse" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.Response%2A>プロパティのメソッドとプロパティにプログラムでアクセスを提供する、<xref:System.Web.HttpResponse>クラス。 ASP.NET ページには、既定値への参照が含まれているため、<xref:System.Web>名前空間 (が含まれています、<xref:System.Web.HttpContext>クラス) のメンバーを参照する<xref:System.Web.HttpContext>.aspx ページへの参照を完全修飾クラスを使用せずに<xref:System.Web.HttpContext>します。 たとえば、使用することができます`Response.Write("some output")`HTTP 出力ストリームに出力を書き込む。 ただしのメンバーを使用する場合<xref:System.Web.HttpResponse>ASP.NET 分離コード モジュールからへの参照を含める必要があります、<xref:System.Web>モジュールと、現在アクティブな要求/応答コンテキストと内のクラスへの参照を完全修飾名前空間<xref:System.Web>を使用します。 たとえば、分離コード ページにする必要があります名を指定する、完全修飾`HttpContext.Current.Response.Write("some output")`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Web アプリケーションは IIS 7 の統合モードで実行されています。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RewritePath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>リソースの要求を、要求された URL で示されているものとは別のパスにリダイレクトします。 <see cref="Overload:System.Web.HttpContext.RewritePath" /> は、Cookie を使用しないセッション状態において、URL からセッション ID を取り除くために使用されます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string -&gt; unit" Usage="httpContext.RewritePath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">内部リライト パス。</param>
        <summary>指定されたパスを使用して URL をリライトします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.RewritePath%28System.String%29>メソッドは、要求された URL で示される 1 つは異なるパスにリソースへの要求をリダイレクトします。 受け取るこのメソッドのオーバー ロードを使用して、サーバー リソースのクライアントからの要求が正しく解決されるように、仮想パスをリセットした場合、`rebaseClientPath`パラメーター、パラメーターを設定および`false`します。  
  
 URL リライトは、Web アプリケーションでページを再構築して、古い Url をブックマークしている人ように使用できますのページに移動した後かどうかを確認する場合に役立ちます。 URL の書き換えには、新しいページの場所への要求を透過的に転送することができます。  
  
 検索エンジン用に最適化されたよりユーザー フレンドリな Url を使用するサイトを有効にする場合は、ASP.NET ルーティングを使用するより堅牢な代替ことです。 詳細については、次を参照してください。 [ASP.NET ルーティング](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a)します。  
  
   
  
## Examples  
 次の例は、使用する方法を示します、 <xref:System.Web.HttpContext.RewritePath%2A> Web サイトのファイル構造を反映しない Url に応答する Web サイトを有効にするメソッド。 コードの最初のブロックは、RewritePath.aspx という ASP.NET Web ページです。 クエリ文字列が必要です。 かどうか、サイトの名前には、URL、WebSite1`http://localhost/WebSite1/RewritePath.aspx?page=1`ブラウザーに「ページ 1」が表示されます。 Web ページを次のコード ブロックは、 `Application_BeginRequest` Global.asax ファイル内のイベント ハンドラー。 このコードは要求をインターセプトの Url など`http://localhost/WebSite1/page1`され処理されるまで RewritePath.aspx 必要な形式に変換します。 そのため、URL `http://localhost/WebSite1/page1` 「ページ 1」をブラウザーで表示するクエリ文字列パラメーターを持つ RewritePath.aspx を呼び出します。 URL など場合、`http://localhost/WebSite1/page1`受信されるのオーバー ロード<xref:System.Web.HttpContext.RewritePath%2A>が呼び出されるの値を指定することができます、<xref:System.Web.HttpRequest.PathInfo%2A>プロパティだけでなく、クエリ文字列パラメーター。  
  
 [!code-aspx-csharp[HttpContext_RewritePath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/rewritepath.aspx#2)]
 [!code-aspx-vb[HttpContext_RewritePath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/rewritepath.aspx#2)]  
  
 [!code-csharp[HttpContext_RewritePath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/global.asax#1)]
 [!code-vb[HttpContext_RewritePath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/global.asax#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Web.HttpException"><paramref name="path" /> パラメーターが現在のアプリケーションのルート ディレクトリ内にありません。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET ルーティング</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">チュートリアル: ASP.NET Web フォーム アプリケーションでのルーティングを使用してください。</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path, bool rebaseClientPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path, bool rebaseClientPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String, rebaseClientPath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path, bool rebaseClientPath);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * bool -&gt; unit" Usage="httpContext.RewritePath (path, rebaseClientPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="rebaseClientPath" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">内部リライト パス。</param>
        <param name="rebaseClientPath">仮想パスをリセットする場合は <see langword="true" />。仮想パスを変更しない場合は <see langword="false" />。</param>
        <summary>指定したパスおよびサーバー リソースの仮想パスが変更されるかどうかを指定するブール値を使用して、URL をリライトします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.RewritePath%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType>メソッドを呼び出して、<xref:System.Web.HttpContext.RewritePath%28System.String%29?displayProperty=nameWithType>メソッドを`rebaseClientPath`パラメーターに設定`true`します。 リソースへのパスを構築するために使用される仮想パスが変更されていないようにするには、設定、`rebaseClientPath`パラメーター`false`します。 設定する一般的なシナリオ`rebaseClientPath`に`false`URL を書き換える必要があり、テーマを使用して、要求されたリソースよりも、別のフォルダーにあるリソースへの URL をリダイレクトする場合します。  
  
 URL リライトは、Web アプリケーションでページを再構築して、古い Url をブックマークしている人ように使用できますのページに移動した後かどうかを確認する場合に役立ちます。 URL の書き換えには、新しいページの場所への要求を透過的に転送することができます。  
  
 検索エンジン用に最適化されたよりユーザー フレンドリな Url を使用するサイトを有効にする場合は、ASP.NET ルーティングを使用するより堅牢な代替ことです。 詳細については、次を参照してください。 [ASP.NET ルーティング](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a)します。  
  
   
  
## Examples  
 コード例では、次を参照してください。、<xref:System.Web.HttpContext.RewritePath%28System.String%29>メソッドのオーバー ロードします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Web.HttpException"><paramref name="path" /> パラメーターが現在のアプリケーションのルート ディレクトリ内にありません。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET ルーティング</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">チュートリアル: ASP.NET Web フォーム アプリケーションでのルーティングを使用してください。</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * string * string -&gt; unit" Usage="httpContext.RewritePath (filePath, pathInfo, queryString)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="pathInfo" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filePath">内部リライト パス。</param>
        <param name="pathInfo">リソースの追加パス情報。 詳細については、「<see cref="P:System.Web.HttpRequest.PathInfo" />」を参照してください。</param>
        <param name="queryString">要求クエリ文字列。</param>
        <summary>指定されたパス、パス情報、およびクエリ文字列情報を使用して、URL をリライトします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.RewritePath%2A>メソッドは、URL を変更することがなく別のリソースにリソースへの要求をリダイレクトします。  
  
 `filePath`パラメーターは含まれません、`pathInfo`パラメーター コンテンツ。 URL のhttp://www.microsoft.com/virdir/page.html/tail、`filePath`パラメーターがhttp://www.microsoft.com/virdir/page.html、および`pathInfo`パラメーターは、末尾。  
  
 URL リライトは、Web アプリケーションでページを再構築して、古い Url をブックマークしている人ように使用できますのページに移動した後かどうかを確認する場合に役立ちます。 URL の書き換えには、新しいページの場所への要求を透過的に転送することができます。  
  
 検索エンジン用に最適化されたよりユーザー フレンドリな Url を使用するサイトを有効にする場合は、ASP.NET ルーティングを使用するより堅牢な代替ことです。 詳細については、次を参照してください。 [ASP.NET ルーティング](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a)します。  
  
   
  
## Examples  
 このメソッドのオーバー ロードの例を含む、コード例については、次を参照してください。、<xref:System.Web.HttpContext.RewritePath%28System.String%29>メソッドのオーバー ロードします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> パラメーターが現在のアプリケーションのルート ディレクトリ内にありません。</exception>
        <exception cref="T:System.Web.HttpException"><paramref name="filePath" /> パラメーターが現在のアプリケーションのルート ディレクトリ内にありません。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET ルーティング</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">チュートリアル: ASP.NET Web フォーム アプリケーションでのルーティングを使用してください。</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString, bool setClientFilePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString, bool setClientFilePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String, setClientFilePath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString, bool setClientFilePath);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * string * string * bool -&gt; unit" Usage="httpContext.RewritePath (filePath, pathInfo, queryString, setClientFilePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="pathInfo" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
        <Parameter Name="setClientFilePath" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filePath">要求を処理するリソースへの仮想パス。</param>
        <param name="pathInfo">URL リダイレクトで使用する追加のパス情報。 詳細については、「<see cref="P:System.Web.HttpRequest.PathInfo" />」を参照してください。</param>
        <param name="queryString">URL リダイレクトで使用する要求クエリ文字列。</param>
        <param name="setClientFilePath">クライアント リソースで使用されるファイル パスを <paramref name="filePath" /> パラメーターの値に設定する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定した仮想パス、パス情報、クエリ文字列、およびクライアント ファイル パスをリライト パスに設定するかどうかを指定するブール値を使用して、URL をリライトします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `filePath`パラメーターの内容を含まない、`pathInfo`パラメーター。 URL のhttp://www.microsoft.com/virdir/page.html/tail、`filePath`パラメーターがhttp://www.microsoft.com/virdir/page.html、および`pathInfo`パラメーターは、末尾。  
  
 リソースへのパスを構築するために使用される仮想パスが変更されていないようにするには、設定、`setClientFilePath`パラメーター`false`します。 設定する一般的なシナリオ`setClientFilePath`に`false`URL を書き換える必要があり、テーマを使用して、要求されたリソースよりも、別のフォルダーにあるリソースへの URL をリダイレクトする場合します。  
  
 URL リライトは、Web アプリケーションでページを再構築して、古い Url をブックマークしている人ように使用できますのページに移動した後かどうかを確認する場合に役立ちます。 URL の書き換えには、新しいページの場所への要求を透過的に転送することができます。  
  
 検索エンジン用に最適化されたよりユーザー フレンドリな Url を使用するサイトを有効にする場合は、ASP.NET ルーティングを使用するより堅牢な代替ことです。 詳細については、次を参照してください。 [ASP.NET ルーティング](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a)します。  
  
   
  
## Examples  
 コード例では、次を参照してください。、<xref:System.Web.HttpContext.RewritePath%28System.String%29>メソッドのオーバー ロードします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> パラメーターが現在のアプリケーションのルート ディレクトリ内にありません。</exception>
        <exception cref="T:System.Web.HttpException"><paramref name="filePath" /> パラメーターが現在のアプリケーションのルート ディレクトリ内にありません。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET ルーティング</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">チュートリアル: ASP.NET Web フォーム アプリケーションでのルーティングを使用してください。</related>
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Web.HttpServerUtility Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpServerUtility Server" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Server" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Server As HttpServerUtility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpServerUtility ^ Server { System::Web::HttpServerUtility ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Server : System.Web.HttpServerUtility" Usage="System.Web.HttpContext.Server" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpServerUtility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web 要求の処理で使用されるメソッドを提供する <see cref="T:System.Web.HttpServerUtility" /> オブジェクトを取得します。</summary>
        <value>現在の HTTP 要求に対する <see cref="T:System.Web.HttpServerUtility" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.Server%2A>プロパティのメソッドとプロパティにプログラムでアクセスを提供する、<xref:System.Web.HttpServerUtility>クラス。 ASP.NET ページには、既定値への参照が含まれているため、<xref:System.Web>名前空間 (が含まれています、<xref:System.Web.HttpContext>クラス) のメンバーを参照する<xref:System.Web.HttpContext>.aspx ページへの参照を完全修飾クラスを使用せずに<xref:System.Web.HttpContext>します。 たとえば、使用することができます`Server.CreateObject("MyCOMComponent")`サーバー上の COM オブジェクトのインスタンスを作成します。 ただしのメンバーを使用する場合<xref:System.Web.HttpServerUtility>ASP.NET 分離コード モジュールからへの参照を含める必要があります、<xref:System.Web>モジュールで現在アクティブな要求/応答コンテキストへの参照を完全修飾名前空間およびクラスの<xref:System.Web>を使用します。 たとえば、分離コード ページにする必要があります名を指定する、完全修飾`HttpContext.Current.Server.CreateObject("MyCOMComponent")`します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public System.Web.SessionState.HttpSessionState Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.SessionState.HttpSessionState Session" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Session" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Session As HttpSessionState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::SessionState::HttpSessionState ^ Session { System::Web::SessionState::HttpSessionState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Session : System.Web.SessionState.HttpSessionState" Usage="System.Web.HttpContext.Session" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.SessionState.HttpSessionState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求に対する <see cref="T:System.Web.SessionState.HttpSessionState" /> オブジェクトを取得します。</summary>
        <value>現在の HTTP 要求に対する <see cref="T:System.Web.SessionState.HttpSessionState" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.Session%2A>プロパティのメソッドとプロパティにプログラムでアクセスを提供する、<xref:System.Web.SessionState.HttpSessionState>クラス。  
  
 セッション状態を使用するためには、これを有効にする必要です。 セッション状態を有効にする方法については、次を参照してください。**構成セッション状態**で[ASP.NET セッション状態の概要](https://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc)します。  
  
 セッション状態の値を保存する方法については、次を参照してください。[方法。セッション状態の値を保存する](https://msdn.microsoft.com/library/a6cb2e3a-df49-4b12-9d9a-eed45541c165)します。 セッション状態から値を読み取る方法については、次を参照してください。[方法。セッション状態の値を読み取る](https://msdn.microsoft.com/library/2ef449bc-5c17-4785-b7cf-378c601af8f5)します。  
  
   
  
## Examples  
 次の例では、セッション状態の値を保存する方法とセッション状態から値を読み取る方法を示します。  
  
 これらの例には次の項目が必要です。  
  
-   有効になっているセッション状態を持つ ASP.NET アプリケーション。  
  
-   Web フォーム ページ クラスにアクセスできる、<xref:System.Web.UI.Page.Session%2A?displayProperty=nameWithType>プロパティ、または任意のクラスにアクセスできる、<xref:System.Web.HttpContext.Current%2A?displayProperty=nameWithType>プロパティ。  
  
```csharp  
string firstName = "Jeff";  
string lastName = "Smith";  
string city = "Seattle";  
  
// Save to session state in a Web Forms page class.  
Session["FirstName"] = firstName;  
Session["LastName"] = lastName;  
Session["City"] = city;  
  
// Read from session state in a Web Forms page class.  
firstName = (string)(Session["FirstName"]);  
lastName = (string)(Session["LastName"]);  
city = (string)(Session["City"]);  
  
// Outside of Web Forms page class, use HttpContext.Current.  
HttpContext context = HttpContext.Current;  
context.Session["FirstName"] = firstName;  
firstName = (string)(context.Session["FirstName"]);  
  
```  
  
```vb  
Dim firstName As String = "Jeff"  
Dim lastName As String = "Smith"  
Dim city As String = "Seattle"  
  
' Save to session state in a Web Forms page class.  
Session("FirstName") = firstName  
Session("LastName") = lastName  
Session("City") = city  
  
' Read from session state in a Web Forms page class.  
firstName = DirectCast(Session("FirstName"), String)  
lastName = DirectCast(Session("LastName"), String)  
city = DirectCast(Session("City"), String)  
  
' Outside of Web Forms page class, use HttpContext.Current.  
Dim context As HttpContext = HttpContext.Current  
context.Session("FirstName") = firstName  
firstName = DirectCast(context.Session("FirstName"), String)  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSessionStateBehavior">
      <MemberSignature Language="C#" Value="public void SetSessionStateBehavior (System.Web.SessionState.SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSessionStateBehavior(valuetype System.Web.SessionState.SessionStateBehavior sessionStateBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSessionStateBehavior(System::Web::SessionState::SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="F#" Value="member this.SetSessionStateBehavior : System.Web.SessionState.SessionStateBehavior -&gt; unit" Usage="httpContext.SetSessionStateBehavior sessionStateBehavior" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionStateBehavior" Type="System.Web.SessionState.SessionStateBehavior" />
      </Parameters>
      <Docs>
        <param name="sessionStateBehavior">必要なセッション状態の動作の種類を指定する列挙値の 1 つ。</param>
        <summary>HTTP 要求をサポートするために必要なセッション状態の動作の種類を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要求の HTTP ハンドラーが実装することでセッション状態が必要とするかどうかを示す ASP.NET の既定の実装で、<xref:System.Web.SessionState.IRequiresSessionState>インターフェイスまたは<xref:System.Web.SessionState.IReadOnlySessionState>インターフェイス。 <xref:System.Web.HttpContext.SetSessionStateBehavior%2A>メソッドと<xref:System.Web.SessionState.SessionStateBehavior>列挙型を使用して、要求を処理するために必要なセッション状態のサポートの種類の詳細を提供できます。 詳細については、<xref:System.Web.SessionState.SessionStateBehavior> 列挙型のページをご覧ください。  
  
 <xref:System.Web.HttpContext.SetSessionStateBehavior%2A>メソッドは、前に呼び出す必要があります、<xref:System.Web.HttpApplication.AcquireRequestState>パイプライン イベント。 呼び出し中に、またはこのイベントの後に発生すると、<xref:System.InvalidOperationException>例外。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メソッドは、<see cref="E:System.Web.HttpApplication.AcquireRequestState" /> イベントの発生後に呼び出されました。</exception>
        <altmember cref="T:System.Web.SessionState.SessionStateBehavior" />
      </Docs>
    </Member>
    <Member MemberName="SkipAuthorization">
      <MemberSignature Language="C#" Value="public bool SkipAuthorization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipAuthorization" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.SkipAuthorization" />
      <MemberSignature Language="VB.NET" Value="Public Property SkipAuthorization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SkipAuthorization { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SkipAuthorization : bool with get, set" Usage="System.Web.HttpContext.SkipAuthorization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.Security.UrlAuthorizationModule" /> オブジェクトが現在の要求に対する承認チェックをスキップするかどうかを指定する値を取得または設定します。</summary>
        <value><see cref="T:System.Web.Security.UrlAuthorizationModule" /> が承認チェックをスキップする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.SkipAuthorization%2A>匿名接続を許可するページにリダイレクトする必要がある認証モジュールで高度な用途のプロパティが対象としています。 両方の設定フォーム認証モジュールと Passport 認証モジュール<xref:System.Web.HttpContext.SkipAuthorization%2A>構成済みのログオン ページにリダイレクトしたときにします。 設定<xref:System.Web.HttpContext.SkipAuthorization%2A>が必要です、`ControlPrincipal`フラグを設定します。 については、`ControlPrincipal`フラグは、「<xref:System.Security.Permissions.SecurityPermissionFlag>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IServiceProvider.GetService">
      <MemberSignature Language="C#" Value="object IServiceProvider.GetService (Type service);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IServiceProvider.GetService(class System.Type service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.System#IServiceProvider#GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function GetService (service As Type) As Object Implements IServiceProvider.GetService" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IServiceProvider.GetService(Type ^ service) = IServiceProvider::GetService;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IServiceProvider.GetService(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="service"><see cref="T:System.Web.HttpContext" /> サービスの型。サービス プロバイダーをこの型に設定します。</param>
        <summary>現在のサービス型のオブジェクトを返します。</summary>
        <returns><see cref="T:System.Web.HttpContext" />。サービスが見つからない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、基になるにアクセスする便利な<xref:System.Web.HttpWorkerRequest>オブジェクト。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThreadAbortOnTimeout">
      <MemberSignature Language="C#" Value="public bool ThreadAbortOnTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ThreadAbortOnTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ThreadAbortOnTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ThreadAbortOnTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ThreadAbortOnTimeout { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ThreadAbortOnTimeout : bool with get, set" Usage="System.Web.HttpContext.ThreadAbortOnTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求がタイムアウトしたときにこの要求に対処していたスレッド上で ASP.NET ランタイムが <see cref="M:System.Threading.Thread.Abort" /> を呼び出す必要があるかどうかを指定する値を取得または設定します。</summary>
        <value>スレッドのタイムアウト時に <see cref="M:System.Threading.Thread.Abort" /> が呼び出される場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ハンドラーとモジュールを使用しているので、<xref:System.Web.HttpRequest.TimedOutToken%2A?displayProperty=nameWithType>協調のキャンセルを実装するプロパティを無効にすることがあります、 <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> ASP.NET は要求がタイムアウトしたときに既定で実行する動作です。このプロパティを設定`false`ASP.NET によって中断されずにキャンセル機能とクリーンアップ ルーチンを実行するかどうかを確認できます。  
  
 このプロパティを設定する場合`false`ASP.NET は自動的に表示されない、「要求がタイムアウトしました」エラー ページ、タイムアウトが発生した場合。 アプリケーションは、応答の内容を適切に設定します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timestamp">
      <MemberSignature Language="C#" Value="public DateTime Timestamp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Timestamp" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Timestamp" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Timestamp As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Timestamp { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.Timestamp : DateTime" Usage="System.Web.HttpContext.Timestamp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求の初期タイムスタンプを取得します。</summary>
        <value>現在の HTTP 要求のタイムスタンプ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返されるタイムスタンプ、<xref:System.Web.HttpContext.Timestamp%2A>プロパティは、サーバーのローカル時刻でありのインスタンス化中に設定されます、<xref:System.Web.HttpContext>オブジェクト。 ローカル時刻は UTC 時刻と UTC オフセットです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trace">
      <MemberSignature Language="C#" Value="public System.Web.TraceContext Trace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.TraceContext Trace" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Trace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Trace As TraceContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::TraceContext ^ Trace { System::Web::TraceContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Trace : System.Web.TraceContext" Usage="System.Web.HttpContext.Trace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.TraceContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 応答に対する <see cref="T:System.Web.TraceContext" /> オブジェクトを取得します。</summary>
        <value>現在の HTTP 応答の <see cref="T:System.Web.TraceContext" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="User">
      <MemberSignature Language="C#" Value="public System.Security.Principal.IPrincipal User { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IPrincipal User" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.User" />
      <MemberSignature Language="VB.NET" Value="Public Property User As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::IPrincipal ^ User { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.User : System.Security.Principal.IPrincipal with get, set" Usage="System.Web.HttpContext.User" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求のセキュリティ情報を取得または設定します。</summary>
        <value>現在の HTTP 要求のセキュリティ情報。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.User%2A>プロパティのメソッドとプロパティにプログラムでアクセスを提供する、<xref:System.Security.Principal.IPrincipal>インターフェイス。  
  
 ASP.NET ページには、既定値への参照が含まれているため、<xref:System.Web>名前空間 (が含まれています、<xref:System.Web.HttpContext>クラス) のメンバーを参照する<xref:System.Web.HttpContext>.aspx ページへの参照を完全修飾クラスを使用せずに<xref:System.Web.HttpContext>します。 たとえば、使用することができます`User.Identity.Name`実行するには、現在のプロセスの代わりに、ユーザーの名前を取得します。 ただしのメンバーを使用する場合<xref:System.Security.Principal.IPrincipal>ASP.NET 分離コード モジュールからへの参照を含める必要があります、<xref:System.Web>モジュールで現在アクティブな要求/応答コンテキストへの参照を完全修飾名前空間およびクラスの<xref:System.Web>を使用します。 たとえば、分離コード ページにする必要があります名を指定する、完全修飾`HttpContext.Current.User.Identity.Name`します。  
  
   
  
## Examples  
 次の例では、現在のユーザーのプロパティにアクセスする方法を示しています、<xref:System.Web.HttpContext.User%2A>プロパティ。 これらのプロパティは、Web ページのタイトルを設定に使用されます。  
  
 アプリケーションでは、Windows 認証を使用する場合、ユーザー名には、ドメインが含まれます。 たとえば、ページのタイトルは「domain \username のホーム ページ」になります。  
  
 [!code-csharp[System.Web.HttpContext.User#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext.User/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.HttpContext.User#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext.User/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="/aspnet/mvc/overview/older-versions/using-oauth-providers-with-mvc">MVC 4 で OAuth プロバイダーを使用</related>
        <related type="ExternalDocumentation" href="/aspnet/web-forms/overview/getting-started/getting-started-with-aspnet-45-web-forms/checkout-and-payment-with-paypal">ASP.NET 4.5 Web フォームの精算と PayPal による支払いの概要</related>
        <related type="ExternalDocumentation" href="/aspnet/mvc/overview/older-versions-1/nerddinner/secure-applications-using-authentication-and-authorization">NerdDinner、認証と承認を使用してセキュリティで保護されたアプリケーション</related>
      </Docs>
    </Member>
    <Member MemberName="WebSocketNegotiatedProtocol">
      <MemberSignature Language="C#" Value="public string WebSocketNegotiatedProtocol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebSocketNegotiatedProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketNegotiatedProtocol" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketNegotiatedProtocol As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WebSocketNegotiatedProtocol { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebSocketNegotiatedProtocol : string" Usage="System.Web.HttpContext.WebSocketNegotiatedProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバーからクライアントに <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 接続のために送信されたネゴシエートされたプロトコルを取得します。</summary>
        <value>ネゴシエートされたプロトコル。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WebSocketRequestedProtocols">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;string&gt; WebSocketRequestedProtocols { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;string&gt; WebSocketRequestedProtocols" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketRequestedProtocols" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketRequestedProtocols As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::String ^&gt; ^ WebSocketRequestedProtocols { System::Collections::Generic::IList&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebSocketRequestedProtocols : System.Collections.Generic.IList&lt;string&gt;" Usage="System.Web.HttpContext.WebSocketRequestedProtocols" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアントから要求されたプロトコルの順序付きリストを取得します。</summary>
        <value>要求されたプロトコル。<see cref="T:System.Web.WebSockets.AspNetWebSocket" /> の要求でないか、リストがない場合は、<see langword="null" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>