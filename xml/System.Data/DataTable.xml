<Type Name="DataTable" FullName="System.Data.DataTable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="db5d336026827d747e661a83a8c8a80d906590ba" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52598436" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DataTable : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitialize, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DataTable extends System.ComponentModel.MarshalByValueComponent implements class System.ComponentModel.IListSource, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.Runtime.Serialization.ISerializable, class System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataTable" />
  <TypeSignature Language="VB.NET" Value="Public Class DataTable&#xA;Inherits MarshalByValueComponent&#xA;Implements IListSource, ISerializable, ISupportInitialize, ISupportInitializeNotification, IXmlSerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataTable : System::ComponentModel::MarshalByValueComponent, System::ComponentModel::IListSource, System::ComponentModel::ISupportInitialize, System::ComponentModel::ISupportInitializeNotification, System::Runtime::Serialization::ISerializable, System::Xml::Serialization::IXmlSerializable" />
  <TypeSignature Language="F#" Value="type DataTable = class&#xA;    inherit MarshalByValueComponent&#xA;    interface IListSource&#xA;    interface ISupportInitializeNotification&#xA;    interface ISerializable&#xA;    interface IXmlSerializable&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.MarshalByValueComponent</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.ComponentModel.DefaultEvent("RowChanging")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.ComponentModel.DefaultProperty("TableName")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.Xml.Serialization.XmlSchemaProvider("GetDataTableSchema")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>メモリ内データの 1 つのテーブルを表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable>は ADO.NET ライブラリ内のサーバーの全体のオブジェクトです。 他のオブジェクトを使用して、<xref:System.Data.DataTable>含める、 <xref:System.Data.DataSet> 、<xref:System.Data.DataView>します。  
  
 アクセスするときに<xref:System.Data.DataTable>オブジェクトでは、条件付きで大文字小文字が区別されることに注意してください。 たとえば、1 つ<xref:System.Data.DataTable>"mydatatable"という名前し"Mydatatable"という 2 つは、1 つのテーブルの検索に使用される文字列は大文字と小文字を区別見なされます。 ただし、"mydatatable"が存在し、"Mydatatable"は、検索文字列は、大文字と小文字を区別しない見なされます。 A <xref:System.Data.DataSet> 2 つ含めることができます<xref:System.Data.DataTable>オブジェクトが同じ<xref:System.Data.DataTable.TableName%2A>プロパティの値が異なる<xref:System.Data.DataTable.Namespace%2A>プロパティの値。 操作の詳細については<xref:System.Data.DataTable>、オブジェクトを参照してください[DataTable の作成](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md)です。  
  
 作成する場合、<xref:System.Data.DataTable>プログラムでは、最初に定義してそのスキーマを追加して<xref:System.Data.DataColumn>オブジェクトを<xref:System.Data.DataColumnCollection>(を使用してアクセス、<xref:System.Data.DataTable.Columns%2A>プロパティ)。 追加の詳細については<xref:System.Data.DataColumn>、オブジェクトを参照してください[DataTable に列の追加](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-columns-to-a-datatable.md)します。  
  
 行を追加する、 <xref:System.Data.DataTable>、最初に使用する必要があります、<xref:System.Data.DataTable.NewRow%2A>を返す新しいメソッドを<xref:System.Data.DataRow>オブジェクト。 <xref:System.Data.DataTable.NewRow%2A>メソッドのスキーマとの行を返します、<xref:System.Data.DataTable>によって、テーブルの定義は、<xref:System.Data.DataColumnCollection>します。 最大数の行を<xref:System.Data.DataTable>できますストアが 16,777, 216 します。 詳細については、次を参照してください。 [DataTable にデータを追加する](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-data-to-a-datatable.md)します。  
  
 <xref:System.Data.DataTable>のコレクションを格納も<xref:System.Data.Constraint>オブジェクト データの整合性を確保するために使用できます。 詳細については、次を参照してください。 [DataTable の制約](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md)します。  
  
 たくさん<xref:System.Data.DataTable>テーブルに変更があったときを判断するために使用できるイベント。 これには、<xref:System.Data.DataTable.RowChanged>、<xref:System.Data.DataTable.RowChanging>、<xref:System.Data.DataTable.RowDeleting>、および <xref:System.Data.DataTable.RowDeleted> が含まれます。 使用できるイベントの詳細については、<xref:System.Data.DataTable>を参照してください[DataTable イベントの処理](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)します。  
  
 インスタンス<xref:System.Data.DataTable>作成されると、いくつか読み取り/書き込みのプロパティは、初期値に設定されます。 これらの値の一覧は、次を参照してください。、<xref:System.Data.DataTable.%23ctor%2A?displayProperty=nameWithType>コンス トラクターのトピックです。  
  
> [!NOTE]
>  <xref:System.Data.DataSet>と<xref:System.Data.DataTable>オブジェクトから継承<xref:System.ComponentModel.MarshalByValueComponent>、およびサポート、 <xref:System.Runtime.Serialization.ISerializable> .NET Framework リモート処理用のインターフェイス。 これらは、.NET Framework リモート処理用に使用できる唯一の ADO.NET オブジェクトです。  
  
   
  
## Examples  
 次の例では、2 つ作成されます<xref:System.Data.DataTable>オブジェクトと 1 つ<xref:System.Data.DataRelation>オブジェクト、および新しいオブジェクトを追加します、<xref:System.Data.DataSet>します。 テーブルが表示されます、<xref:System.Windows.Forms.DataGridView>コントロール。  
  
 [!code-csharp[Classic WebData DataTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable Example/VB/source.vb#1)]  
  
 このサンプルでは、特定のスキーマ定義を含む DataTable を手動で作成する方法を示します。  
  
-   複数のデータ テーブルを作成し、最初の列を定義します。  
  
-   テーブルの制約を作成します。  
  
-   値を挿入し、テーブルを表示します。  
  
-   式列を作成し、テーブルを表示します。  
  
 このコード サンプルの c# および Visual Basic プロジェクトで確認できます[開発者コード サンプル](https://code.msdn.microsoft.com/How-to-create-DataTable-7abb4914)します。  
  
 [!code-csharp[Classic WebData DataTable Example2#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/classic webdata datatable example2/cs/source.cs#1)]
 [!code-vb[Classic WebData DataTable Example2#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/classic webdata datatable example2/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>この型は、マルチ スレッドの読み取り操作も安全です。 書き込み操作を同期する必要があります。</threadsafe>
    <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataTable" /> クラスの新しいインスタンスを初期化します。</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>引数を指定せずに、<see cref="T:System.Data.DataTable" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コンス トラクターのすべてのプロパティの初期値の設定、<xref:System.Data.DataTable>オブジェクト。 次の表は、プロパティとその既定値を示します。 インスタンス<xref:System.Data.DataTable>作成は、次読み取り/書き込みプロパティの初期値に設定されます。  
  
|プロパティ|既定値|  
|--------------|-------------------|  
|**CaseSensitive**|親と同じ<xref:System.Data.DataSet>いずれかに属する場合。 それ以外の場合は `false`。|  
|**DisplayExpression**|空の文字列 ("")|  
|**ロケール**|親と同じ<xref:System.Data.DataSet>オブジェクトの<xref:System.Globalization.CultureInfo>(によって返される、<xref:System.Data.DataSet.Locale%2A>プロパティ)。 親が存在しない場合、既定では、現在のシステム<xref:System.Globalization.CultureInfo>します。|  
|**MinimumCapacity**|50 行までです。|  
  
 これらのプロパティを個別に呼び出して、プロパティをいずれかの値を変更することができます。  
  
   
  
## Examples  
 次の例では、作成、新しい<xref:System.Data.DataTable>で<xref:System.Data.DataColumn>と<xref:System.Data.DataRow>で表示、<xref:System.Windows.Forms.DataGridView>コントロール。  
  
 [!code-csharp[Classic WebData DataTable.DataTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable (string tableName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tableName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tableName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable(System::String ^ tableName);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTable : string -&gt; System.Data.DataTable" Usage="new System.Data.DataTable tableName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tableName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tableName">テーブルに付ける名前。 <paramref name="tableName" /> が <see langword="null" /> または空の文字列の場合は、<see cref="T:System.Data.DataTableCollection" /> に追加したときに既定の名前が付けられます。</param>
        <summary>指定したテーブル名を使用して <see cref="T:System.Data.DataTable" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、作成、<xref:System.Data.DataTable>で表示、<xref:System.Windows.Forms.DataGridView>コントロール。  
  
 [!code-csharp[Classic WebData DataTable.DataTable1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataTable1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataTable (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataTable(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTable : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Data.DataTable" Usage="new System.Data.DataTable (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">オブジェクトのシリアル化または逆シリアル化に必要なデータ。</param>
        <param name="context">指定したシリアル化ストリームの転送元と転送先。</param>
        <summary>
          <see cref="T:System.Data.DataTable" /> と <see cref="T:System.Runtime.Serialization.SerializationInfo" /> を使用して、<see cref="T:System.Runtime.Serialization.StreamingContext" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この実装の<xref:System.Data.DataTable>コンス トラクターが必要です。<xref:System.Runtime.Serialization.ISerializable>します。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable (string tableName, string tableNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tableName, string tableNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tableName As String, tableNamespace As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable(System::String ^ tableName, System::String ^ tableNamespace);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTable : string * string -&gt; System.Data.DataTable" Usage="new System.Data.DataTable (tableName, tableNamespace)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tableName" Type="System.String" />
        <Parameter Name="tableNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tableName">テーブルに付ける名前。 <paramref name="tableName" /> が <see langword="null" /> または空の文字列の場合は、<see cref="T:System.Data.DataTableCollection" /> に追加したときに既定の名前が付けられます。</param>
        <param name="tableNamespace">
          <see langword="DataTable" /> に格納されているデータの XML 表現の名前空間。</param>
        <summary>指定したテーブル名と名前空間を使用して、<see cref="T:System.Data.DataTable" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="AcceptChanges">
      <MemberSignature Language="C#" Value="public void AcceptChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.AcceptChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptChanges();" />
      <MemberSignature Language="F#" Value="member this.AcceptChanges : unit -&gt; unit" Usage="dataTable.AcceptChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>前回 <see cref="M:System.Data.DataTable.AcceptChanges" /> を呼び出した以降にこのテーブルに対して行われたすべての変更をコミットします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに<xref:System.Data.DataTable.AcceptChanges%2A>が呼び出されると、いずれかの<xref:System.Data.DataRow>まだ編集モードでのオブジェクトは、その編集を正常に終了します。 <xref:System.Data.DataRowState>も変更されます: すべて`Added`と`Modified`になる行`Unchanged`、および`Deleted`行が削除されます。  
  
 <xref:System.Data.DataTable.AcceptChanges%2A>でメソッドが呼び出さ一般に、<xref:System.Data.DataTable>更新を試行した後、<xref:System.Data.DataSet>を使用して、<xref:System.Data.Common.DbDataAdapter.Update%2A?displayProperty=nameWithType>メソッド。  
  
   
  
## Examples  
 次の例では、各テーブルにエラーをテストします。 (に渡すことによって、未定義の関数)、テーブルのエラーを調整できる場合<xref:System.Data.DataTable.AcceptChanges%2A>。 それ以外は<xref:System.Data.DataTable.RejectChanges%2A>が呼び出されます。  
  
 [!code-csharp[Classic WebData DataTable.AcceptChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.AcceptChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.AcceptChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.AcceptChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="dataTable.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>フォームまたは別のコンポーネントで使用する <see cref="T:System.Data.DataTable" /> の初期化を開始します。 初期化は実行時に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visual Studio .NET のデザイン環境では、このメソッドを使用して、フォームまたはその他のコンポーネントで使用するコンポーネントの初期化を開始します。 <xref:System.Data.DataTable.EndInit%2A>メソッドは、初期化を終了します。 使用して、<xref:System.Data.DataTable.BeginInit%2A>と<xref:System.Data.DataTable.EndInit%2A>メソッドにより、コントロールは完全に初期化される前に使用されているからです。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="BeginLoadData">
      <MemberSignature Language="C#" Value="public void BeginLoadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginLoadData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.BeginLoadData" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginLoadData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginLoadData();" />
      <MemberSignature Language="F#" Value="member this.BeginLoadData : unit -&gt; unit" Usage="dataTable.BeginLoadData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>データを読み込む間、通知、インデックスの維持、および制約をオフにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.BeginLoadData%2A>と共に<xref:System.Data.DataTable.LoadDataRow%2A>と<xref:System.Data.DataTable.EndLoadData%2A>します。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="CaseSensitive">
      <MemberSignature Language="C#" Value="public bool CaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.CaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property CaseSensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CaseSensitive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CaseSensitive : bool with get, set" Usage="System.Data.DataTable.CaseSensitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableCaseSensitiveDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>テーブル内の文字列比較で大文字と小文字を区別するかどうかを示します。</summary>
        <value>比較で大文字と小文字を区別する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は親 <see cref="T:System.Data.DataSet" /> オブジェクトの <see cref="P:System.Data.DataSet.CaseSensitive" /> プロパティに設定します。<see cref="T:System.Data.DataTable" /> とは独立して <see cref="T:System.Data.DataSet" /> を作成した場合は <see langword="false" /> に設定します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.CaseSensitive%2A>プロパティで並べ替え、検索、およびフィルター処理文字列の比較に影響を与えます。  
  
   
  
## Examples  
 次の例では、<xref:System.Data.DataTable.Select%2A>メソッドに 2 回、<xref:System.Data.DataTable>します。 最初に、<xref:System.Data.DataTable.CaseSensitive%2A>プロパティに設定されて`false`、2 番目、 `true`。  
  
 [!code-csharp[Classic WebData DataTable.CaseSensitive Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.CaseSensitive Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.CaseSensitive Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.CaseSensitive Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.Select" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="ChildRelations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection ChildRelations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection ChildRelations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ChildRelations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChildRelations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ ChildRelations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ChildRelations : System.Data.DataRelationCollection" Usage="System.Data.DataTable.ChildRelations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableChildRelationsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.Data.DataTable" /> の子リレーションシップのコレクションを取得します。</summary>
        <value>テーブルの子リレーションを格納している <see cref="T:System.Data.DataRelationCollection" />。 <see cref="T:System.Data.DataRelation" /> オブジェクトが存在しない場合、空のコレクションが返されます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Data.DataRelation> 2 つのテーブル間のリレーションシップを定義します。 通常、2 つのテーブルは、同じデータを含む単一のフィールドでリンクされています。 たとえば、アドレス データを格納するテーブルには、国/地域を表すコードを含む 1 つのフィールドがあります。 国/地域のデータが含まれる 2 番目のテーブルには、国/地域を識別するコードを含む 1 つのフィールドを持つあり、このコードは、最初のテーブルの対応するフィールドに挿入します。 A <xref:System.Data.DataRelation>、次に、少なくとも 4 つ情報にはが含まれています。 (1) 最初のテーブルの名前、(2) の最初のテーブル内の列名、(3) 2 つ目のテーブルの名前および (4) 2 番目のテーブル内の列名。  
  
   
  
## Examples  
 次の例では、<xref:System.Data.DataTable.ChildRelations%2A>プロパティをそれぞれの子を返す<xref:System.Data.DataRelation>で、<xref:System.Data.DataTable>します。 各リレーションシップは、引数として使用し、<xref:System.Data.DataRow.GetChildRows%2A>のメソッド、<xref:System.Data.DataRow>行の配列を返します。 行の各列の値が出力されます。  
  
 [!code-csharp[Classic WebData DataTable.ChildRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ChildRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ChildRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ChildRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.ParentRelations" />
        <altmember cref="M:System.Data.DataRow.GetParentRows(System.String)" />
        <altmember cref="M:System.Data.DataRow.GetChildRows(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="dataTable.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Data.DataTable" /> からすべてのデータを消去します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 すべてのテーブルのすべての行が削除されます。 表に、子行が孤立するを原因となる任意の強制子リレーションシップがある場合、例外が生成されます。  
  
 場合、<xref:System.Data.DataSet>にバインドされて、<xref:System.Xml.XmlDataDocument>を呼び出すと、<xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType>または<xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType>発生させる、<xref:System.NotSupportedException>します。 このような状況を避けるためには、各テーブルは、一度に 1 行ずつを削除するを走査します。 使用すると<xref:System.Data.DataTable.NewRow%2A>を呼び出す前に新しい行を作成する、行を処理する必要があります<xref:System.Data.DataTable.Clear%2A>します。  
  
   
  
## Examples  
 次の例では、すべてのデータのテーブルをクリアします。  
  
 [!code-csharp[Classic WebData DataTable.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable イベントの処理</related>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Data.DataTable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataTable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Data::DataTable ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; System.Data.DataTable&#xA;override this.Clone : unit -&gt; System.Data.DataTable" Usage="dataTable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>すべての <see cref="T:System.Data.DataTable" /> スキーマおよび制約を含め <see cref="T:System.Data.DataTable" /> の構造体のクローンを作成します。</summary>
        <returns>現在の <see cref="T:System.Data.DataTable" /> と同じスキーマを持つ新しい <see cref="T:System.Data.DataTable" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これらのクラスが派生されている場合、複製同じ派生クラスはでも。  
  
 新しい複製を作成<xref:System.Data.DataTable>元と同じ構造で<xref:System.Data.DataTable>、任意のデータはコピーされませんが、(新しい<xref:System.Data.DataTable>は含められません`DataRows`)。 新しい構造とデータの両方をコピーする<xref:System.Data.DataTable>を使用して、<xref:System.Data.DataTable.Copy%2A>します。  
  
   
  
## Examples  
 次の例では、DataTable.Clone を実行した後、構造体とレプリケーション先テーブルの制約を更新する方法を示します。 ClonedDataTable クラスでは、変換先テーブルを返すし、すべての更新イベントが含まれています。 クローン後のソース テーブルの構造の変更は、変換先テーブルに反映されません。 具体的には、このサンプルには。  
  
-   ソース テーブル内の列の変更を更新します。  
  
-   ソース テーブルの一意の制約の変更を更新します。  
  
-   ソース テーブルの外部キーの変更を更新します。  
  
 このコード サンプルの c# および Visual Basic プロジェクトで確認できます[開発者コード サンプル](https://code.msdn.microsoft.com/site/search?f%5B0%5D.Type=SearchText&f%5B0%5D.Value=How%20to%20automically%20update%20the%20structure%20of%20a%20cloned%20DataTable)します。  
  
```csharp  
using System;  
using System.Linq;  
using System.Data;  
using System.ComponentModel;  
  
class Program {  
   static void Main(string[] args) {  
      DataTable courses = NewCourseDataTable();  
      Console.WriteLine("This is the source table:");  
      WriteDataTable(courses);  
  
      ClonedDataTable clonedResult = new ClonedDataTable(courses);  
      DataTable clonedCourses = clonedResult.DestinationTable;  
      Console.WriteLine("This is the destination table:");  
      WriteDataTable(clonedCourses);  
  
      // Add the events of updating column collection into the source table.  
      clonedResult.UpdateAddedColumn();  
      clonedResult.UpdateDeletedColumn();  
      // Add a DataColumn in source table.  
      DataColumn columnCreidts = new DataColumn("Credits", typeof(Int32));  
      courses.Columns.Add(columnCreidts);  
      Console.WriteLine("After add a column in source table, it's the result in the destination:");  
      WriteDataTable(clonedCourses);  
  
      // Add the event of updating UniqueConstraint into the source table.  
      clonedResult.UpdateUniqueConstraint();  
  
      // Add the unique constraint in source table.  
      UniqueConstraint uniqueConstraint = new UniqueConstraint(courses.Columns["CourseId"]);  
      courses.Constraints.Add(uniqueConstraint);  
  
      Console.WriteLine(@"If we add the unique constraint in source table and then insert the duplicate   
rows into the destination table, we will get the following error:");  
      InsertDuplicateData(clonedCourses);  
      Console.WriteLine();  
  
      // Add the event of updating ForeignKeyConstraint into the source table.  
      clonedResult.UpdateForeignKeyConstraint();  
  
      // Add the ForeignKeyConstraint into the source table.  
      DataTable deparments = NewDeparmentDataTable();  
      DataSet dataset = new DataSet();  
  
      dataset.Tables.Add(courses);  
      dataset.Tables.Add(clonedCourses);  
      dataset.Tables.Add(deparments);  
  
      ForeignKeyConstraint foreignKey = new ForeignKeyConstraint(deparments.Columns["DepartmentId"], courses.Columns["DepartmentId"]);  
      courses.Constraints.Add(foreignKey);  
  
      Console.WriteLine(@"If we add the foreign key constraint in source table and then insert a row   
without the parent  into the destination table, we will get the following error:");  
      InsertNoParentRow(clonedCourses);  
      Console.WriteLine();  
  
      Console.WriteLine("Please press any key to exit...");  
      Console.ReadKey();  
   }  
  
   static private DataTable NewCourseDataTable() {  
      DataTable newTable = new DataTable();  
  
      DataColumn[] columns ={   
                                      new DataColumn("CourseId", typeof(String)),  
                                      new DataColumn("CourseName",typeof(String)),                                        
                                      new DataColumn("DepartmentId", typeof(Int32))  
                                  };  
  
      newTable.Columns.AddRange(columns);  
  
      newTable.Rows.Add("C1045", "Calculus", 7);  
      newTable.Rows.Add("C1061", "Physics", 1);  
      newTable.Rows.Add("C2021", "Composition", 2);  
      newTable.Rows.Add("C2042", "Literature", 2);  
  
      return newTable;  
   }  
  
   static private DataTable NewDeparmentDataTable() {  
      DataTable newTable = new DataTable();  
  
      DataColumn[] columns ={   
                                      new DataColumn("DepartmentId", typeof(Int32)),  
                                      new DataColumn("Name",typeof(String)),  
                                  };  
  
      newTable.Columns.AddRange(columns);  
  
      newTable.Rows.Add(1, "Engineering");  
      newTable.Rows.Add(2, "English");  
      newTable.Rows.Add(4, "Economics");  
      newTable.Rows.Add(7, "Mathematics");  
  
      return newTable;  
   }  
  
   static private void WriteDataTable(DataTable table) {  
      if (table == null)  
         return;  
  
      foreach (DataColumn column in table.Columns) {  
         Console.Write("{0,-15}", column.ColumnName);  
      }  
      Console.WriteLine();  
  
      foreach (DataRow row in table.Rows) {  
         for (int i = 0; i < table.Columns.Count; i++)  
            Console.Write("{0,-15}", row[i].ToString());  
         Console.WriteLine();  
      }  
  
      Console.WriteLine();  
   }  
  
   static private void InsertDuplicateData(DataTable table) {  
      try {  
         table.Rows.Add("C1045", "Calculus", 7);  
         table.Rows.Add("C1045", "Calculus", 7);  
      } catch (Exception e) {  
         Console.WriteLine("\"" + e.Message + "\"");  
      }  
   }  
  
   private static void InsertNoParentRow(DataTable table) {  
      try {  
         table.Rows.Add("C1061", "Physics", 11);  
      } catch (Exception e) {  
         Console.WriteLine("\"" + e.Message + "\"");  
      }  
   }  
}  
  
public class ClonedDataTable {  
   private DataTable sourceTable;  
   private DataTable destinationTable;  
  
   public ClonedDataTable(DataTable source) {  
      sourceTable = source;  
      // set the cloned result  
      destinationTable = sourceTable.Clone();  
   }  
  
   public void UpdateAddedColumn() {  
      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnAdded);  
   }  
  
   public void UpdateDeletedColumn() {  
      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnDeleted);  
   }  
  
   public void UpdateUniqueConstraint() {  
      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(UniqueConstraint_Changed);  
   }  
  
   public void UpdateForeignKeyConstraint() {  
      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(ForeignKeyConstraint_Changed);  
   }  
  
   // After the source table adds a column, the method will add the same column in the destination table.  
   void ColumnAdded(object sender, System.ComponentModel.CollectionChangeEventArgs e) {  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn column = e.Element as DataColumn;  
  
         if (column != null) {  
            DataColumn newColumn = new DataColumn(column.ColumnName, column.DataType, column.Expression, column.ColumnMapping);  
  
            if (!destinationTable.Columns.Contains(newColumn.ColumnName))  
               destinationTable.Columns.Add(newColumn);  
         }  
      }  
   }  
  
   // After the source table deletes a column, the method will delete the same column in the destination table.  
   void ColumnDeleted(object sender, CollectionChangeEventArgs e) {  
      if (e.Action == CollectionChangeAction.Remove) {  
         DataColumn column = e.Element as DataColumn;  
  
         if (column != null)  
            if (destinationTable.Columns.Contains(column.ColumnName))  
               destinationTable.Columns.Remove(column.ColumnName);  
      }  
   }  
  
   // After the source table changes the UniqueConstraint, this method changes the same UniqueConstraint in destination table.        
   void UniqueConstraint_Changed(object sender, CollectionChangeEventArgs e) {  
      UniqueConstraint constraint = e.Element as UniqueConstraint;  
  
      if (constraint == null)  
         return;  
  
      String constraintName = constraint.ConstraintName;  
  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  
         Boolean isPrimaryKey = constraint.IsPrimaryKey;  
  
         // Get the columns used in new constraint from the destiantion table.  
         for (Int32 i = 0; i < constraint.Columns.Count(); i++) {  
            String columnName = constraint.Columns[i].ColumnName;  
  
            if (destinationTable.Columns.Contains(columnName))  
               columns[i] = destinationTable.Columns[columnName];  
            else  
               return;  
         }  
  
         UniqueConstraint newConstraint = new UniqueConstraint(constraintName, columns, isPrimaryKey);  
  
         if (!destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Add(newConstraint);  
  
      } else if (e.Action == CollectionChangeAction.Remove)  
         if (destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Remove(constraintName);  
   }  
  
   // After the source table changes the ForeignKeyConstraint, this method changes    
   // the same ForeignKeyConstraint in the destination table.  
   void ForeignKeyConstraint_Changed(object sender, CollectionChangeEventArgs e) {  
      ForeignKeyConstraint constraint = e.Element as ForeignKeyConstraint;  
  
      if (constraint == null)  
         return;  
  
      // If the source and destination are not in the same DataSet, don't change the ForeignKeyConstraint.  
      if (sourceTable.DataSet != destinationTable.DataSet)  
         return;  
  
      String constraintName = constraint.ConstraintName;  
  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  
         DataColumn[] parentColumns = constraint.RelatedColumns;  
  
         // Get the columns used in new constraint from the destination table.  
         for (int i = 0; i < constraint.Columns.Count(); i++) {  
            String columnName = constraint.Columns[i].ColumnName;  
  
            if (destinationTable.Columns.Contains(columnName))  
               columns[i] = destinationTable.Columns[columnName];  
            else  
               return;  
         }  
  
         ForeignKeyConstraint newConstraint = new ForeignKeyConstraint(constraintName, parentColumns, columns);  
         newConstraint.AcceptRejectRule = constraint.AcceptRejectRule;  
         newConstraint.DeleteRule = constraint.DeleteRule;  
         newConstraint.UpdateRule = constraint.UpdateRule;  
  
         if (!destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Add(newConstraint);  
      } else if (e.Action == CollectionChangeAction.Remove)  
         if (destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Remove(constraintName);  
   }  
  
   // return the destination table.  
   public DataTable DestinationTable {  
      get { return destinationTable; }  
   }  
}  
```  
  
 このサンプルでは、DataTable 内のデータを変更して、データ ソースを更新する方法を示します。  
  
 まず、データベースを作成します。  
  
```  
USE [master]  
GO  
  
CREATE DATABASE [MySchool]   
  
GO  
  
USE [MySchool]  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Course]([CourseID] [nvarchar](10) NOT NULL,  
[Year] [smallint] NOT NULL,  
[Title] [nvarchar](100) NOT NULL,  
[Credits] [int] NOT NULL,  
[DepartmentID] [int] NOT NULL,  
 CONSTRAINT [PK_Course] PRIMARY KEY CLUSTERED   
(  
[CourseID] ASC,  
[Year] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Department]([DepartmentID] [int] IDENTITY(1,1) NOT NULL,  
[Name] [nvarchar](50) NOT NULL,  
[Budget] [money] NOT NULL,  
[StartDate] [datetime] NOT NULL,  
[Administrator] [int] NULL,  
 CONSTRAINT [PK_Department] PRIMARY KEY CLUSTERED   
(  
[DepartmentID] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1045', 2012, N'Calculus', 4, 7)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1061', 2012, N'Physics', 4, 1)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2021', 2012, N'Composition', 3, 2)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2042', 2012, N'Literature', 4, 2)  
  
SET IDENTITY_INSERT [dbo].[Department] ON   
  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (1, N'Engineering', 350000.0000, CAST(0x0000999C00000000 AS DateTime), 2)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (2, N'English', 120000.0000, CAST(0x0000999C00000000 AS DateTime), 6)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (4, N'Economics', 200000.0000, CAST(0x0000999C00000000 AS DateTime), 4)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (7, N'Mathematics', 250024.0000, CAST(0x0000999C00000000 AS DateTime), 3)  
SET IDENTITY_INSERT [dbo].[Department] OFF  
  
ALTER TABLE [dbo].[Course]  WITH CHECK ADD  CONSTRAINT [FK_Course_Department] FOREIGN KEY([DepartmentID])  
REFERENCES [dbo].[Department] ([DepartmentID])  
GO  
ALTER TABLE [dbo].[Course] CHECK CONSTRAINT [FK_Course_Department]  
GO  
```  
  
 コンパイルして、サンプルを実行することができますようになりました。 [DataTable、およびデータ ソースの更新でのデータを変更する方法](https://code.msdn.microsoft.com/How-to-modify-data-in-c68d35f4)はこのサンプルの Visual Basic および c# のプロジェクトがあります。  
  
```csharp  
using System;  
using System.Data;  
using System.Data.SqlClient;  
  
class Program {  
   static void Main(string[] args) {  
  
   string MySchoolConnectionString = "Data Source=(local);Initial Catalog=MySchool;Integrated Security=True";  
  
      // Get Data  
      String selectString =  
       @"Select [CourseID],[Year],[Title],[Credits],[DepartmentID] From [dbo].[Course];  
               Select [DepartmentID],[Name],[Budget],[StartDate],[Administrator] From [dbo].[Department] ";  
  
      DataSet dataSet = new DataSet();  
      DataTable course = dataSet.Tables.Add("Course");  
      DataTable department = dataSet.Tables.Add("Department");  
  
      Console.WriteLine("Get data from database:");  
      GetDataTables(MySchoolConnectionString, selectString, dataSet, course, department);  
      Console.WriteLine();  
  
      // Use DataTable Edits to edit the data  
      String updateString =  
              @"Update [dbo].[Course] Set [Credits]=@Credits Where [CourseID]=@CourseID;";  
  
      course.ColumnChanged += OnColumnChanged;  
  
      // Set the Credits of first row is negative value, and set the Credits of second row is plus.  
      ChangeCredits(course, course.Rows[0], -1);  
      ChangeCredits(course, course.Rows[1], 11);  
  
      UpdateDataTables(MySchoolConnectionString, updateString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"),  
          new SqlParameter("@Credits", SqlDbType.Int, 4, "Credits"));  
      Console.WriteLine("Only the Credits of second row is changed.");  
      ShowDataTable(course);  
      Console.WriteLine();  
  
      // Delete and Remove from DataTable  
      // Create the foreign key constraint, and set the DeleteRule with Cascade.  
      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint("CourseDepartFK", department.Columns["DepartmentID"], course.Columns["DepartmentID"]);  
      courseDepartFK.DeleteRule = Rule.Cascade;  
      courseDepartFK.UpdateRule = Rule.Cascade;  
      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  
      course.Constraints.Add(courseDepartFK);  
  
      String deleteString = @"Delete From [dbo].[Course] Where [CourseID]=@CourseID;";  
  
      department.Rows[0].Delete();  
      Console.WriteLine("If One row in Department table is deleted, the related rows in Course table will also be deleted.");  
      Console.WriteLine("Department DataTable:");  
      ShowDataTable(department);  
      Console.WriteLine();  
      Console.WriteLine("Course DataTable:");  
      ShowDataTable(course);  
      Console.WriteLine();  
      // Update the delete operation  
      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"));  
      Console.WriteLine("After delete operation:");  
      Console.WriteLine("Course DataTable:");  
      ShowDataTable(course);  
      Console.WriteLine();  
  
      course.Rows.RemoveAt(0);  
      Console.WriteLine("Now we remove one row from Course:");  
      ShowDataTable(course);  
      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"));  
   }  
  
   // Use SqlDataAdapter to get data.  
   private static void GetDataTables(String connectionString, String selectString,  
       DataSet dataSet, params DataTable[] tables) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.SelectCommand = new SqlCommand(selectString);  
         adapter.SelectCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Fill(0, 0, tables);  
  
         foreach (DataTable table in dataSet.Tables) {  
            Console.WriteLine("Data in {0}:", table.TableName);  
            ShowDataTable(table);  
            Console.WriteLine();  
         }  
      }  
   }  
  
   // Use SqlDataAdapter to update the updata operation.  
   private static void UpdateDataTables(String connectionString, String updateString,  
       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.UpdateCommand = new SqlCommand(updateString);  
         adapter.UpdateCommand.Parameters.AddRange(parameters);  
         adapter.UpdateCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Update(dataSet, tableName);  
      }  
   }  
  
   // Use SqlDataAdapter to update delete operation.  
   private static void DeleteDataTables(String connectionString, String deleteString,  
       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.DeleteCommand = new SqlCommand(deleteString);  
         adapter.DeleteCommand.Parameters.AddRange(parameters);  
         adapter.DeleteCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Update(dataSet, tableName);  
      }  
   }  
  
   // Use DataTable Edits to modify the data.  
   private static void ChangeCredits(DataTable table, DataRow row, Int32 credits) {  
      row.BeginEdit();  
      Console.WriteLine("We change row {0}", table.Rows.IndexOf(row));  
      row["Credits"] = credits;  
      row.EndEdit();  
   }  
  
   // The method will be invoked when the value in DataTable is changed.  
   private static void OnColumnChanged(Object sender, DataColumnChangeEventArgs args) {  
      Int32 credits = 0;  
      // If Credits is changed and the value is negative, we'll cancel the edit.  
      if ((args.Column.ColumnName == "Credits") &&  
          (!Int32.TryParse(args.ProposedValue.ToString(), out credits) || credits < 0)) {  
         Console.WriteLine("The value of Credits is invalid. Edit canceled.");  
         args.Row.CancelEdit();  
      }  
   }  
  
   // Display the column and value of DataTable.  
   private static void ShowDataTable(DataTable table) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-14}", col.ColumnName);  
      }  
      Console.WriteLine("{0,-14}", "RowState");  
  
      foreach (DataRow row in table.Rows) {  
         if (row.RowState == DataRowState.Deleted) {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime)))  
                  Console.Write("{0,-14:d}", row[col, DataRowVersion.Original]);  
               else if (col.DataType.Equals(typeof(Decimal)))  
                  Console.Write("{0,-14:C}", row[col, DataRowVersion.Original]);  
               else  
                  Console.Write("{0,-14}", row[col, DataRowVersion.Original]);  
            }  
         }  
         else {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime)))  
                  Console.Write("{0,-14:d}", row[col]);  
               else if (col.DataType.Equals(typeof(Decimal)))  
                  Console.Write("{0,-14:C}", row[col]);  
               else  
                  Console.Write("{0,-14}", row[col]);  
            }  
         }  
         Console.WriteLine("{0,-14}", row.RowState);  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.Copy" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="ColumnChanged">
      <MemberSignature Language="C#" Value="public event System.Data.DataColumnChangeEventHandler ColumnChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataColumnChangeEventHandler ColumnChanged" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.ColumnChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ColumnChanged As DataColumnChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataColumnChangeEventHandler ^ ColumnChanged;" />
      <MemberSignature Language="F#" Value="member this.ColumnChanged : System.Data.DataColumnChangeEventHandler " Usage="member this.ColumnChanged : System.Data.DataColumnChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableColumnChangedDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataColumn" /> 内の指定した <see cref="T:System.Data.DataRow" /> の値が変更された後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 詳細については、次を参照してください。 [DataTable イベントの処理](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)します。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.ColumnChanged Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanged Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ColumnChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataColumnChangeEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="ColumnChanging">
      <MemberSignature Language="C#" Value="public event System.Data.DataColumnChangeEventHandler ColumnChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataColumnChangeEventHandler ColumnChanging" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.ColumnChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ColumnChanging As DataColumnChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataColumnChangeEventHandler ^ ColumnChanging;" />
      <MemberSignature Language="F#" Value="member this.ColumnChanging : System.Data.DataColumnChangeEventHandler " Usage="member this.ColumnChanging : System.Data.DataColumnChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableColumnChangingDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataColumn" /> 内の指定した <see cref="T:System.Data.DataRow" /> の値が変更されているときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 詳細については、次を参照してください。 [DataTable イベントの処理](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)します。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.ColumnChanging Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanging Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ColumnChanging Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanging Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="Columns">
      <MemberSignature Language="C#" Value="public System.Data.DataColumnCollection Columns { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataColumnCollection Columns" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Columns" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Columns As DataColumnCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataColumnCollection ^ Columns { System::Data::DataColumnCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Columns : System.Data.DataColumnCollection" Usage="System.Data.DataTable.Columns" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableColumnsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このテーブルに属する列のコレクションを取得します。</summary>
        <value>テーブルの <see cref="T:System.Data.DataColumnCollection" /> オブジェクトのコレクションを格納している <see cref="T:System.Data.DataColumn" />。 <see cref="T:System.Data.DataColumn" /> オブジェクトが存在しない場合、空のコレクションが返されます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataColumnCollection>各列のデータ型を定義することで、テーブルのスキーマを決定します。  
  
   
  
## Examples  
 次の例を使用してテーブル内の各行の各値を出力する、<xref:System.Data.DataTable.Columns%2A>プロパティ。  
  
 [!code-csharp[Classic WebData DataTable.Columns Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Columns Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Columns Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Columns Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="Compute">
      <MemberSignature Language="C#" Value="public object Compute (string expression, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Compute(string expression, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Compute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Compute (expression As String, filter As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Compute(System::String ^ expression, System::String ^ filter);" />
      <MemberSignature Language="F#" Value="member this.Compute : string * string -&gt; obj" Usage="dataTable.Compute (expression, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">計算する式。</param>
        <param name="filter">式で評価される行を制限するフィルター。</param>
        <summary>フィルター基準を満たしている現在の行で指定した式を計算します。</summary>
        <returns>計算の結果に設定された <see cref="T:System.Object" />。 式が null に評価された場合、戻り値は <see cref="F:System.DBNull.Value" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `expression`パラメーターには、集計関数が必要です。 たとえば、有効な式は、次のように。  
  
 `Count(Quantity)`  
  
 この式ではありません。  
  
 `Sum (Quantity * UnitPrice)`  
  
 場合は 2 つ以上の列に対して操作を実行する必要があります、作成、<xref:System.Data.DataColumn>に設定して、その<xref:System.Data.DataColumn.Expression%2A>プロパティを適切な式と、結果の列に集計式を使用します。 その場合は、指定された、<xref:System.Data.DataColumn>名前「合計」、および<xref:System.Data.DataColumn.Expression%2A>プロパティには、この設定。  
  
 `"Quantity * UnitPrice"`  
  
 式の引数、<xref:System.Data.DataTable.Compute%2A>メソッドがこれになります。  
  
 `Sum(total)`  
  
 2 番目のパラメーターでは、`filter`は、式で使用する行を決定します。 たとえば、テーブルに"colDate"という名前の日付列が含まれている場合、次の式を持つ行を制限します。  
  
 `colDate > 1/1/99 AND colDate < 17/1/99`  
  
 両方のパラメーターの式の作成にルールは、次を参照してください。、<xref:System.Data.DataColumn.Expression%2A?displayProperty=nameWithType>プロパティ。  
  
   
  
## Examples  
 次の例では、識別番号が 5 つの販売員「合計」をという名前の列の値を合計します。  
  
 [!code-csharp[Classic WebData DataTable.Compute Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Compute Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Compute Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Compute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="Constraints">
      <MemberSignature Language="C#" Value="public System.Data.ConstraintCollection Constraints { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.ConstraintCollection Constraints" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Constraints" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Constraints As ConstraintCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::ConstraintCollection ^ Constraints { System::Data::ConstraintCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Constraints : System.Data.ConstraintCollection" Usage="System.Data.DataTable.Constraints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableConstraintsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.ConstraintCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このテーブルに保持されている制約のコレクションを取得します。</summary>
        <value>テーブルの <see cref="T:System.Data.ConstraintCollection" /> オブジェクトのコレクションを格納している <see cref="T:System.Data.Constraint" />。 <see cref="T:System.Data.Constraint" /> オブジェクトが存在しない場合、空のコレクションが返されます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Data.ForeignKeyConstraint> (または複数) の列の値が削除または更新したときに実行するアクションを制限します。 このような制約が主キー列で使用するためのものです。 2 つのテーブル間の親/子リレーションシップで、親テーブルから値を削除することができます子の行に影響は次の方法のいずれかでします。  
  
-   子の行がすることもできます (カスケード アクション) を削除します。  
  
-   子の列 (または列) の値は null 値を設定できます。  
  
-   子の列 (または列) の値は、既定値に設定できます。  
  
-   例外を生成できます。  
  
 A<xref:System.Data.UniqueConstraint>と非一意の値に主キーの値を設定しようとしてアクティブになります。  
  
   
  
## Examples  
 次の例では、追加、<xref:System.Data.ForeignKeyConstraint>に制約のコレクション。  
  
 [!code-csharp[Classic WebData DataTable.Constraints Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Constraints Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Constraints Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Constraints Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Data.DataTable Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ Copy();" />
      <MemberSignature Language="F#" Value="member this.Copy : unit -&gt; System.Data.DataTable" Usage="dataTable.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この <see cref="T:System.Data.DataTable" /> の構造体だけでなくデータもコピーします。</summary>
        <returns>この <see cref="T:System.Data.DataTable" /> と同じ構造体 (テーブル スキーマおよび制約) とデータを持つ新しい <see cref="T:System.Data.DataTable" />。  
  
これらのクラスが派生されている場合は、コピーも同じ派生クラスになります。  
  
 <see cref="M:System.Data.DataTable.Copy" /> は、新しい <see cref="T:System.Data.DataTable" /> を元の <see cref="T:System.Data.DataTable" /> と同じ構造とデータで作成します。 構造体を新しい <see cref="T:System.Data.DataTable" /> にコピーし、データをコピーしない場合は、<see cref="M:System.Data.DataTable.Clone" /> を使用します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、 <xref:System.Data.DataTable.Copy%2A> 、元のコピーを作成するメソッド<xref:System.Data.DataTable>します。 親から継承されている場合、名前空間の名前は保持されません<xref:System.Data.DataTable>または<xref:System.Data.DataSet>します。  
  
 [!code-csharp[Classic WebData DataTable.Copy Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Copy Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Copy Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Copy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataView.ToTable" />
        <altmember cref="M:System.Data.DataTable.Clone" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.CreateDataReader" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader () As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader();" />
      <MemberSignature Language="F#" Value="member this.CreateDataReader : unit -&gt; System.Data.DataTableReader" Usage="dataTable.CreateDataReader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この <see cref="T:System.Data.DataTableReader" /> 内のデータに対応する <see cref="T:System.Data.DataTable" /> を返します。</summary>
        <returns>1 つの結果セットを格納した <see cref="T:System.Data.DataTableReader" />。ソース インスタンスである <see cref="T:System.Data.DataTable" /> に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <xref:System.Data.DataTable> インスタンスを作成するコンソール アプリケーションの例を次に示します。 例は、塗りつぶされた<xref:System.Data.DataTable>を呼び出すプロシージャに、<xref:System.Data.DataTable.CreateDataReader%2A>内に含まれる結果を反復処理するメソッド、<xref:System.Data.DataTableReader>します。  
  
 [!code-csharp[DataWorks DataTable.CreateDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.CreateDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.CreateDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.CreateDataReader/VB/source.vb#1)]  
  
 この例では、次の出力がコンソール ウィンドウに表示されます。  
  
 `1 Mary`  
  
 `2 Andy`  
  
 `3 Peter`  
  
 `4 Russ`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.CreateDataReader" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataTable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataTable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateInstance () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataTable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : unit -&gt; System.Data.DataTable&#xA;override this.CreateInstance : unit -&gt; System.Data.DataTable" Usage="dataTable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Data.DataTable" /> の新しいインスタンスを作成します。</summary>
        <returns>新しい式。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataSet">
      <MemberSignature Language="C#" Value="public System.Data.DataSet DataSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataSet DataSet" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DataSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataSet As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataSet ^ DataSet { System::Data::DataSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataSet : System.Data.DataSet" Usage="System.Data.DataTable.DataSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableDataSetDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このテーブルが属する <see cref="T:System.Data.DataSet" /> を取得します。</summary>
        <value>このテーブルが属する <see cref="T:System.Data.DataSet" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールがデータにバインドされて、<xref:System.Data.DataTable>が属するテーブルと、<xref:System.Data.DataSet>を取得する、<xref:System.Data.DataSet>このプロパティを使用します。  
  
   
  
## Examples  
 次の例は、親を返します<xref:System.Data.DataSet>を通じて、特定のテーブルの<xref:System.Data.DataTable.DataSet%2A>プロパティ。  
  
 [!code-csharp[Classic WebData DataTable.DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultView">
      <MemberSignature Language="C#" Value="public System.Data.DataView DefaultView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataView DefaultView" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DefaultView" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultView As DataView" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataView ^ DefaultView { System::Data::DataView ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultView : System.Data.DataView" Usage="System.Data.DataTable.DefaultView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableDefaultViewDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フィルター処理されたビューまたはカーソル位置を含むことがある、テーブルのカスタマイズされたビューを取得します。</summary>
        <value>
          <see cref="T:System.Data.DataView" /> に関連付けられている <see cref="T:System.Data.DataTable" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.DefaultView%2A>プロパティが返す、<xref:System.Data.DataView>並べ替え、フィルター、および検索に使用することができます、<xref:System.Data.DataTable>します。  
  
   
  
## Examples  
 次の例のプロパティの設定、<xref:System.Data.DataTable>オブジェクトの<xref:System.Data.DataView>を通じて、<xref:System.Data.DataTable.DefaultView%2A>プロパティ。 バインディングも示しています、<xref:System.Windows.Forms.DataGridView>への制御、 <xref:System.Data.DataTable> "CompanyName"という名前の列を含む"Suppliers"という名前。  
  
 [!code-csharp[Classic WebData DataTable.DefaultView Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DefaultView Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DefaultView Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DefaultView Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayExpression">
      <MemberSignature Language="C#" Value="public string DisplayExpression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DisplayExpression" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DisplayExpression" />
      <MemberSignature Language="VB.NET" Value="Public Property DisplayExpression As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DisplayExpression { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DisplayExpression : string with get, set" Usage="System.Data.DataTable.DisplayExpression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableDisplayExpressionDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザー インターフェイスにこのテーブルを表示するために使用する値を返す式を取得または設定します。 <see langword="DisplayExpression" /> プロパティを使用すると、ユーザー インターフェイスにこのテーブルの名前が表示されます。</summary>
        <value>表示文字列。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Data.DataColumn.Expression" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="dataTable.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>フォームまたは別のコンポーネントで使用する <see cref="T:System.Data.DataTable" /> の初期化を終了します。 初期化は実行時に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visual Studio .NET のデザイン環境では、このメソッドを使用して、フォームまたはその他のコンポーネントで使用するコンポーネントの初期化を終了します。 <xref:System.Data.DataTable.BeginInit%2A>メソッドは、初期化を開始します。 使用して、<xref:System.Data.DataTable.BeginInit%2A>と<xref:System.Data.DataTable.EndInit%2A>メソッドにより、コントロールは完全に初期化される前に使用されているからです。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="EndLoadData">
      <MemberSignature Language="C#" Value="public void EndLoadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndLoadData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.EndLoadData" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndLoadData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndLoadData();" />
      <MemberSignature Language="F#" Value="member this.EndLoadData : unit -&gt; unit" Usage="dataTable.EndLoadData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>データを読み込んだ後、通知、インデックスの維持、および制約をオンにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.EndLoadData%2A>と共に<xref:System.Data.DataTable.LoadDataRow%2A>と<xref:System.Data.DataTable.BeginLoadData%2A>します。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProperties">
      <MemberSignature Language="C#" Value="public System.Data.PropertyCollection ExtendedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.PropertyCollection ExtendedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ExtendedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtendedProperties As PropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::PropertyCollection ^ ExtendedProperties { System::Data::PropertyCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProperties : System.Data.PropertyCollection" Usage="System.Data.DataTable.ExtendedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("ExtendedPropertiesDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.PropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>カスタマイズされたユーザー情報のコレクションを取得します。</summary>
        <value>カスタム ユーザー情報が格納された <see cref="T:System.Data.PropertyCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Data.DataTable.ExtendedProperties%2A>にカスタム情報を追加する、<xref:System.Data.DataTable>します。 使用して情報を追加、`Add`メソッド。 情報を取得、`Item`メソッド。  
  
 拡張プロパティは、型でなければなりません<xref:System.String>します。 文字列型でないプロパティは保持されないときに、<xref:System.Data.DataTable>は XML として書き込まれます。  
  
   
  
## Examples  
 次の例では、追加するタイムスタンプ値を<xref:System.Data.DataTable>を通じて、<xref:System.Data.DataTable.ExtendedProperties%2A>プロパティ。  
  
 [!code-csharp[Classic WebData DataTable.ExtendedProperties Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ExtendedProperties Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ExtendedProperties Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ExtendedProperties Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="fInitInProgress">
      <MemberSignature Language="C#" Value="protected internal bool fInitInProgress;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly bool fInitInProgress" />
      <MemberSignature Language="DocId" Value="F:System.Data.DataTable.fInitInProgress" />
      <MemberSignature Language="VB.NET" Value="Protected Friend fInitInProgress As Boolean " />
      <MemberSignature Language="C++ CLI" Value="protected public: bool fInitInProgress;" />
      <MemberSignature Language="F#" Value="val mutable fInitInProgress : bool" Usage="System.Data.DataTable.fInitInProgress" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>初期化処理中かどうかをチェックします。 初期化は実行時に発生します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>前回 <see cref="T:System.Data.DataTable" /> を読み取るか、<see cref="M:System.Data.DataTable.AcceptChanges" /> を呼び出した以降にこのデータセットに対して行われたすべての変更が格納されているこのデータセットのコピーを取得します。</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable イベントの処理</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataTable GetChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable GetChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ GetChanges();" />
      <MemberSignature Language="F#" Value="member this.GetChanges : unit -&gt; System.Data.DataTable" Usage="dataTable.GetChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>前回 <see cref="T:System.Data.DataTable" /> を読み取るか、<see cref="M:System.Data.DataTable.AcceptChanges" /> を呼び出した以降にこのデータセットに対して行われたすべての変更が格納されているこのデータセットのコピーを取得します。</summary>
        <returns>この <see cref="T:System.Data.DataTable" /> からの変更のコピー。変更がない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新たに作成<xref:System.Data.DataSet>、元のすべての行のコピーを含む<xref:System.Data.DataSet>保留中の変更があります。 リレーションシップの制限が原因で、新規に追加する追加の変更されていない行<xref:System.Data.DataSet>変更されていない行が変更された行の外部キーに対応する主キーを含めるかどうか。 メソッドを返します`null`(`Nothing` Visual Basic で) 元の行がない場合<xref:System.Data.DataSet>で保留中の変更。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable イベントの処理</related>
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataTable GetChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable GetChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges (rowStates As DataRowState) As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ GetChanges(System::Data::DataRowState rowStates);" />
      <MemberSignature Language="F#" Value="member this.GetChanges : System.Data.DataRowState -&gt; System.Data.DataTable" Usage="dataTable.GetChanges rowStates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">
          <see cref="T:System.Data.DataRowState" /> 値のいずれか 1 つ。</param>
        <summary>前回 <see cref="T:System.Data.DataTable" /> を読み取るか、<see cref="M:System.Data.DataTable.AcceptChanges" /> を呼び出した以降にこのデータセットに対して行われたすべての変更が格納されているこのデータセットのコピーを、<see cref="T:System.Data.DataRowState" /> によってフィルター処理した後で取得します。</summary>
        <returns>アクションを実行した後、<see cref="T:System.Data.DataTable" /> を使用して元の <see cref="T:System.Data.DataTable" /> にマージするために使用できる、<see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" /> のフィルター処理後のコピー。 必要な <see cref="T:System.Data.DataRowState" /> の行が見つからない場合、このメソッドは <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.GetChanges%2A>メソッドは、1 秒あたりに生成するために使用<xref:System.Data.DataTable>元に導入された変更のみを格納するオブジェクト。 使用して、`rowStates`新しいオブジェクトを含める必要があります変更の種類を指定する引数。  
  
 親が変更されていない行が含まれるリレーションシップの制約があります。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable イベントの処理</related>
      </Docs>
    </Member>
    <Member MemberName="GetDataTableSchema">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema (System.Xml.Schema.XmlSchemaSet schemaSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema(class System.Xml.Schema.XmlSchemaSet schemaSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetDataTableSchema(System.Xml.Schema.XmlSchemaSet)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDataTableSchema (schemaSet As XmlSchemaSet) As XmlSchemaComplexType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Schema::XmlSchemaComplexType ^ GetDataTableSchema(System::Xml::Schema::XmlSchemaSet ^ schemaSet);" />
      <MemberSignature Language="F#" Value="static member GetDataTableSchema : System.Xml.Schema.XmlSchemaSet -&gt; System.Xml.Schema.XmlSchemaComplexType" Usage="System.Data.DataTable.GetDataTableSchema schemaSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaComplexType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemaSet" Type="System.Xml.Schema.XmlSchemaSet" />
      </Parameters>
      <Docs>
        <param name="schemaSet">
          <see cref="T:System.Xml.Schema.XmlSchemaSet" /> インスタンス。</param>
        <summary>このメソッドは、Web サービスの <see cref="T:System.Xml.Schema.XmlSchemaSet" /> を記述する Web サービス記述言語 (WSDL) を含む <see cref="T:System.Data.DataTable" /> インスタンスを返します。</summary>
        <returns>
          <see cref="T:System.Xml.Schema.XmlSchemaSet" /> インスタンス。</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="GetErrors">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] GetErrors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] GetErrors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetErrors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetErrors () As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ GetErrors();" />
      <MemberSignature Language="F#" Value="member this.GetErrors : unit -&gt; System.Data.DataRow[]" Usage="dataTable.GetErrors " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>エラーが含まれる <see cref="T:System.Data.DataRow" /> オブジェクトの配列を取得します。</summary>
        <returns>エラーが含まれる <see cref="T:System.Data.DataRow" /> オブジェクトの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一覧を返します<xref:System.Data.DataRow>を持つオブジェクト<xref:System.Data.DataRow.RowError%2A>を設定します。 呼び出すときにエラーが発生することができます、<xref:System.Data.Common.DataAdapter.Update%2A>で<xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A>設定`true`します。 呼び出さないでください<xref:System.Data.DataTable.AcceptChanges%2A>上、<xref:System.Data.DataTable>すべてのエラーを解決して再送信するまで、<xref:System.Data.DataSet>を更新するためです。  
  
   
  
## Examples  
 次の例では、<xref:System.Data.DataTable.GetErrors%2A>の配列を返すメソッドを<xref:System.Data.DataRow>エラーが発生したオブジェクト。  
  
 [!code-csharp[Classic WebData DataTable.GetErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.HasErrors" />
        <altmember cref="P:System.Data.DataRow.RowError" />
        <altmember cref="M:System.Data.DataRow.SetColumnError(System.Int32,System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">DataTable (ADO.NET)</related>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dataTable.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> オブジェクトと関連付けられているシリアル化データを保持する <see cref="T:System.Data.DataTable" />。</param>
        <param name="context">
          <see cref="T:System.Runtime.Serialization.StreamingContext" /> に関連付けられているシリアル化ストリームのソースおよびデスティネーションを格納する <see cref="T:System.Data.DataTable" /> オブジェクト。</param>
        <summary>シリアル化情報オブジェクトを、<see cref="T:System.Data.DataTable" /> のシリアル化に必要なデータで事前設定します。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> パラメーターが null 参照 (Visual Basic の場合は <see langword="Nothing" />) です。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="GetRowType">
      <MemberSignature Language="C#" Value="protected virtual Type GetRowType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Type GetRowType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetRowType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetRowType () As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Type ^ GetRowType();" />
      <MemberSignature Language="F#" Value="abstract member GetRowType : unit -&gt; Type&#xA;override this.GetRowType : unit -&gt; Type" Usage="dataTable.GetRowType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>行の種類を取得します。</summary>
        <returns>
          <see cref="T:System.Data.DataRow" /> の種類を返します。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSchema">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Schema.XmlSchema GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Schema.XmlSchema GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetSchema" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSchema () As XmlSchema" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xml::Schema::XmlSchema ^ GetSchema();" />
      <MemberSignature Language="F#" Value="abstract member GetSchema : unit -&gt; System.Xml.Schema.XmlSchema&#xA;override this.GetSchema : unit -&gt; System.Xml.Schema.XmlSchema" Usage="dataTable.GetSchema " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />」をご覧ください。</summary>
        <returns>
          <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> メソッドによって生成され <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /> メソッドによって処理されるオブジェクトの XML 表現を記述する <see cref="T:System.Xml.Schema.XmlSchema" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasErrors">
      <MemberSignature Language="C#" Value="public bool HasErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.HasErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasErrors { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasErrors : bool" Usage="System.Data.DataTable.HasErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableHasErrorsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>テーブルが属する <see cref="T:System.Data.DataSet" /> のいずれかのテーブルのいずれかの行にエラーがあるかどうかを示す値を取得します。</summary>
        <value>エラーがある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ユーザーの作業に含まれるデータのセットに応じて、 <xref:System.Data.DataTable>、変更によって検証エラーが発生した場合、エラーでは、各変更をマークすることができます。 全体をマークする<xref:System.Data.DataRow>を使用してエラー メッセージ、<xref:System.Data.DataRow.RowError%2A>プロパティ。 含む行の各列でエラーを設定することも、<xref:System.Data.DataRow.SetColumnError%2A>メソッド。  
  
 データ ソースを更新する前に、 <xref:System.Data.DataSet>、最初に呼び出すことをお勧め、<xref:System.Data.DataSet.GetChanges%2A>メソッド ターゲットを<xref:System.Data.DataSet>します。 メソッドの結果、<xref:System.Data.DataSet>元に行われた変更のみを格納しています。 送信する前に、<xref:System.Data.DataSet>を更新するため、データ ソースを確認、<xref:System.Data.DataTable.HasErrors%2A>エラーが行または行の列にアタッチされているかどうかに表示するには、各テーブルのプロパティ。  
  
 各エラーを解決した後でエラーをクリア、<xref:System.Data.DataRow.ClearErrors%2A>のメソッド、`DataRow`します。  
  
   
  
## Examples  
 次の例では、<xref:System.Data.DataTable.HasErrors%2A>テーブルにエラーが含まれるかどうかを確認するプロパティ。  
  
 [!code-csharp[Classic WebData DataTable.HasErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.HasErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.HasErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.HasErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.GetErrors" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="ImportRow">
      <MemberSignature Language="C#" Value="public void ImportRow (System.Data.DataRow row);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ImportRow(class System.Data.DataRow row) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ImportRow(System.Data.DataRow)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ImportRow (row As DataRow)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ImportRow(System::Data::DataRow ^ row);" />
      <MemberSignature Language="F#" Value="member this.ImportRow : System.Data.DataRow -&gt; unit" Usage="dataTable.ImportRow row" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="row" Type="System.Data.DataRow" />
      </Parameters>
      <Docs>
        <param name="row">インポートする <see cref="T:System.Data.DataRow" />。</param>
        <summary>プロパティ設定、元の値、および現在の値を保持し、<see cref="T:System.Data.DataRow" /> を <see cref="T:System.Data.DataTable" /> にコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す<xref:System.Data.DataTable.NewRow%2A>、行の既定の値が、既存のテーブル スキーマを使用してテーブルに行を追加し、設定、<xref:System.Data.DataRowState>に`Detached`します。 呼び出す<xref:System.Data.DataTable.ImportRow%2A>既存を保持<xref:System.Data.DataRowState>と共に、行の他の値。 場合、`DataRow`渡されるパラメーターがデタッチ済み状態では、無視され、例外はスローされません。  
  
 新しい行は、データ テーブルの末尾に追加されます。  
  
 新しい行には制約に違反している場合は、データ テーブルに追加されません。  
  
 DataTable.Rows.Find と DataTable.Rows.IndexOf として持つ新しい行のインデックスを取得できます。 詳細については、「<xref:System.Data.DataRowCollection>」および「<xref:System.Data.DataTable.Rows%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5cb86d48-a987-4af4-80e0-8cc2c8373d62">DataTable (ADO.NET) 内のデータを操作します。</related>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataTable" /> が初期化された後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 詳細については、「<xref:System.Data.DataTable.IsInitialized%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable イベントの処理</related>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Data.DataTable.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataTable" /> が初期化されているかどうかを示す値を取得します。</summary>
        <value>コンポーネントが初期化を完了したことを示す場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 状態を返し、<xref:System.Data.DataTable>ことによって作成される、たとえば Visual Studio の中にします。 <xref:System.Data.DataTable.BeginInit%2A>メソッドに設定`false`と<xref:System.Data.DataTable.EndInit%2A>メソッドに設定`true`します。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable イベントの処理</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定された <see cref="T:System.Data.DataTable" /> を使用し、<see cref="T:System.Data.IDataReader" /> にデータ ソースからの値を設定します。 <see langword="DataTable" /> が既に行を含んでいる場合、データ ソースからの受信データは既存の行にマージされます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Load`メソッドは、指定したデータ ソースからデータを取得し、現在のデータ コンテナーに追加することをすべて中央揃え、いくつかの一般的なシナリオで使用できます (ここで、 `DataTable`)。 これらのシナリオの標準の使用状況の説明、`DataTable`その更新プログラムを記述する方法、および動作をマージします。  
  
 A`DataTable`により同期または 1 つのプライマリ データ ソースを更新します。 `DataTable`プライマリ データ ソースとの同期を許可する、変更を追跡します。 さらに、 `DataTable` 1 つまたは複数のセカンダリ データ ソースからデータの増分を受け入れることができます。 `DataTable`セカンダリ データ ソースと同期できるようにするために変更を追跡する必要はありません。  
  
 これら 2 つの架空のデータ ソースを指定するには、ユーザーは、次の動作のいずれかが必要な可能性。  
  
-   初期化`DataTable`プライマリ データ ソースから。 このシナリオで、ユーザーが、空の初期化が`DataTable`をプライマリ データ ソースの値。 後で、ユーザーは、プライマリ データ ソースに変更を反映する予定です。  
  
-   変更を保持し、プライマリ データ ソースから再同期します。 このシナリオで、ユーザーが実行する、`DataTable`で行われた変更を維持し、プライマリ データ ソースと、増分同期を行い、前のシナリオで入力、`DataTable`します。  
  
-   セカンダリ データ ソースからの増分データ フィードです。 このシナリオでは、ユーザーは、1 つまたは複数のセカンダリ データ ソースからの変更をマージし、プライマリ データ ソースに戻るには、その変更を反映するがします。  
  
 `Load`メソッドにより、これらすべてのシナリオが可能です。 すべてが 1 つのオーバー ロードは、このメソッドを使用して、読み込みのオプション パラメーターを指定できますを示す方法に既に含まれて、<xref:System.Data.DataTable>読み込まれる行と結合します。 (動作を指定することはできませんをオーバー ロードは、既定の読み込みオプションを使用します)。次の表に、次の 3 つの負荷で提供されるオプション、<xref:System.Data.LoadOption>列挙体。 各ケースでは、説明は、着信データの行の主キーには、既存の行の主キーが一致する場合に、動作を示します。  
  
|読み込みオプション|説明|  
|-----------------|-----------------|  
|`PreserveChanges` (既定値)|受信した行の値を持つ行の元のバージョンを更新します。|  
|`OverwriteChanges`|受信した行の値を持つ行の現在と元のバージョンを更新します。|  
|`Upsert`|受信した行の値を持つ行の現在のバージョンを更新します。|  
  
 一般に、`PreserveChanges`と`OverwriteChanges`オプションは、ユーザーが同期のシナリオを意図しています、`DataSet`とプライマリ データ ソースを変更します。 `Upsert`オプションが 1 つまたは複数のセカンダリ データ ソースから集計の変更を容易になります。  
  
   
  
## Examples  
 次の例では、呼び出しに関連する問題のいくつかを紹介します<xref:System.Data.DataTable.Load%2A>メソッド。 例では、スキーマの問題は、読み込まれてから、スキーマの推論などに重点を置いています最初に、<xref:System.Data.IDataReader>とし、互換性のないスキーマは、および不足しているまたはその他の列を含むスキーマを処理します。 例では、さまざまな読み込みオプションの処理など、データの問題、について説明します。  
  
> [!NOTE]
>  この例は、のいずれかのオーバー ロードされたバージョンを使用する方法を示します`Load`します。 使用可能な可能性があるその他の例は、個々 のオーバー ロードのトピックを参照してください。  
  
 [!code-csharp[DataWorks DataTableLoad#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.Load" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (reader As IDataReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader -&gt; unit" Usage="dataTable.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
      </Parameters>
      <Docs>
        <param name="reader">結果セットを提供する <see cref="T:System.Data.IDataReader" />。</param>
        <summary>指定された <see cref="T:System.Data.DataTable" /> を使用し、<see cref="T:System.Data.IDataReader" /> にデータ ソースからの値を設定します。 <see cref="T:System.Data.DataTable" /> が既に行を含んでいる場合、データ ソースからの受信データは既存の行にマージされます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.Load%2A>メソッドは最初の結果セットから読み込まれた<xref:System.Data.IDataReader>が正常に完了には、設定、リーダーの位置 [次へ] の結果セットに存在する場合とします。 データを変換するとき、`Load`メソッドと同じ変換規則を使用して、<xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType>メソッド。  
  
 <xref:System.Data.DataTable.Load%2A>メソッドする必要があります考慮に入れて 3 つの特定の問題からデータを読み込むときに、<xref:System.Data.IDataReader>インスタンス: スキーマ、データ、およびイベント操作。 スキーマを使用する場合、<xref:System.Data.DataTable.Load%2A>メソッドを次の表に示す条件が発生する可能性があります。 データが含まれていないものも含め、すべてのインポートされた結果セット向けに、スキーマ操作が行わします。  
  
|条件|動作|  
|---------------|--------------|  
|<xref:System.Data.DataTable>スキーマがありません。|<xref:System.Data.DataTable.Load%2A>メソッドは、インポートの結果セットに基づくスキーマを推論<xref:System.Data.IDataReader>します。|  
|<xref:System.Data.DataTable>スキーマがありますが、読み込まれたスキーマに互換性はありません。|<xref:System.Data.DataTable.Load%2A>メソッドしようとすると、互換性のないスキーマにデータを読み込むときに発生する特定のエラーに対応する例外をスローします。|  
|スキーマに互換性はあるが、読み込まれた結果セットのスキーマに存在しない列が含まれています、<xref:System.Data.DataTable>します。|<xref:System.Data.DataTable.Load%2A>メソッドは、余分な列を追加します。`DataTable`のスキーマ。 メソッドは、対応する場合に例外をスロー内の列、<xref:System.Data.DataTable>読み込まれた結果セットは、互換性のある値ではできません。 メソッドは、追加したすべての列の結果セットからも制約情報を取得します。 場合にのみに使用するこの制約の情報を除く Primary Key 制約の場合は、現在<xref:System.Data.DataTable>読み込み操作の開始時の任意の列を含んでいません。|  
|スキーマに互換性はあるが、読み込まれた結果セットのスキーマがよりも少ない列が含まれています、`DataTable`します。|不足している列が定義された既定値を持っているか、列のデータ型は、null 許容の場合、<xref:System.Data.DataTable.Load%2A>メソッドにより、追加する行であり、既定値の置換または`null`不足している列の値。 既定値はありません場合、または`null`使用できますが、次に、`Load`メソッドが例外をスローします。 特定の既定値が指定されていない場合、`Load`メソッドは、`null`暗黙の既定値として値。|  
  
 動作を検討する前に、`Load`メソッドは、データ操作の観点からそれを考慮して各内で行を<xref:System.Data.DataTable>各列の元の値と現在の値の両方を保持します。 これらの値は、それと同等である可能性がありますか、いっぱいになるのため、行のデータが変更された場合は異なる場合があります、`DataTable`します。  詳細については、次を参照してください。[行の状態と行バージョン](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)します。  
  
 このバージョンの`Load`メソッドは、元の値をそのまま残して、各行の現在の値を保持しようとしています。 (受信データの動作をより細かく制御する場合は、「 <xref:System.Data.DataTable.Load%2A?displayProperty=nameWithType>。)既存の行と、受信した行に対応する主キー値が含まれている場合、現在の行の状態の値を使用して、行が処理されると、それ以外の場合、新しい行として扱われます。  
  
 イベントの操作の観点から、<xref:System.Data.DataTable.RowChanging>各の行を変更すると、前に、イベントが発生し、<xref:System.Data.DataTable.RowChanged>イベントは、各行が変更された後に発生します。 各ケースで、<xref:System.Data.DataRowChangeEventArgs.Action%2A>のプロパティ、<xref:System.Data.DataRowChangeEventArgs>イベント ハンドラーに渡されるインスタンスには、イベントに関連付けられた特定のアクションに関する情報が含まれています。 このアクションの値は、読み込み操作の前に、の行の状態によって異なります。 各ケースで両方のイベントが発生して、アクションはそれぞれ同じです。 アクションは、各行の現在または元のバージョンまたは行の現在の状態に応じて、両方に適用できます。  
  
 次の表の動作、`Load`メソッド。 最後の行 (「(存在しない)」のラベル) には、既存の行が一致しない行の動作について説明します。 このテーブル内の各セルは、と共に、行のフィールドの現在と元の値をについて説明します、<xref:System.Data.DataRowState>後の値を`Load`メソッドが完了しました。 この場合、メソッドの読み込み オプションを指定することはできず、既定では、`PreserveChanges`します。  
  
|既存の DataRowState|後の値`Load`メソッド、およびイベント アクション|  
|---------------------------|--------------------------------------------------|  
|追加|現在 =\<既存 ><br /><br /> 元 =\<受信 ><br /><br /> 状態 =\<変更 ><br /><br /> RowAction ChangeOriginal を =|  
|変更日時|現在 =\<既存 ><br /><br /> 元 =\<受信 ><br /><br /> 状態 =\<変更 ><br /><br /> RowAction ChangeOriginal を =|  
|Deleted|現在 =\<不可 ><br /><br /> 元 =\<受信 ><br /><br /> 状態 =\<削除 ><br /><br /> RowAction ChangeOriginal を =|  
|Unchanged|現在 =\<受信 ><br /><br /> 元 =\<受信 ><br /><br /> 状態 = \<Unchanged ><br /><br /> RowAction ChangeCurrentAndOriginal を =|  
|(存在しません)|現在 =\<受信 ><br /><br /> 元 =\<受信 ><br /><br /> 状態 = \<Unchanged ><br /><br /> RowAction ChangeCurrentAndOriginal を =|  
  
 値を<xref:System.Data.DataColumn>などのプロパティを使用して制限できます<xref:System.Data.DataColumn.ReadOnly%2A>と<xref:System.Data.DataColumn.AutoIncrement%2A>します。 `Load`メソッドは、列のプロパティで定義されている動作と一貫性のある方法では、このような列を処理します。 読み取りの唯一の制約上、<xref:System.Data.DataColumn>はメモリ内で発生した変更のみに適用されます。 `Load`メソッドの必要な場合は、読み取り専用の列の値が上書きされます。  
  
 受信行では、現在の行を比較するために使用する主キー フィールドのバージョンを決定する、`Load`メソッドが存在する場合、同一行に、主キーの値の元のバージョンを使用します。 それ以外の場合、`Load`メソッドは、主キー フィールドの現在のバージョンを使用します。  
  
   
  
## Examples  
 次の例では、呼び出しに関連する問題のいくつかを紹介します<xref:System.Data.DataTable.Load%2A>メソッド。 例では、スキーマの問題は、読み込まれてから、スキーマの推論などに重点を置いています最初に、<xref:System.Data.IDataReader>とし、互換性のないスキーマは、および不足しているまたはその他の列を含むスキーマを処理します。 例を呼び出して、`Load`読み込み操作の前後にデータを表示するメソッド。  
  
 [!code-csharp[DataWorks DataTableLoad.IDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.IDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.IDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.IDataReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable イベントの処理</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader * System.Data.LoadOption -&gt; unit" Usage="dataTable.Load (reader, loadOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
      </Parameters>
      <Docs>
        <param name="reader">1 つ以上の結果セットを含む <see cref="T:System.Data.IDataReader" />。</param>
        <param name="loadOption">
          <see cref="T:System.Data.LoadOption" /> 列挙体の値。<see cref="T:System.Data.DataTable" /> に既に含まれている行を同じ主キーを持つ受信した行と結合する方法を示します。</param>
        <summary>指定された <see cref="T:System.Data.DataTable" /> を使用し、<see cref="T:System.Data.IDataReader" /> にデータ ソースからの値を設定します。 <see langword="DataTable" /> が既に行を含んでいる場合、<paramref name="loadOption" /> パラメーターの値に従って、データ ソースからの受信データは既存の行にマージされます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Load`メソッドは最初の結果セットから読み込まれた<xref:System.Data.IDataReader>が正常に完了には、設定、リーダーの位置 [次へ] の結果セットに存在する場合とします。 データを変換するとき、`Load`メソッドと同じ変換規則を使用して、<xref:System.Data.Common.DbDataAdapter.Fill%2A>メソッド。  
  
 `Load`メソッドする必要があります考慮に入れて 3 つの特定の問題からデータを読み込むときに、<xref:System.Data.IDataReader>インスタンス: スキーマ、データ、およびイベント操作。 スキーマを使用する場合、`Load`メソッドを次の表に示す条件が発生する可能性があります。 データが含まれていないものも含め、すべてのインポートされた結果セット向けに、スキーマ操作が行わします。  
  
|条件|動作|  
|---------------|--------------|  
|<xref:System.Data.DataTable>スキーマがありません。|`Load`メソッドは、インポートの結果セットに基づくスキーマを推論<xref:System.Data.IDataReader>します。|  
|<xref:System.Data.DataTable>スキーマがありますが、読み込まれたスキーマに互換性はありません。|`Load`メソッドしようとすると、互換性のないスキーマにデータを読み込むときに発生する特定のエラーに対応する例外をスローします。|  
|スキーマに互換性はあるが、読み込まれた結果セットのスキーマに存在しない列が含まれています、`DataTable`します。|`Load`メソッドは、余分な列を追加します。`DataTable`のスキーマ。 メソッドは、対応する場合に例外をスロー内の列、<xref:System.Data.DataTable>読み込まれた結果セットは、互換性のある値ではできません。 メソッドは、追加したすべての列の結果セットからも制約情報を取得します。 場合にのみに使用するこの制約の情報を除く Primary Key 制約の場合は、現在<xref:System.Data.DataTable>読み込み操作の開始時の任意の列を含んでいません。|  
|スキーマに互換性はあるが、読み込まれた結果セットのスキーマがよりも少ない列が含まれています、`DataTable`します。|不足している列が定義された既定値を持っているか、列のデータ型は、null 許容の場合、`Load`メソッドにより、追加する行であり、不足している列の default または null 値を置き換えます。 既定値や null は使用できない場合、`Load`メソッドが例外をスローします。 特定の既定値が指定されていない場合、`Load`メソッドは、暗黙の既定値として null 値を使用します。|  
  
 動作を検討する前に、`Load`メソッドは、データ操作の観点からそれを考慮して各内で行を<xref:System.Data.DataTable>各列の元の値と現在の値の両方を保持します。 これらの値は、それと同等である可能性がありますか、いっぱいになるのため、行のデータが変更された場合は異なる場合があります、`DataTable`します。 参照してください[行の状態と行バージョン](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)詳細についてはします。  
  
 このメソッド呼び出しで指定した<xref:System.Data.LoadOption>パラメーター受信データの処理に影響を与えます。 Load メソッドで既存の行として主キーが同じである読み込みの行が処理する方法 現在の値、元の値、またはその両方を変更にする必要がありますか。 これらの問題などがによって制御される、`loadOption`パラメーター。  
  
 既存の行と、受信した行に対応する主キー値が含まれている場合、現在の行の状態の値を使用して、行が処理されると、それ以外の場合、新しい行として扱われます。  
  
 イベントの操作の観点から、<xref:System.Data.DataTable.RowChanging>各の行を変更すると、前に、イベントが発生し、<xref:System.Data.DataTable.RowChanged>イベントは、各行が変更された後に発生します。 各ケースで、<xref:System.Data.DataRowChangeEventArgs.Action%2A>のプロパティ、<xref:System.Data.DataRowChangeEventArgs>イベント ハンドラーに渡されるインスタンスには、イベントに関連付けられた特定のアクションに関する情報が含まれています。 このアクションの値は、読み込み操作の前に、の行の状態によって異なります。 各ケースで両方のイベントが発生して、アクションはそれぞれ同じです。 アクションは、各行の現在または元のバージョンまたは行の現在の状態に応じて、両方に適用できます。  
  
 次の表に、それぞれの呼び出されたときに、Load メソッドの動作、`LoadOption`値し、も、値が読み込まれている行の行の状態と対話する方法を示しています。 最後の行 (「(存在しない)」のラベル) には、既存の行が一致しない行の動作について説明します。 このテーブル内の各セルは、と共に、行のフィールドの現在と元の値をについて説明します、<xref:System.Data.DataRowState>後の値を`Load`メソッドが完了しました。  
  
|既存の DataRowState|Upsert|OverwriteChanges|PreserveChanges (既定の動作)|  
|---------------------------|------------|----------------------|------------------------------------------|  
|追加|現在 =\<受信 ><br /><br /> 元 = -\<不可 ><br /><br /> 状態 =\<追加 ><br /><br /> RowAction 変更を =|現在 =\<受信 ><br /><br /> 元 =\<受信 ><br /><br /> 状態 = \<Unchanged ><br /><br /> RowAction ChangeCurrentAndOriginal を =|現在 =\<既存 ><br /><br /> 元 =\<受信 ><br /><br /> 状態 =\<変更 ><br /><br /> RowAction ChangeOriginal を =|  
|変更日時|現在 =\<受信 ><br /><br /> 元 =\<既存 ><br /><br /> 状態 =\<変更 ><br /><br /> RowAction 変更を =|現在 =\<受信 ><br /><br /> 元 =\<受信 ><br /><br /> 状態 = \<Unchanged ><br /><br /> RowAction ChangeCurrentAndOriginal を =|現在 =\<既存 ><br /><br /> 元 =\<受信 ><br /><br /> 状態 =\<変更 ><br /><br /> RowAction ChangeOriginal を =|  
削除済みとオリジナル|(負荷の動作に影響が削除された行ではなく)<br /><br /> 現在 =--<br /><br /> 元 =\<既存 ><br /><br /> 状態 =\<削除 ><br /><br /> (次の特性を持つ新しい行が追加されます)<br /><br /> 現在 =\<受信 ><br /><br /> 元 =\<不可 ><br /><br /> 状態 =\<追加 ><br /><br /> RowAction = 追加|削除の取り消しと<br /><br /> 現在 =\<受信 ><br /><br /> 元 =\<受信 ><br /><br /> 状態 = \<Unchanged ><br /><br /> RowAction ChangeCurrentAndOriginal を =|現在 =\<不可 ><br /><br /> 元 =\<受信 ><br /><br /> 状態 =\<削除 ><br /><br /> RowAction ChangeOriginal を =|  
|Unchanged|現在 =\<受信 ><br /><br /> 元 =\<既存 ><br /><br /> 新しい値が、既存の値と同じ場合<br /><br /> 状態 = \<Unchanged ><br /><br /> RowAction = Nothing<br /><br /> Else<br /><br /> 状態 =\<変更 ><br /><br /> RowAction 変更を =|現在 =\<受信 ><br /><br /> 元 =\<受信 ><br /><br /> 状態 = \<Unchanged ><br /><br /> RowAction ChangeCurrentAndOriginal を =|現在 =\<受信 ><br /><br /> 元 =\<受信 ><br /><br /> 状態 = \<Unchanged ><br /><br /> RowAction ChangeCurrentAndOriginal を =|  
存在しません)|現在 =\<受信 ><br /><br /> 元 =\<不可 ><br /><br /> 状態 =\<追加 ><br /><br /> RowAction = 追加|現在 =\<受信 ><br /><br /> 元 =\<受信 ><br /><br /> 状態 = \<Unchanged ><br /><br /> RowAction ChangeCurrentAndOriginal を =|現在 =\<受信 ><br /><br /> 元 =\<受信 ><br /><br /> 状態 = \<Unchanged ><br /><br /> RowAction ChangeCurrentAndOriginal を =|  
  
 値を<xref:System.Data.DataColumn>などのプロパティを使用して制限できます<xref:System.Data.DataColumn.ReadOnly%2A>と<xref:System.Data.DataColumn.AutoIncrement%2A>します。 `Load`メソッドは、列のプロパティで定義されている動作と一貫性のある方法では、このような列を処理します。 読み取りの唯一の制約上、<xref:System.Data.DataColumn>はメモリ内で発生した変更のみに適用されます。 `Load`メソッドの必要な場合は、読み取り専用の列の値が上書きされます。  
  
 呼び出すときに、OverwriteChanges PreserveChanges オプションを指定するかどうか、`Load`メソッド、そのことを前提から受信したデータが送信されたことを行ったが、`DataTable`の変更を追跡し、伝達できるプライマリ データ ソース、および DataTableデータ ソースに変更します。 Upsert オプションを選択した場合、データがユーザーによって変更されるなど、中間層コンポーネントによって提供されるデータなどのセカンダリ データ ソースのいずれかから送信されたことと見なされます。 ここでは、という前提は、目的の 1 つまたは複数のデータ ソースからデータを集計するには、 `DataTable`、プライマリ データ ソースにデータをおそらく伝達します。 <xref:System.Data.LoadOption>が主キーの比較に使用される行のバージョンを特定のパラメーターを使用します。 次の表では、詳細を提供します。  
  
|読み込みオプション|プライマリ キーの比較に使用される DataRow バージョン|  
|-----------------|-----------------------------------------------------|  
|`OverwriteChanges`|元のバージョンは存在する場合、それ以外の場合に現在のバージョン|  
|`PreserveChanges`|元のバージョンは存在する場合、それ以外の場合に現在のバージョン|  
|`Upsert`|現在のバージョンが存在する場合、それ以外の場合に元のバージョン|  
  
   
  
## Examples  
 次の例では、呼び出しに関連する問題のいくつかを紹介します<xref:System.Data.DataTable.Load%2A>メソッド。 例では、スキーマの問題は、読み込まれてから、スキーマの推論などに重点を置いています最初に、<xref:System.Data.IDataReader>とし、互換性のないスキーマは、および不足しているまたはその他の列を含むスキーマを処理します。 例では、さまざまな読み込みオプションの処理など、データの問題、について説明します。  
  
 [!code-csharp[DataWorks DataTableLoad.LoadOption#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.LoadOption/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.LoadOption#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.LoadOption/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable イベントの処理</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.FillErrorEventHandler errorHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, System::Data::FillErrorEventHandler ^ errorHandler);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler -&gt; unit&#xA;override this.Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler -&gt; unit" Usage="dataTable.Load (reader, loadOption, errorHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="errorHandler" Type="System.Data.FillErrorEventHandler" />
      </Parameters>
      <Docs>
        <param name="reader">結果セットを提供する <see cref="T:System.Data.IDataReader" />。</param>
        <param name="loadOption">
          <see cref="T:System.Data.LoadOption" /> 列挙体の値。<see cref="T:System.Data.DataTable" /> に既に含まれている行を同じ主キーを持つ受信した行と結合する方法を示します。</param>
        <param name="errorHandler">データの読み込み中にエラーが発生した場合に呼び出される <see cref="T:System.Data.FillErrorEventHandler" /> デリゲート。</param>
        <summary>エラー処理デリゲートを使用し、指定された <see cref="T:System.Data.DataTable" /> を使用して、<see cref="T:System.Data.IDataReader" /> にデータ ソースからの値を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Load`メソッドは最初の結果セットから読み込まれた<xref:System.Data.IDataReader>が正常に完了には、設定、リーダーの位置 [次へ] の結果セットに存在する場合とします。 データを変換するとき、`Load`メソッドと同じ変換規則を使用して、<xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType>メソッド。  
  
 `Load`メソッドする必要があります考慮に入れて 3 つの特定の問題からデータを読み込むときに、<xref:System.Data.IDataReader>インスタンス: スキーマ、データ、およびイベント操作。 スキーマを使用する場合、`Load`メソッドを次の表に示す条件が発生する可能性があります。 データが含まれていないものも含め、すべてのインポートされた結果セット向けに、スキーマ操作が行わします。  
  
|条件|動作|  
|---------------|--------------|  
|<xref:System.Data.DataTable>スキーマがありません。|`Load`メソッドは、インポートの結果セットに基づくスキーマを推論<xref:System.Data.IDataReader>します。|  
|<xref:System.Data.DataTable>スキーマがありますが、読み込まれたスキーマに互換性はありません。|`Load`メソッドしようとすると、互換性のないスキーマにデータを読み込むときに発生する特定のエラーに対応する例外をスローします。|  
|スキーマに互換性はあるが、読み込まれた結果セットのスキーマに存在しない列が含まれています、`DataTable`します。|`Load`メソッドは、余分な列を追加します。`DataTable`のスキーマ。 メソッドは、対応する場合に例外をスロー内の列、<xref:System.Data.DataTable>読み込まれた結果セットは、互換性のある値ではできません。 メソッドは、追加したすべての列の結果セットからも制約情報を取得します。 場合にのみに使用するこの制約の情報を除く Primary Key 制約の場合は、現在<xref:System.Data.DataTable>読み込み操作の開始時の任意の列を含んでいません。|  
|スキーマに互換性はあるが、読み込まれた結果セットのスキーマがよりも少ない列が含まれています、`DataTable`します。|不足している列が定義された既定値を持っているか、列のデータ型は、null 許容の場合、`Load`メソッドにより、追加する行であり、不足している列の default または null 値を置き換えます。 既定値や null は使用できない場合、`Load`メソッドが例外をスローします。 特定の既定値が指定されていない場合、`Load`メソッドは、暗黙の既定値として null 値を使用します。|  
  
 動作を検討する前に、`Load`メソッドは、データ操作の観点からそれを考慮して各内で行を<xref:System.Data.DataTable>各列の元の値と現在の値の両方を保持します。 これらの値は、それと同等である可能性がありますか、いっぱいになるのため、行のデータが変更された場合は異なる場合があります、`DataTable`します。 参照してください[行の状態と行バージョン](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)詳細についてはします。  
  
 このメソッド呼び出しで指定した<xref:System.Data.LoadOption>パラメーター受信データの処理に影響を与えます。 Load メソッドで既存の行として主キーが同じである読み込みの行が処理する方法 現在の値、元の値、またはその両方を変更にする必要がありますか。 これらの問題などがによって制御される、`loadOption`パラメーター。  
  
 既存の行と、受信した行に対応する主キー値が含まれている場合、現在の行の状態の値を使用して、行が処理されると、それ以外の場合、新しい行として扱われます。  
  
 イベントの操作の観点から、<xref:System.Data.DataTable.RowChanging>各の行を変更すると、前に、イベントが発生し、<xref:System.Data.DataTable.RowChanged>イベントは、各行が変更された後に発生します。 各ケースで、<xref:System.Data.DataRowChangeEventArgs.Action%2A>のプロパティ、<xref:System.Data.DataRowChangeEventArgs>イベント ハンドラーに渡されるインスタンスには、イベントに関連付けられた特定のアクションに関する情報が含まれています。 このアクションの値は、読み込み操作の前に、の行の状態によって異なります。 各ケースで両方のイベントが発生して、アクションはそれぞれ同じです。 アクションは、各行の現在または元のバージョンまたは行の現在の状態に応じて、両方に適用できます。  
  
 次の表に、それぞれの呼び出されたときに、Load メソッドの動作、`LoadOption`値し、も、値が読み込まれている行の行の状態と対話する方法を示しています。 最後の行 (「(存在しない)」のラベル) には、既存の行が一致しない行の動作について説明します。 このテーブル内の各セルは、と共に、行のフィールドの現在と元の値をについて説明します、<xref:System.Data.DataRowState>後の値を`Load`メソッドが完了しました。  
  
|既存の DataRowState|Upsert|OverwriteChanges|PreserveChanges (既定の動作)|  
|---------------------------|------------|----------------------|------------------------------------------|  
|追加|現在 =\<受信 ><br /><br /> 元 = -\<不可 ><br /><br /> 状態 =\<追加 ><br /><br /> RowAction 変更を =|現在 =\<受信 ><br /><br /> 元 =\<受信 ><br /><br /> 状態 = \<Unchanged ><br /><br /> RowAction ChangeCurrentAndOriginal を =|現在 =\<既存 ><br /><br /> 元 =\<受信 ><br /><br /> 状態 =\<変更 ><br /><br /> RowAction ChangeOriginal を =|  
|変更日時|現在 =\<受信 ><br /><br /> 元 =\<既存 ><br /><br /> 状態 =\<変更 ><br /><br /> RowAction 変更を =|現在 =\<受信 ><br /><br /> 元 =\<受信 ><br /><br /> 状態 = \<Unchanged ><br /><br /> RowAction ChangeCurrentAndOriginal を =|現在 =\<既存 ><br /><br /> 元 =\<受信 ><br /><br /> 状態 =\<変更 ><br /><br /> RowAction ChangeOriginal を =|  
削除済みとオリジナル|(負荷の動作に影響が削除された行ではなく)<br /><br /> 現在 =--<br /><br /> 元 =\<既存 ><br /><br /> 状態 =\<削除 ><br /><br /> (次の特性を持つ新しい行が追加されます)<br /><br /> 現在 =\<受信 ><br /><br /> 元 =\<不可 ><br /><br /> 状態 =\<追加 ><br /><br /> RowAction = 追加|削除の取り消しと<br /><br /> 現在 =\<受信 ><br /><br /> 元 =\<受信 ><br /><br /> 状態 = \<Unchanged ><br /><br /> RowAction ChangeCurrentAndOriginal を =|現在 =\<不可 ><br /><br /> 元 =\<受信 ><br /><br /> 状態 =\<削除 ><br /><br /> RowAction ChangeOriginal を =|  
|Unchanged|現在 =\<受信 ><br /><br /> 元 =\<既存 ><br /><br /> 新しい値が、既存の値と同じ場合<br /><br /> 状態 = \<Unchanged ><br /><br /> RowAction = Nothing<br /><br /> Else<br /><br /> 状態 =\<変更 ><br /><br /> RowAction 変更を =|現在 =\<受信 ><br /><br /> 元 =\<受信 ><br /><br /> 状態 = \<Unchanged ><br /><br /> RowAction ChangeCurrentAndOriginal を =|現在 =\<受信 ><br /><br /> 元 =\<受信 ><br /><br /> 状態 = \<Unchanged ><br /><br /> RowAction ChangeCurrentAndOriginal を =|  
存在しません)|現在 =\<受信 ><br /><br /> 元 =\<不可 ><br /><br /> 状態 =\<追加 ><br /><br /> RowAction = 追加|現在 =\<受信 ><br /><br /> 元 =\<受信 ><br /><br /> 状態 = \<Unchanged ><br /><br /> RowAction ChangeCurrentAndOriginal を =|現在 =\<受信 ><br /><br /> 元 =\<受信 ><br /><br /> 状態 = \<Unchanged ><br /><br /> RowAction ChangeCurrentAndOriginal を =|  
  
 値を<xref:System.Data.DataColumn>などのプロパティを使用して制限できます<xref:System.Data.DataColumn.ReadOnly%2A>と<xref:System.Data.DataColumn.AutoIncrement%2A>します。 `Load`メソッドは、列のプロパティで定義されている動作と一貫性のある方法では、このような列を処理します。 読み取りの唯一の制約上、<xref:System.Data.DataColumn>はメモリ内で発生した変更のみに適用されます。 `Load`メソッドの必要な場合は、読み取り専用の列の値が上書きされます。  
  
 呼び出すときに、OverwriteChanges PreserveChanges オプションを指定するかどうか、`Load`メソッド、そのことを前提から受信したデータが送信されたことを行ったが、`DataTable`の変更を追跡し、伝達できるプライマリ データ ソース、および DataTableデータ ソースに変更します。 Upsert オプションを選択した場合、データがユーザーによって変更されるなど、中間層コンポーネントによって提供されるデータなどのセカンダリ データ ソースのいずれかから送信されたことと見なされます。 ここでは、という前提は、目的の 1 つまたは複数のデータ ソースからデータを集計するには、 `DataTable`、プライマリ データ ソースにデータをおそらく伝達します。 <xref:System.Data.LoadOption>が主キーの比較に使用される行のバージョンを特定のパラメーターを使用します。 次の表では、詳細を提供します。  
  
|読み込みオプション|プライマリ キーの比較に使用される DataRow バージョン|  
|-----------------|-----------------------------------------------------|  
|`OverwriteChanges`|元のバージョンは存在する場合、それ以外の場合に現在のバージョン|  
|`PreserveChanges`|元のバージョンは存在する場合、それ以外の場合に現在のバージョン|  
|`Upsert`|現在のバージョンが存在する場合、それ以外の場合に元のバージョン|  
  
 `errorHandler`パラメーターは、<xref:System.Data.FillErrorEventHandler>データの読み込み中にエラーが発生したときに呼び出されるプロシージャを参照するデリゲート。 <xref:System.Data.FillErrorEventArgs>プロシージャに渡されるパラメーターは、発生したエラー、データの現在の行に関する情報を取得するためのプロパティを提供し、<xref:System.Data.DataTable>に指定されています。 このデリゲートのメカニズムを使用して、単純な try/catch ブロックではなく、エラーを確認することができます状況の処理し、必要な場合の処理を続行します。 <xref:System.Data.FillErrorEventArgs>パラメーターを提供、<xref:System.Data.FillErrorEventArgs.Continue%2A>プロパティ: このプロパティを設定`true`をエラーを処理し、処理を続行することを示します。 プロパティを設定`false`を処理を停止することを示します。 注意してくださいそのプロパティを設定する`false`コードが例外をスローする問題を発生させた。  
  
   
  
## Examples  
 [!code-csharp[DataWorks DataTableLoad.ErrorEventHandler#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.ErrorEventHandler/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.ErrorEventHandler#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.ErrorEventHandler/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable イベントの処理</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadDataRow">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>特定の行を検索し、更新します。 一致する行が見つからない場合は、指定した値を使用して新しい行が作成されます。</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadDataRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow LoadDataRow (object[] values, bool fAcceptChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow LoadDataRow(object[] values, bool fAcceptChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadDataRow (values As Object(), fAcceptChanges As Boolean) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ LoadDataRow(cli::array &lt;System::Object ^&gt; ^ values, bool fAcceptChanges);" />
      <MemberSignature Language="F#" Value="member this.LoadDataRow : obj[] * bool -&gt; System.Data.DataRow" Usage="dataTable.LoadDataRow (values, fAcceptChanges)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
        <Parameter Name="fAcceptChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="values">新しい行の作成に使用する値の配列。</param>
        <param name="fAcceptChanges">変更を受け入れる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>特定の行を検索し、更新します。 一致する行が見つからない場合は、指定した値を使用して新しい行が作成されます。</summary>
        <returns>新しい <see cref="T:System.Data.DataRow" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.LoadDataRow%2A>メソッドが値の配列を受け取り、主キー列で一致する値を検索します。  
  
 列に既定値がある場合は、その列の既定値を設定する配列に null 値を渡します。 同様に、列にある場合、<xref:System.Data.DataColumn.AutoIncrement%2A>を true に、自動的に生成された行の値を設定する配列の null 値を渡すプロパティを設定します。  
  
 場合、`fAcceptChanges`パラメーターが`true`またはが指定されていない新しいデータが追加されたし、<xref:System.Data.DataTable.AcceptChanges%2A>内のすべての変更を反映するために呼び出される、<xref:System.Data.DataTable>場合は、引数が`false`、新しく追加された行が挿入、およびへの変更としてマークされています。既存の行は、変更としてマークされます。  
  
 例外は、いずれかの中にも発生する<xref:System.Data.DataTable.ColumnChanging>または<xref:System.Data.DataTable.RowChanging>イベント。 例外が発生する場合、行は、テーブルには追加されません。  
  
 使用<xref:System.Data.DataTable.LoadDataRow%2A>と共に<xref:System.Data.DataTable.BeginLoadData%2A>と<xref:System.Data.DataTable.EndLoadData%2A>します。  
  
   
  
## Examples  
 次の例では、<xref:System.Data.DataTable.LoadDataRow%2A>行を検索しようとするメソッド。 このような行が見つからない場合は、値が新しい行を作成に使用されます。  
  
 [!code-csharp[Classic WebData DataTable.LoadDataRow Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.LoadDataRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.LoadDataRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.LoadDataRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">配列がテーブルの列数より大きいです。</exception>
        <exception cref="T:System.InvalidCastException">値が各列の型と一致していません。</exception>
        <exception cref="T:System.Data.ConstraintException">この行を追加すると、制約が無効になります。</exception>
        <exception cref="T:System.Data.NoNullAllowedException">
          <see cref="P:System.Data.DataColumn.AllowDBNull" /> が false である列に null を格納しようとしています。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable イベントの処理</related>
      </Docs>
    </Member>
    <Member MemberName="LoadDataRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow LoadDataRow (object[] values, System.Data.LoadOption loadOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow LoadDataRow(object[] values, valuetype System.Data.LoadOption loadOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ LoadDataRow(cli::array &lt;System::Object ^&gt; ^ values, System::Data::LoadOption loadOption);" />
      <MemberSignature Language="F#" Value="member this.LoadDataRow : obj[] * System.Data.LoadOption -&gt; System.Data.DataRow" Usage="dataTable.LoadDataRow (values, loadOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
      </Parameters>
      <Docs>
        <param name="values">新しい行の作成に使用する値の配列。</param>
        <param name="loadOption">配列値を既存の行にある対応する値に適用する方法を決定するために使用します。</param>
        <summary>特定の行を検索し、更新します。 一致する行が見つからない場合は、指定した値を使用して新しい行が作成されます。</summary>
        <returns>新しい <see cref="T:System.Data.DataRow" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.LoadDataRow%2A>メソッドが値の配列を受け取り、主キー列で一致する値を検索します。  
  
 列に既定値がある場合は、その列の既定値を設定する配列に null 値を渡します。 同様に、列にある場合、<xref:System.Data.DataColumn.AutoIncrement%2A>を true に、自動的に生成された行の値を設定する配列の null 値を渡すプロパティを設定します。  
  
 値、`loadOption`配列内の値を既存の行に適用する方法を決定するパラメーターを使用します。 たとえば場合、`loadOption`に設定されている`OverwriteChanges`、`Original`と`Current`各列の値は、受信した行の値に置き換えられます、`RowState`プロパティに設定されて`Unchanged`します。  
  
 例外は、いずれかの中にも発生する<xref:System.Data.DataTable.ColumnChanging>または<xref:System.Data.DataTable.RowChanging>イベント。 例外が発生する場合、行は、テーブルには追加されません。  
  
 使用<xref:System.Data.DataTable.LoadDataRow%2A>と共に<xref:System.Data.DataTable.BeginLoadData%2A>と<xref:System.Data.DataTable.EndLoadData%2A>します。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="Locale">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Locale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Locale" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Locale" />
      <MemberSignature Language="VB.NET" Value="Public Property Locale As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Locale { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Locale : System.Globalization.CultureInfo with get, set" Usage="System.Data.DataTable.Locale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableLocaleDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>テーブル内の文字列の比較に使用するロケール情報を取得または設定します。</summary>
        <value>ユーザーのコンピューターのロケールについてのデータが格納されている <see cref="T:System.Globalization.CultureInfo" />。 既定値は <see cref="T:System.Data.DataSet" /> が属する <see cref="T:System.Globalization.CultureInfo" /> オブジェクトの (<see cref="P:System.Data.DataSet.Locale" /> プロパティによって返される) <see cref="T:System.Data.DataTable" /> です。テーブルが <see cref="T:System.Data.DataSet" /> に属さない場合、既定値は現在のシステムの <see cref="T:System.Globalization.CultureInfo" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Globalization.CultureInfo>の特定のカルチャまたはコミュニティのソフトウェアの設定を表します。  
  
 文字列の比較に使用される場合、<xref:System.Globalization.CultureInfo>並べ替え、比較、およびフィルター処理に影響を与えます。  
  
> [!NOTE]
>  式を指定する列で、<xref:System.StringComparison.InvariantCulture>使用されます。 <xref:System.StringComparison.CurrentCulture>は無視されます。  
  
   
  
## Examples  
 次の例のセット、<xref:System.Globalization.CultureInfo>を通じて、 <xref:System.Data.DataTable.Locale%2A> ISO 言語の名前を出力します。  
  
 [!code-csharp[Classic WebData DataTable.Locale Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Locale Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Locale Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Locale Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Merge">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した <see cref="T:System.Data.DataTable" /> を現在の <see cref="T:System.Data.DataTable" /> とマージします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Merge`メソッドを使用して、2 つのマージを<xref:System.Data.DataTable>ほぼ同じスキーマを含むオブジェクト。 既存のデータ ソースから最新の変更を組み込むことに、マージが通常使用クライアント アプリケーションに対する<xref:System.Data.DataTable>します。 これにより、クライアント アプリケーションを更新して<xref:System.Data.DataTable>データ ソースから最新のデータにします。  
  
 マージ操作では、元のテーブルのみとマージするテーブルが考慮されます。 しない子テーブルが影響を受けるか、含まれています。 テーブルに 1 つまたは複数の子テーブル、リレーションシップの一部として定義されている場合は、各子テーブルを個別にマージする必要があります。  
  
   
  
## Examples  
 次のコンソール アプリケーションの動作を示す、`missingSchemaAction`のパラメーター、<xref:System.Data.DataTable.Merge%2A>メソッド。 この例では、2 番目のバージョンのスキーマの変更、同じテーブルの 2 つのバージョンを作成します。 コードは、最初に 2 番目のテーブルをマージを試みます。  
  
> [!NOTE]
>  この例では、マージのオーバー ロードされたバージョンのいずれかを使用する方法を示します。 使用可能な可能性があるその他の例は、個々 のオーバー ロードのトピックを参照してください。  
  
 [!code-csharp[DataWorks DataTableMergeOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableMergeOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableMergeOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableMergeOverload/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable -&gt; unit" Usage="dataTable.Merge table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">現在の <see cref="T:System.Data.DataTable" /> とマージする <see cref="T:System.Data.DataTable" />。</param>
        <summary>指定した <see cref="T:System.Data.DataTable" /> を現在の <see cref="T:System.Data.DataTable" /> とマージします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Merge メソッドが 2 つにマージするために使用<xref:System.Data.DataTable>ほぼ同じスキーマを含むオブジェクト。 既存のデータ ソースから最新の変更を組み込むことに、マージが通常使用クライアント アプリケーションに対する<xref:System.Data.DataTable>します。 これにより、クライアント アプリケーションを更新して<xref:System.Data.DataTable>データ ソースから最新のデータにします。  
  
 マージ操作では、元のテーブルのみとマージするテーブルが考慮されます。 しない子テーブルが影響を受けるか、含まれています。 テーブルに 1 つまたは複数の子テーブル、リレーションシップの一部として定義されている場合は、各子テーブルを個別にマージする必要があります。  
  
 `Merge`メソッドは、通常、一連の変更の検証、エラーを調整、変更により、データ ソースの更新、および最後に、既存の更新に関連するプロシージャの最後に呼び出されます<xref:System.Data.DataTable>します。  
  
 マージを実行するときに、マージする前に、既存のデータに加えられた変更が既定では、マージ操作中に保持されます。 開発者はで、このメソッドの他の 2 つのオーバー ロードのいずれかを呼び出し、false 値を指定するこの動作を変更することができます、`preserveChanges`パラメーター。  
  
 クライアント アプリケーションでは、1 つのボタン ユーザーがクリックすることができますが、変更されたデータを収集し、中間層のコンポーネントに送信する前に検証するために通常は。 このシナリオで、<xref:System.Data.DataTable.GetChanges%2A>メソッドが最初に呼び出されます。 2 番目に返します<xref:System.Data.DataTable>検証とマージ用に最適化します。 この 1 秒間<xref:System.Data.DataTable>オブジェクトのみを含む、 <xref:System.Data.DataRow> 、元のサブセットの結果として、変更されたオブジェクト<xref:System.Data.DataTable>します。 このサブセットは一般に小さいため、中間層のコンポーネントにより効率的によく渡されます。 中間層のコンポーネントは、ストアド プロシージャを使用して変更を元のデータ ソースを更新します。 中間層が、新しいバックアップを送信できますし、 <xref:System.Data.DataTable> (によって、元のクエリを再実行)、元のデータとデータ ソースから最新のデータを含むかをデータ ソースから行われた変更のサブセットに送り返すことができます。 (たとえば、データ ソースは、一意の主キー値を自動的に作成される場合これらの値伝えることができるクライアント アプリケーションにします。)どちらの場合、返された<xref:System.Data.DataTable>クライアント アプリケーションの元に再マージすることができます<xref:System.Data.DataTable>で、<xref:System.Data.DataTable.Merge%2A>メソッド。  
  
 新しいソースをマージするときに<xref:System.Data.DataTable>、ターゲットに任意のソースの行で、<xref:System.Data.DataRowState>の値`Unchanged`、 `Modified`、または`Deleted`が同じ主キーの値を持つターゲット行に一致します。 ソースを持つ行を<xref:System.Data.DataRowState>の値`Added`が新しいソース行として同じプライマリ キー値を持つターゲットの新しい行に一致します。  
  
   
  
## Examples  
 次のコンソール アプリケーションの作成、単純な<xref:System.Data.DataTable>テーブルにデータを追加します。 例は、コピーする行の追加、テーブルのコピーを作成します。 最後に、例では、<xref:System.Data.DataTable.Merge%2A>メソッドの最初のテーブル内のデータを 2 番目のテーブル データをマージします。  
  
 [!code-csharp[DataWorks DataTable.Merge#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.Merge/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.Merge#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.Merge/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable イベントの処理</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable, preserveChanges As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable * bool -&gt; unit" Usage="dataTable.Merge (table, preserveChanges)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="table">現在の <see langword="DataTable" /> とマージする <see langword="DataTable" />。</param>
        <param name="preserveChanges">現在の <see langword="true" /> に対して行われた変更を保持するには <see langword="DataTable" />。保持しない場合は <see langword="false" />。</param>
        <summary>指定した <see cref="T:System.Data.DataTable" /> を現在の <see langword="DataTable" /> とマージし、現在の <see langword="DataTable" /> の変更を保持するかどうかを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Merge メソッドが 2 つにマージするために使用<xref:System.Data.DataTable>ほぼ同じスキーマを含むオブジェクト。 既存のデータ ソースから最新の変更を組み込むことに、マージが通常使用クライアント アプリケーションに対する<xref:System.Data.DataTable>します。 これにより、クライアント アプリケーションを更新して<xref:System.Data.DataTable>データ ソースから最新のデータにします。  
  
 マージ操作では、元のテーブルのみとマージするテーブルが考慮されます。 しない子テーブルが影響を受けるか、含まれています。 テーブルに 1 つまたは複数の子テーブル、リレーションシップの一部として定義されている場合は、各子テーブルを個別にマージする必要があります。  
  
 `Merge`メソッドは、通常、一連の変更の検証、エラーを調整、変更により、データ ソースの更新、および最後に、既存の更新に関連するプロシージャの最後に呼び出されます<xref:System.Data.DataTable>します。  
  
 マージを実行するときに、マージする前に、既存のデータに加えられた変更は、開発者が場合は false を指定しない限り、マージ操作中に保持されます、`preserveChanges`パラメーター。 場合、`preserveChanges`にパラメーターが設定されている`true`、入力方向の値は、既存の行の現在の行バージョンの既存の値を上書きできません。 場合、`preserveChanges`にパラメーターが設定されている`false`、受信した値は、既存の行の現在の行のバージョンで既存の値を上書きしないでください。 行のバージョンの詳細については、次を参照してください。[行の状態と行バージョン](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)します。  
  
 クライアント アプリケーションでは、1 つのボタン ユーザーがクリックすることができますが、変更されたデータを収集し、中間層のコンポーネントに送信する前に検証するために通常は。 このシナリオで、<xref:System.Data.DataTable.GetChanges%2A>メソッドが最初に呼び出されます。 2 番目に返します<xref:System.Data.DataTable>検証とマージ用に最適化します。 この 1 秒間<xref:System.Data.DataTable>オブジェクトのみを含む、<xref:System.Data.DataTable>と<xref:System.Data.DataRow>、元のサブセットの結果として、変更されたオブジェクト<xref:System.Data.DataTable>します。 このサブセットは一般的に小さく、したがってこのサブセットは、中間層のコンポーネントに渡されるより効率的にします。 中間層のコンポーネントは、ストアド プロシージャを使用して変更を元のデータ ソースを更新します。 中間層が、新しいバックアップを送信できますし、 <xref:System.Data.DataTable> (によって、元のクエリを再実行)、元のデータとデータ ソースから最新のデータを含むかをデータ ソースから行われた変更のサブセットに送り返すことができます。 (たとえば、データ ソースは、一意の主キー値を自動的に作成される場合これらの値伝えることができるクライアント アプリケーションにします。)どちらの場合、返された<xref:System.Data.DataTable>クライアント アプリケーションの元に再マージすることができます<xref:System.Data.DataTable>で、<xref:System.Data.DataTable.Merge%2A>メソッド。  
  
 新しいソースをマージするときに<xref:System.Data.DataTable>、ターゲットに任意のソースの行で、<xref:System.Data.DataRowState>の値`Unchanged`、 `Modified`、または`Deleted`が同じ主キーの値を持つターゲット行に一致します。 ソースを持つ行を<xref:System.Data.DataRowState>の値`Added`が新しいソース行として同じプライマリ キー値を持つターゲットの新しい行に一致します。  
  
   
  
## Examples  
 次のコンソール アプリケーションを作成、 <xref:System.Data.DataTable> 、行を格納している、それらの行のデータの一部が変更され、別のデータを結合しようとしています。<xref:System.Data.DataTable>します。 動作の違い例を示します、`preserveChanges`パラメーター。  
  
 [!code-csharp[DataWorks DataTable.MergePreserveChanges#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.MergePreserveChanges/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.MergePreserveChanges#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.MergePreserveChanges/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable イベントの処理</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataTable.Merge (table, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="table">現在の <see cref="T:System.Data.DataTable" /> とマージする <see cref="T:System.Data.DataTable" />。</param>
        <param name="preserveChanges">現在の <see langword="true" /> に対して行われた変更を保持するには <see cref="T:System.Data.DataTable" />。保持しない場合は <see langword="false" />。</param>
        <param name="missingSchemaAction">
          <see cref="T:System.Data.MissingSchemaAction" /> 値のいずれか 1 つ。</param>
        <summary>指定した <see cref="T:System.Data.DataTable" /> を現在の <see langword="DataTable" /> とマージして、現在の <see langword="DataTable" /> の変更を保持するかどうかを指定し、さらに欠けているスキーマの処理方法を指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Merge`メソッドを使用して、2 つのマージを<xref:System.Data.DataTable>ほぼ同じスキーマを含むオブジェクト。 既存のデータ ソースから最新の変更を組み込むことに、マージが通常使用クライアント アプリケーションに対する<xref:System.Data.DataTable>します。 これにより、クライアント アプリケーションを更新して<xref:System.Data.DataTable>データ ソースから最新のデータにします。  
  
 マージ操作では、元のテーブルのみとマージするテーブルが考慮されます。 しない子テーブルが影響を受けるか、含まれています。 テーブルに 1 つまたは複数の子テーブル、リレーションシップの一部として定義されている場合は、各子テーブルを個別にマージする必要があります。  
  
 `Merge`メソッドは、通常、一連の変更の検証、エラーを調整、変更により、データ ソースの更新、および最後に、既存の更新に関連するプロシージャの最後に呼び出されます<xref:System.Data.DataTable>します。  
  
 マージを実行するときに、マージする前に、既存のデータに加えられた変更は、開発者が場合は false を指定しない限り、マージ操作中に保持されます、`preserveChanges`パラメーター。 場合、`preserveChanges`にパラメーターが設定されている`true`、入力方向の値は、既存の行の現在の行バージョンの既存の値を上書きできません。 場合、`preserveChanges`にパラメーターが設定されている`false`、受信した値は、既存の行の現在の行のバージョンで既存の値を上書きしないでください。 行のバージョンの詳細については、次を参照してください。[行の状態と行バージョン](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)します。  
  
 クライアント アプリケーションでは、1 つのボタン ユーザーがクリックすることができますが、変更されたデータを収集し、中間層のコンポーネントに送信する前に検証するために通常は。 このシナリオで、<xref:System.Data.DataTable.GetChanges%2A>メソッドが最初に呼び出されます。 2 番目に返します<xref:System.Data.DataTable>検証とマージ用に最適化します。 この 1 秒間<xref:System.Data.DataTable>オブジェクトのみを含む、<xref:System.Data.DataTable>と<xref:System.Data.DataRow>、元のサブセットの結果として、変更されたオブジェクト<xref:System.Data.DataTable>します。 このサブセットは一般的に小さく、したがってこのサブセットは、中間層のコンポーネントに渡されるより効率的にします。 中間層のコンポーネントは、ストアド プロシージャを使用して変更を元のデータ ソースを更新します。 中間層が、新しいバックアップを送信できますし、 <xref:System.Data.DataTable> (によって、元のクエリを再実行)、元のデータとデータ ソースから最新のデータを含むかをデータ ソースから行われた変更のサブセットに送り返すことができます。 (たとえば、データ ソースは、一意の主キー値を自動的に作成される場合これらの値伝えることができるクライアント アプリケーションにします。)どちらの場合、返された<xref:System.Data.DataTable>クライアント アプリケーションの元に再マージすることができます<xref:System.Data.DataTable>で、<xref:System.Data.DataTable.Merge%2A>メソッド。  
  
 ときに、<xref:System.Data.DataTable.Merge%2A>メソッドが呼び出されると、2 つのスキーマ<xref:System.Data.DataTable>するスキーマが変更された可能性があるため、オブジェクトを比較します。 たとえば、企業間取引シナリオで新しい列が追加された可能性が XML スキーマを自動プロセスで。 場合、ソース<xref:System.Data.DataTable>スキーマ要素が含まれています (追加<xref:System.Data.DataColumn>オブジェクト)、ターゲットに不足している、スキーマ要素は、設定して、ターゲットに追加できる、`missingSchemaAction`への引数`MissingSchemaAction.Add`。 その場合は、マージされた<xref:System.Data.DataTable>に追加されたスキーマとデータが含まれています。  
  
 スキーマをマージ後に、データに結合されます。  
  
 新しいソースをマージするときに<xref:System.Data.DataTable>、ターゲットに任意のソースの行で、<xref:System.Data.DataRowState>の値`Unchanged`、 `Modified`、または`Deleted`が同じ主キーの値を持つターゲット行に一致します。 ソースを持つ行を<xref:System.Data.DataRowState>の値`Added`が新しいソース行として同じプライマリ キー値を持つターゲットの新しい行に一致します。  
  
   
  
## Examples  
 次のコンソール アプリケーションの動作を示す、`missingSchemaAction`のパラメーター、<xref:System.Data.DataTable.Merge%2A>メソッド。 この例では、2 番目のバージョンのスキーマの変更、同じテーブルの 2 つのバージョンを作成します。 コードは、最初に 2 番目のテーブルをマージを試みます。  
  
 [!code-csharp[DataWorks DataTable.MergeMissingSchemaAction#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.MergeMissingSchemaAction/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.MergeMissingSchemaAction#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.MergeMissingSchemaAction/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable イベントの処理</related>
      </Docs>
    </Member>
    <Member MemberName="MinimumCapacity">
      <MemberSignature Language="C#" Value="public int MinimumCapacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.MinimumCapacity" />
      <MemberSignature Language="VB.NET" Value="Public Property MinimumCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumCapacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MinimumCapacity : int with get, set" Usage="System.Data.DataTable.MinimumCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(50)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableMinimumCapacityDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このテーブルの初期開始サイズを取得または設定します。</summary>
        <value>この行の初期開始サイズ。行数で表します。 既定値には 50 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.MinimumCapacity%2A>システムは、データをフェッチする前に、適切なリソースのセットを作成できます。 状況でパフォーマンスが重要な場合は、このプロパティを設定するパフォーマンスを最適化できます。  
  
   
  
## Examples  
 次の例のセット、<xref:System.Data.DataTable.MinimumCapacity%2A>の<xref:System.Data.DataTable>します。  
  
 [!code-csharp[Classic WebData DataTable.MinimumCapacity Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.MinimumCapacity Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.MinimumCapacity Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.MinimumCapacity Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.Data.DataTable.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableNamespaceDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataTable" /> に格納されているデータの XML 表現の名前空間を取得または設定します。</summary>
        <value>
          <see cref="T:System.Data.DataTable" /> の名前空間。</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="NewRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow NewRow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow NewRow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRow" />
      <MemberSignature Language="VB.NET" Value="Public Function NewRow () As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ NewRow();" />
      <MemberSignature Language="F#" Value="member this.NewRow : unit -&gt; System.Data.DataRow" Usage="dataTable.NewRow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>テーブルと同じスキーマで新しい <see cref="T:System.Data.DataRow" /> を作成します。</summary>
        <returns>
          <see cref="T:System.Data.DataRow" /> と同じスキーマを持つ <see cref="T:System.Data.DataTable" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用する必要があります、<xref:System.Data.DataTable.NewRow%2A>新しいを作成するメソッド<xref:System.Data.DataRow>オブジェクトと同じスキーマを持つ、<xref:System.Data.DataTable>します。 作成した後、<xref:System.Data.DataRow>に追加することができます、<xref:System.Data.DataRowCollection>を使用して、<xref:System.Data.DataTable>オブジェクトの<xref:System.Data.DataTable.Rows%2A>プロパティ。 使用すると<xref:System.Data.DataTable.NewRow%2A>を新しい行を作成するには、行必要があります追加またはを呼び出す前に、データ テーブルから削除<xref:System.Data.DataTable.Clear%2A>します。  
  
   
  
## Examples  
 次の例では、作成、 <xref:System.Data.DataTable>、2 つ追加します<xref:System.Data.DataColumn>オブジェクト、テーブルのスキーマを決定し、いくつか新たに作成します<xref:System.Data.DataRow>オブジェクトを使用して、<xref:System.Data.DataTable.NewRow%2A>メソッド。 これは、<xref:System.Data.DataRow>オブジェクトに追加し、<xref:System.Data.DataRowCollection>を使用して、<xref:System.Data.DataRowCollection.Add%2A>メソッド。  
  
 [!code-csharp[Classic WebData DataTable.NewRow Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.NewRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.NewRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.NewRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable イベントの処理</related>
      </Docs>
    </Member>
    <Member MemberName="NewRowArray">
      <MemberSignature Language="C#" Value="protected internal System.Data.DataRow[] NewRowArray (int size);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Data.DataRow[] NewRowArray(int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRowArray(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function NewRowArray (size As Integer) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ NewRowArray(int size);" />
      <MemberSignature Language="F#" Value="member this.NewRowArray : int -&gt; System.Data.DataRow[]" Usage="dataTable.NewRowArray size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="size">配列のサイズを表す <see cref="T:System.Int32" /> 値。</param>
        <summary>
          <see cref="T:System.Data.DataRow" /> の配列を返します。</summary>
        <returns>新しい配列。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRowFromBuilder">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataRow NewRowFromBuilder (System.Data.DataRowBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataRow NewRowFromBuilder(class System.Data.DataRowBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRowFromBuilder(System.Data.DataRowBuilder)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function NewRowFromBuilder (builder As DataRowBuilder) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataRow ^ NewRowFromBuilder(System::Data::DataRowBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="abstract member NewRowFromBuilder : System.Data.DataRowBuilder -&gt; System.Data.DataRow&#xA;override this.NewRowFromBuilder : System.Data.DataRowBuilder -&gt; System.Data.DataRow" Usage="dataTable.NewRowFromBuilder builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Data.DataRowBuilder" />
      </Parameters>
      <Docs>
        <param name="builder">
          <see cref="T:System.Data.DataRowBuilder" /> オブジェクト。</param>
        <summary>既存の行から新しい行を作成します。</summary>
        <returns>
          <see cref="T:System.Data.DataRow" /> の派生クラス。</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="OnColumnChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnColumnChanged (System.Data.DataColumnChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnColumnChanged(class System.Data.DataColumnChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnColumnChanged (e As DataColumnChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnColumnChanged(System::Data::DataColumnChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnColumnChanged : System.Data.DataColumnChangeEventArgs -&gt; unit&#xA;override this.OnColumnChanged : System.Data.DataColumnChangeEventArgs -&gt; unit" Usage="dataTable.OnColumnChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataColumnChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Data.DataColumnChangeEventArgs" />。</param>
        <summary>
          <see cref="E:System.Data.DataTable.ColumnChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 概要については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドするときに<see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" />、派生クラスでは、基本クラスを呼び出す、<see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" />メソッド。</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable イベントの処理</related>
      </Docs>
    </Member>
    <Member MemberName="OnColumnChanging">
      <MemberSignature Language="C#" Value="protected internal virtual void OnColumnChanging (System.Data.DataColumnChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnColumnChanging(class System.Data.DataColumnChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnColumnChanging (e As DataColumnChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnColumnChanging(System::Data::DataColumnChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnColumnChanging : System.Data.DataColumnChangeEventArgs -&gt; unit&#xA;override this.OnColumnChanging : System.Data.DataColumnChangeEventArgs -&gt; unit" Usage="dataTable.OnColumnChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataColumnChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Data.DataColumnChangeEventArgs" />。</param>
        <summary>
          <see cref="E:System.Data.DataTable.ColumnChanging" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 概要については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドするときに<see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" />、派生クラスでは、基本クラスを呼び出す、<see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" />メソッド。</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable イベントの処理</related>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanging(class System.ComponentModel.PropertyChangedEventArgs pcevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanging (pcevent As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanging(System::ComponentModel::PropertyChangedEventArgs ^ pcevent);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit" Usage="dataTable.OnPropertyChanging pcevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcevent" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="pcevent">イベント データを格納している <see cref="T:System.ComponentModel.PropertyChangedEventArgs" />。</param>
        <summary>
          <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 概要については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドするときに<see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />、派生クラスでは、基本クラスを呼び出す、<see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />メソッド。</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable イベントの処理</related>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveColumn">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveColumn (System.Data.DataColumn column);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveColumn(class System.Data.DataColumn column) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemoveColumn (column As DataColumn)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemoveColumn(System::Data::DataColumn ^ column);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveColumn : System.Data.DataColumn -&gt; unit&#xA;override this.OnRemoveColumn : System.Data.DataColumn -&gt; unit" Usage="dataTable.OnRemoveColumn column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="column" Type="System.Data.DataColumn" />
      </Parameters>
      <Docs>
        <param name="column">削除する <see cref="T:System.Data.DataColumn" />。</param>
        <summary>
          <see cref="T:System.Data.DataTable" /> が削除されることを <see cref="T:System.Data.DataColumn" /> に通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドするときに<see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" />、派生クラスでは、基本クラスを呼び出す、<see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" />メソッド。</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable イベントの処理</related>
      </Docs>
    </Member>
    <Member MemberName="OnRowChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRowChanged (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowChanged(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowChanged (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowChanged(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowChanged : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowChanged : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Data.DataRowChangeEventArgs" />。</param>
        <summary>
          <see cref="E:System.Data.DataTable.RowChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 概要については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドするときに<see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" />、派生クラスでは、基本クラスを呼び出す、<see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" />メソッド。</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable イベントの処理</related>
      </Docs>
    </Member>
    <Member MemberName="OnRowChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnRowChanging (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowChanging(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowChanging (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowChanging(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowChanging : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowChanging : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Data.DataRowChangeEventArgs" />。</param>
        <summary>
          <see cref="E:System.Data.DataTable.RowChanging" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 概要については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドするときに<see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" />、派生クラスでは、基本クラスを呼び出す、<see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" />メソッド。</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable イベントの処理</related>
      </Docs>
    </Member>
    <Member MemberName="OnRowDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnRowDeleted (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowDeleted(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowDeleted (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowDeleted(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowDeleted : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowDeleted : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Data.DataRowChangeEventArgs" />。</param>
        <summary>
          <see cref="E:System.Data.DataTable.RowDeleted" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 概要については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドするときに<see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" />、派生クラスでは、基本クラスを呼び出す、<see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" />メソッド。</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable イベントの処理</related>
      </Docs>
    </Member>
    <Member MemberName="OnRowDeleting">
      <MemberSignature Language="C#" Value="protected virtual void OnRowDeleting (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowDeleting(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowDeleting (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowDeleting(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowDeleting : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowDeleting : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowDeleting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Data.DataRowChangeEventArgs" />。</param>
        <summary>
          <see cref="E:System.Data.DataTable.RowDeleting" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 概要については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドするときに<see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" />、派生クラスでは、基本クラスを呼び出す、<see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" />メソッド。</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable イベントの処理</related>
      </Docs>
    </Member>
    <Member MemberName="OnTableCleared">
      <MemberSignature Language="C#" Value="protected virtual void OnTableCleared (System.Data.DataTableClearEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableCleared(class System.Data.DataTableClearEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableCleared(System.Data.DataTableClearEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableCleared (e As DataTableClearEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableCleared(System::Data::DataTableClearEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTableCleared : System.Data.DataTableClearEventArgs -&gt; unit&#xA;override this.OnTableCleared : System.Data.DataTableClearEventArgs -&gt; unit" Usage="dataTable.OnTableCleared e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableClearEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Data.DataTableClearEventArgs" />。</param>
        <summary>
          <see cref="E:System.Data.DataTable.TableCleared" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 発生させる、 <xref:System.Data.DataTable.TableCleared> 、すぐにすべての行が削除された後正常にする前に発生するイベント、<xref:System.Data.DataTable.Clear%2A>メソッドが呼び出し元にコントロールを返します。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 概要については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable イベントの処理</related>
      </Docs>
    </Member>
    <Member MemberName="OnTableClearing">
      <MemberSignature Language="C#" Value="protected virtual void OnTableClearing (System.Data.DataTableClearEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableClearing(class System.Data.DataTableClearEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableClearing(System.Data.DataTableClearEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableClearing (e As DataTableClearEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableClearing(System::Data::DataTableClearEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTableClearing : System.Data.DataTableClearEventArgs -&gt; unit&#xA;override this.OnTableClearing : System.Data.DataTableClearEventArgs -&gt; unit" Usage="dataTable.OnTableClearing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableClearEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Data.DataTableClearEventArgs" />。</param>
        <summary>
          <see cref="E:System.Data.DataTable.TableClearing" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 発生させる、<xref:System.Data.DataTable.TableClearing>の処理の前に発生するイベント、<xref:System.Data.DataTable.Clear%2A>操作を開始します。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 概要については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable イベントの処理</related>
      </Docs>
    </Member>
    <Member MemberName="OnTableNewRow">
      <MemberSignature Language="C#" Value="protected virtual void OnTableNewRow (System.Data.DataTableNewRowEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableNewRow(class System.Data.DataTableNewRowEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableNewRow(System.Data.DataTableNewRowEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableNewRow (e As DataTableNewRowEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableNewRow(System::Data::DataTableNewRowEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTableNewRow : System.Data.DataTableNewRowEventArgs -&gt; unit&#xA;override this.OnTableNewRow : System.Data.DataTableNewRowEventArgs -&gt; unit" Usage="dataTable.OnTableNewRow e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableNewRowEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Data.DataTableNewRowEventArgs" />。</param>
        <summary>
          <see cref="E:System.Data.DataTable.TableNewRow" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 発生させる、<xref:System.Data.DataTable.TableNewRow>新しいの後に発生するイベント、<xref:System.Data.DataRow>を使用して作成された<xref:System.Data.DataTable.NewRow%2A>。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 概要については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable イベントの処理</related>
      </Docs>
    </Member>
    <Member MemberName="ParentRelations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection ParentRelations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection ParentRelations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ParentRelations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ParentRelations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ ParentRelations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ParentRelations : System.Data.DataRelationCollection" Usage="System.Data.DataTable.ParentRelations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableParentRelationsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.Data.DataTable" /> の親リレーションシップのコレクションを取得します。</summary>
        <value>テーブルの親リレーションを格納している <see cref="T:System.Data.DataRelationCollection" />。 <see cref="T:System.Data.DataRelation" /> オブジェクトが存在しない場合、空のコレクションが返されます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、<xref:System.Data.DataTable.ParentRelations%2A>プロパティを返す各親<xref:System.Data.DataRelation>で、<xref:System.Data.DataTable>します。 各リレーションシップは、引数として使用し、<xref:System.Data.DataRow.GetParentRows%2A>のメソッド、<xref:System.Data.DataRow>行の配列を返します。 行の各列の値が出力されます。  
  
 [!code-csharp[Classic WebData DataTable.ParentRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ParentRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ParentRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ParentRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.ChildRelations" />
        <altmember cref="T:System.Data.DataRelation" />
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="P:System.Data.DataSet.Relations" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public string Prefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Prefix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string with get, set" Usage="System.Data.DataTable.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTablePrefixDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataTable" /> に格納されているデータの XML 表現の名前空間を取得または設定します。</summary>
        <value>
          <see cref="T:System.Data.DataTable" /> のプリフィックス。</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="PrimaryKey">
      <MemberSignature Language="C#" Value="public System.Data.DataColumn[] PrimaryKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataColumn[] PrimaryKey" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.PrimaryKey" />
      <MemberSignature Language="VB.NET" Value="Public Property PrimaryKey As DataColumn()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Data::DataColumn ^&gt; ^ PrimaryKey { cli::array &lt;System::Data::DataColumn ^&gt; ^ get(); void set(cli::array &lt;System::Data::DataColumn ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrimaryKey : System.Data.DataColumn[] with get, set" Usage="System.Data.DataTable.PrimaryKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Data.PrimaryKeyTypeConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTablePrimaryKeyDescr")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumn[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このデータ テーブルの主キーとして機能する列の配列を取得または設定します。</summary>
        <value>
          <see cref="T:System.Data.DataColumn" /> オブジェクトの配列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 テーブルの主キーは、テーブル内のレコードを識別するために一意である必要があります。 2 つ以上の列から成る主キーを持つテーブルを作成することもできます。 これは、1 つの列が一意の値を含めることはできませんと発生します。 たとえば、"FirstName"と"LastName"の列の 2 つの列の主キーから構成されます。 主キーは、1 つ以上の列確立できなかったため、<xref:System.Data.DataTable.PrimaryKey%2A>プロパティの配列から成る<xref:System.Data.DataColumn>オブジェクト。  
  
   
  
## Examples  
 最初の例の主キー列を返す方法を示しています、<xref:System.Data.DataTable>に表示される、`DataGrid`します。 2 番目の例は、主キー列を設定する方法を示します、<xref:System.Data.DataTable>します。  
  
 [!code-csharp[Classic WebData DataTable.PrimaryKey Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.PrimaryKey Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.PrimaryKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.PrimaryKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.DataException">キーが外部キーです。</exception>
        <altmember cref="T:System.Data.DataColumn" />
        <altmember cref="P:System.Data.DataTable.PrimaryKey" />
        <altmember cref="T:System.Data.DataColumnCollection" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>XML スキーマとデータを <see cref="T:System.Data.DataTable" /> に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.ReadXml%2A>メソッドを提供するだけ、いずれかのデータを読み取る方法またはデータとスキーマの両方に、 <xref:System.Data.DataTable> 、XML ドキュメントからは、<xref:System.Data.DataTable.ReadXmlSchema%2A>メソッドは、スキーマのみを読み取ります。 データとスキーマの両方を読み取りのいずれかの操作を使用して、`ReadXML`オーバー ロードが含まれる、`XmlReadMode`パラメーター、その値に設定し、 `ReadSchema`。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataTable.WriteXml%2A>と<xref:System.Data.DataTable.WriteXmlSchema%2A>メソッドでは、それぞれします。 XML データ、または両方のスキーマとデータを書き込む、`DataTable`を使用して、`WriteXml`メソッド。 スキーマだけを作成するには、使用、`WriteXmlSchema`メソッド。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合、列の型がスローされます、`DataRow`から読み取りまたは実装に書き込まれる<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装しない<xref:System.Xml.Serialization.IXmlSerializable>します。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.ReadXml" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.Stream -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" /> から派生するオブジェクト。</param>
        <summary>指定した <see cref="T:System.Data.DataTable" /> を使用して、XML スキーマとデータを <see cref="T:System.IO.Stream" /> に読み込みます。</summary>
        <returns>データを読み込むために使用する <see cref="T:System.Data.XmlReadMode" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在<xref:System.Data.DataTable>とその子孫が、指定したデータを読み込まれる<xref:System.IO.Stream>します。 このメソッドの動作のと同じですが、<xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType>この場合、データを除く、メソッドが、現在のテーブルとその子孫に対してのみ読み込まれます。  
  
 <xref:System.Data.DataTable.ReadXml%2A>メソッドを提供するだけ、いずれかのデータを読み取る方法またはデータとスキーマの両方に、 <xref:System.Data.DataTable> 、XML ドキュメントからは、<xref:System.Data.DataTable.ReadXmlSchema%2A>メソッドは、スキーマのみを読み取ります。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataTable.WriteXml%2A>と<xref:System.Data.DataTable.WriteXmlSchema%2A>メソッドでは、それぞれします。 XML データ、または両方のスキーマとデータを書き込む、`DataTable`を使用して、`WriteXml`メソッド。 スキーマだけを作成するには、使用、`WriteXmlSchema`メソッド。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合、列の型がスローされます、`DataRow`から読み取りまたは実装に書き込まれる<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装しない<xref:System.Xml.Serialization.IXmlSerializable>します。  
  
 インライン スキーマが指定されている場合、インライン スキーマは、データを読み込む前に既存のリレーショナル構造の拡張に使用されます。 競合 (たとえば、さまざまなデータ型で定義された同じテーブルで同じ列) がある場合は、例外が発生します。  
  
 インライン スキーマが指定されていない場合、リレーショナル構造は、XML ドキュメントの構造に従って、必要に応じて、推論によって拡張されます。 すべてのデータを公開するためには、推論でスキーマを拡張することはできません、例外が発生します。  
  
> [!NOTE]
>  `DataSet` 、対応する XML 要素に関連付けない`DataColumn`または`DataTable`場合 (「_」) のように有効な XML 文字がシリアル化された XML でエスケープされます。 `DataSet`自体のみ XML 要素の名前に無効な XML 文字をエスケープし、したがってのみ利用できる同じです。 XML 要素名の有効な文字はエスケープすると、処理中に、要素が無視されます。  
  
   
  
## Examples  
 次の例では、作成、 <xref:System.Data.DataTable> 2 つの列と 10 行を格納しています。 この例で、<xref:System.Data.DataTable>スキーマとデータを呼び出すことによって、メモリ ストリーム、<xref:System.Data.DataTable.WriteXml%2A>メソッド。 例では、1 秒あたりの作成<xref:System.Data.DataTable>を呼び出すと、<xref:System.Data.DataTable.ReadXml%2A>メソッドを呼び出してスキーマおよびデータを使用します。  
  
 [!code-csharp[DataWorks DataTable.ReadXml#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXml/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXml#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXml/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.TextReader -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">データを読み込むために使用する <see cref="T:System.IO.TextReader" />。</param>
        <summary>指定した <see cref="T:System.Data.DataTable" /> を使用して、XML スキーマとデータを <see cref="T:System.IO.TextReader" /> に読み込みます。</summary>
        <returns>データを読み込むために使用する <see cref="T:System.Data.XmlReadMode" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在<xref:System.Data.DataTable>とその子孫が、指定したデータを読み込まれる<xref:System.IO.TextReader>します。 このメソッドの動作のと同じですが、<xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType>この場合、データを除く、メソッドが、現在のテーブルとその子孫に対してのみ読み込まれます。  
  
 <xref:System.Data.DataTable.ReadXml%2A>メソッドを提供するだけ、いずれかのデータを読み取る方法またはデータとスキーマの両方に、 <xref:System.Data.DataTable> 、XML ドキュメントからは、<xref:System.Data.DataTable.ReadXmlSchema%2A>メソッドは、スキーマのみを読み取ります。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataTable.WriteXml%2A>と<xref:System.Data.DataTable.WriteXmlSchema%2A>メソッドでは、それぞれします。 XML データ、または両方のスキーマとデータを書き込む、`DataTable`を使用して、`WriteXml`メソッド。 スキーマだけを作成するには、使用、`WriteXmlSchema`メソッド。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合、列の型がスローされます、`DataRow`から読み取りまたは実装に書き込まれる<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装しない<xref:System.Xml.Serialization.IXmlSerializable>します。  
  
 インライン スキーマが指定されている場合、インライン スキーマは、データを読み込む前に既存のリレーショナル構造の拡張に使用されます。 競合 (たとえば、さまざまなデータ型で定義された同じテーブルで同じ列) がある場合は、例外が発生します。  
  
 インライン スキーマが指定されていない場合、リレーショナル構造は、XML ドキュメントの構造に従って、必要に応じて、推論によって拡張されます。 すべてのデータを公開するためには、推論でスキーマを拡張することはできません、例外が発生します。  
  
> [!NOTE]
>  `DataSet` 、対応する XML 要素に関連付けない`DataColumn`または`DataTable`場合 (「_」) のように有効な XML 文字がシリアル化された XML でエスケープされます。 `DataSet`自体のみ XML 要素の名前に無効な XML 文字をエスケープし、したがってのみ利用できる同じです。 XML 要素名の有効な文字はエスケープすると、処理中に、要素が無視されます。  
  
   
  
## Examples  
 次の例では、作成、 <xref:System.Data.DataTable> 2 つの列と 10 行を格納しています。 この例で、<xref:System.Data.DataTable>スキーマとデータを呼び出すことによって、メモリ ストリーム、<xref:System.Data.DataTable.WriteXml%2A>メソッド。 例では、1 秒あたりの作成<xref:System.Data.DataTable>を呼び出すと、<xref:System.Data.DataTable.ReadXml%2A>メソッドを呼び出してスキーマおよびデータを使用します。  
  
 [!code-csharp[DataWorks DataTable.ReadXmlText#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlText/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlText#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlText/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : string -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">データの読み取り元のファイルの名前。</param>
        <summary>指定したファイルから、XML スキーマとデータを <see cref="T:System.Data.DataTable" /> に読み込みます。</summary>
        <returns>データを読み込むために使用する <see cref="T:System.Data.XmlReadMode" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在<xref:System.Data.DataTable>と指定されたという名前のファイルからのデータとその子孫が読み込まれる<xref:System.String>します。 このメソッドの動作のと同じですが、<xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType>この場合、データを除く、メソッドが、現在のテーブルとその子孫に対してのみ読み込まれます。  
  
 <xref:System.Data.DataTable.ReadXml%2A>メソッドを提供するだけ、いずれかのデータを読み取る方法またはデータとスキーマの両方に、 <xref:System.Data.DataTable> 、XML ドキュメントからは、<xref:System.Data.DataTable.ReadXmlSchema%2A>メソッドは、スキーマのみを読み取ります。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataTable.WriteXml%2A>と<xref:System.Data.DataTable.WriteXmlSchema%2A>メソッドでは、それぞれします。 XML データ、または両方のスキーマとデータを書き込む、`DataTable`を使用して、`WriteXml`メソッド。 スキーマだけを作成するには、使用、`WriteXmlSchema`メソッド。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合、列の型がスローされます、`DataRow`から読み取りまたは実装に書き込まれる<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装しない<xref:System.Xml.Serialization.IXmlSerializable>します。  
  
 インライン スキーマが指定されている場合、インライン スキーマは、データを読み込む前に既存のリレーショナル構造の拡張に使用されます。 競合 (たとえば、さまざまなデータ型で定義された同じテーブルで同じ列) がある場合は、例外が発生します。  
  
 インライン スキーマが指定されていない場合、リレーショナル構造は、XML ドキュメントの構造に従って、必要に応じて、推論によって拡張されます。 すべてのデータを公開するためには、推論でスキーマを拡張することはできません、例外が発生します。  
  
> [!NOTE]
>  `DataSet` 、対応する XML 要素に関連付けない`DataColumn`または`DataTable`場合 (「_」) のように有効な XML 文字がシリアル化された XML でエスケープされます。 `DataSet`自体のみ XML 要素の名前に無効な XML 文字をエスケープし、したがってのみ利用できる同じです。 XML 要素名の有効な文字はエスケープすると、処理中に、要素が無視されます。  
  
```csharp  
using System.Data;  
public class A {  
   static void Main(string[] args) {  
      DataTable tabl = new DataTable("mytable");  
      tabl.Columns.Add(new DataColumn("id", typeof(int)));  
      for (int i = 0; i < 10; i++) {  
         DataRow row = tabl.NewRow();  
         row["id"] = i;  
         tabl.Rows.Add(row);  
      }  
      tabl.WriteXml("f.xml", XmlWriteMode.WriteSchema);  
      DataTable newt = new DataTable();  
      newt.ReadXml("f.xml");  
   }  
}  
```  
  
   
  
## Examples  
 次の例では、作成、 <xref:System.Data.DataTable> 2 つの列と 10 行を格納しています。 この例で、<xref:System.Data.DataTable>スキーマとデータ ディスクにします。 例では、1 秒あたりの作成<xref:System.Data.DataTable>を呼び出すと、<xref:System.Data.DataTable.ReadXml%2A>メソッドを呼び出してスキーマおよびデータを使用します。  
  
 [!code-csharp[DataWorks DataTable.ReadXmlString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.Xml.XmlReader -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">データを読み込むために使用する <see cref="T:System.Xml.XmlReader" />。</param>
        <summary>指定した <see cref="T:System.Data.DataTable" /> を使用して、XML スキーマとデータを <see cref="T:System.Xml.XmlReader" /> に読み込みます。</summary>
        <returns>データを読み込むために使用する <see cref="T:System.Data.XmlReadMode" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在<xref:System.Data.DataTable>と指定されたという名前のファイルからのデータとその子孫が読み込まれる<xref:System.Xml.XmlReader>します。 このメソッドの動作のと同じですが、<xref:System.Data.DataTable.ReadXml%2A>この場合、データを除く、メソッドが、現在のテーブルとその子孫に対してのみ読み込まれます。  
  
 <xref:System.Data.DataTable.ReadXml%2A>メソッドを提供するだけ、いずれかのデータを読み取る方法またはデータとスキーマの両方に、 <xref:System.Data.DataTable> 、XML ドキュメントからは、<xref:System.Data.DataTable.ReadXmlSchema%2A>メソッドは、スキーマのみを読み取ります。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataTable.WriteXml%2A>と<xref:System.Data.DataTable.WriteXmlSchema%2A>メソッドでは、それぞれします。 XML データ、または両方のスキーマとデータを書き込む、`DataTable`を使用して、`WriteXml`メソッド。 スキーマだけを作成するには、使用、`WriteXmlSchema`メソッド。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合、列の型がスローされます、`DataRow`から読み取りまたは実装に書き込まれる<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装しない<xref:System.Xml.Serialization.IXmlSerializable>します。  
  
 インライン スキーマが指定されている場合、インライン スキーマは、データを読み込む前に既存のリレーショナル構造の拡張に使用されます。 競合 (たとえば、さまざまなデータ型で定義された同じテーブルで同じ列) がある場合は、例外が発生します。  
  
 インライン スキーマが指定されていない場合、リレーショナル構造は、XML ドキュメントの構造に従って、必要に応じて、推論によって拡張されます。 すべてのデータを公開するためには、推論でスキーマを拡張することはできません、例外が発生します。  
  
> [!NOTE]
>  `DataSet` 、対応する XML 要素に関連付けない`DataColumn`または`DataTable`場合 (「_」) のように有効な XML 文字がシリアル化された XML でエスケープされます。 `DataSet`自体のみ XML 要素の名前に無効な XML 文字をエスケープし、したがってのみ利用できる同じです。 XML 要素名の有効な文字はエスケープすると、処理中に、要素が無視されます。  
  
   
  
## Examples  
 次の例では、作成、 <xref:System.Data.DataTable> 2 つの列と 10 行を格納しています。 この例で、<xref:System.Data.DataTable>スキーマとデータを<xref:System.Xml.XmlReader>します。 例では、1 秒あたりの作成<xref:System.Data.DataTable>を呼び出すと、<xref:System.Data.DataTable.ReadXml%2A>からスキーマとデータを格納する方法、<xref:System.Xml.XmlReader>インスタンス。  
  
 [!code-csharp[DataWorks DataTable.ReadXmlXmlReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlXmlReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlXmlReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlXmlReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>XML スキーマを <see cref="T:System.Data.DataTable" /> に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、`ReadXmlSchema`のスキーマを作成する方法、<xref:System.Data.DataTable>します。 スキーマには、テーブル、リレーションシップ、および制約の定義が含まれます。  
  
 XML ドキュメントにスキーマを書き込むには使用、<xref:System.Data.DataTable.WriteXmlSchema%2A>メソッド。  
  
 XML スキーマは XSD 標準に従って解釈されます。  
  
 `ReadXmlSchema`メソッドを呼び出す前に一般的に、<xref:System.Data.DataTable.ReadXml%2A>の塗りつぶしに使用するメソッド、<xref:System.Data.DataTable>します。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.ReadXmlSchema" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.Stream -&gt; unit" Usage="dataTable.ReadXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">スキーマを読み込むために使用するストリーム。</param>
        <summary>指定したストリームを使用して、XML スキーマを <see cref="T:System.Data.DataTable" /> に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Data.DataTable.ReadXmlSchema%2A>のスキーマを作成する方法、<xref:System.Data.DataTable>します。 スキーマには、テーブル、リレーションシップ、および制約の定義が含まれます。  
  
 XML ドキュメントにスキーマを書き込むには使用、<xref:System.Data.DataTable.WriteXmlSchema%2A>メソッド。  
  
 XML スキーマは XSD 標準に従って解釈されます。  
  
 データの破損は、msdata:DataType と xs:type 型が一致しない場合に発生することができます。 例外はスローされません。  
  
 `ReadXmlSchema`メソッドを呼び出す前に一般的に、<xref:System.Data.DataTable.ReadXml%2A>の塗りつぶしに使用するメソッド、<xref:System.Data.DataTable>します。  
  
 XML スキーマを使用して入れ子になったリレーションを作成するには、暗黙的な入れ子になった要素を使用します。 明示的な列名を使用して、入れ子の関係を構成することもできます。 要素は、対応するデータ テーブルを入れ子になった関係に参加させるために暗黙的に入れ子にする必要があります。  
  
   
  
## Examples  
 次のコンソール アプリケーションを作成する新しい<xref:System.Data.DataTable>、読み書きをするには、そのテーブルのスキーマ、<xref:System.IO.MemoryStream>します。 例が新たに作成し、<xref:System.Data.DataTable>し、保存された XML スキーマからそのスキーマを読み込みます。  
  
 [!code-csharp[DataWorks DataTable.ReadXmlIOStream#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlIOStream/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlIOStream#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlIOStream/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.TextReader -&gt; unit" Usage="dataTable.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">スキーマ情報を読み込むために使用する <see cref="T:System.IO.TextReader" />。</param>
        <summary>指定した <see cref="T:System.Data.DataTable" /> を使用して、XML スキーマを <see cref="T:System.IO.TextReader" /> に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Data.DataTable.ReadXmlSchema%2A>のスキーマを作成する方法、<xref:System.Data.DataTable>します。 スキーマには、テーブル、リレーションシップ、および制約の定義が含まれます。  
  
 XML ドキュメントにスキーマを書き込むには使用、<xref:System.Data.DataTable.WriteXmlSchema%2A>メソッド。  
  
 XML スキーマは XSD 標準に従って解釈されます。  
  
 データの破損は、msdata:DataType と xs:type 型が一致しない場合に発生することができます。 例外はスローされません。  
  
 `ReadXmlSchema`メソッドを呼び出す前に一般的に、<xref:System.Data.DataTable.ReadXml%2A>の塗りつぶしに使用するメソッド、<xref:System.Data.DataTable>します。  
  
 XML スキーマを使用して入れ子になったリレーションを作成するには、暗黙的な入れ子になった要素を使用します。 また、明示的な列名を使用する入れ子になったリレーションシップを再構成できます。 要素は、対応するデータ テーブルを入れ子になった関係に参加させるために暗黙的に入れ子にする必要があります。  
  
   
  
## Examples  
 次のコンソール アプリケーションを作成する新しい<xref:System.Data.DataTable>、読み書きをするには、そのテーブルのスキーマ、<xref:System.IO.MemoryStream>します。 例が新たに作成し、<xref:System.Data.DataTable>し、そのスキーマを保存された XML スキーマから読み取りを使用して、 <xref:System.IO.StreamReader> (から継承する<xref:System.IO.TextReader>) のソースとして。  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchema#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchema/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchema#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchema/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : string -&gt; unit" Usage="dataTable.ReadXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">スキーマ情報の読み取り元のファイルの名前。</param>
        <summary>指定したファイルから <see cref="T:System.Data.DataTable" /> に XML スキーマを読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Data.DataTable.ReadXmlSchema%2A>のスキーマを作成する方法、<xref:System.Data.DataTable>します。 スキーマには、テーブル、リレーションシップ、および制約の定義が含まれます。  
  
 XML ドキュメントにスキーマを書き込むには使用、<xref:System.Data.DataTable.WriteXmlSchema%2A>メソッド。  
  
 XML スキーマは XSD 標準に従って解釈されます。  
  
 データの破損は、msdata:DataType と xs:type 型が一致しない場合に発生することができます。 例外はスローされません。  
  
 `ReadXmlSchema`メソッドを呼び出す前に一般的に、<xref:System.Data.DataTable.ReadXml%2A>の塗りつぶしに使用するメソッド、`DataTable`します。  
  
 XML スキーマを使用して入れ子になったリレーションを作成するには、暗黙的な入れ子になった要素を使用します。 また、明示的な列名を使用する入れ子になったリレーションシップを再構成できます。 要素は、対応するデータ テーブルを入れ子になった関係に参加させるために暗黙的に入れ子にする必要があります。  
  
   
  
## Examples  
 次のコンソール アプリケーションを作成する新しい<xref:System.Data.DataTable>、し、そのテーブルのスキーマをファイルに書き込みます。 例が新たに作成し、<xref:System.Data.DataTable>し、そのソースとしてファイルを使用して、保存された XML スキーマからそのスキーマを読み込みます。  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchemaString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchemaString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.Xml.XmlReader -&gt; unit" Usage="dataTable.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">スキーマ情報を読み込むために使用する <see cref="T:System.Xml.XmlReader" />。</param>
        <summary>指定した <see cref="T:System.Data.DataTable" /> を使用して、XML スキーマを <see cref="T:System.Xml.XmlReader" /> に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Data.DataTable.ReadXmlSchema%2A>のスキーマを作成する方法、<xref:System.Data.DataTable>します。 スキーマには、テーブル、リレーションシップ、および制約の定義が含まれます。  
  
 XML ドキュメントにスキーマを書き込むには使用、<xref:System.Data.DataTable.WriteXmlSchema%2A>メソッド。  
  
 XML スキーマは XSD 標準に従って解釈されます。  
  
 データの破損は、msdata:DataType と xs:type 型が一致しない場合に発生することができます。 例外はスローされません。  
  
 `ReadXmlSchema`メソッドを呼び出す前に一般的に、<xref:System.Data.DataTable.ReadXml%2A>の塗りつぶしに使用するメソッド、<xref:System.Data.DataTable>します。  
  
> [!NOTE]
>  XML スキーマを使用して入れ子になったリレーションを作成する方法では、暗黙的な入れ子になった要素があります。 さらに、入れ子になったリレーションの再関連付けし、明示的な列名を使用する可能性があります。 要素は暗黙的に、入れ子の関係に参加する対応するデータ テーブルの入れ子にする必要があります。  
  
   
  
## Examples  
 次のコンソール アプリケーションを作成する新しい<xref:System.Data.DataTable>、読み書きをするには、そのテーブルのスキーマ、<xref:System.IO.MemoryStream>します。 例が新たに作成し、<xref:System.Data.DataTable>し、そのスキーマを保存された XML スキーマから読み取りを使用して、 <xref:System.Xml.XmlTextReader> (から継承する<xref:System.Xml.XmlReader>) のソースとして。  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchemaReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchemaReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSerializable">
      <MemberSignature Language="C#" Value="protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ReadXmlSerializable(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSerializable(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ReadXmlSerializable (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ReadXmlSerializable(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadXmlSerializable : System.Xml.XmlReader -&gt; unit&#xA;override this.ReadXmlSerializable : System.Xml.XmlReader -&gt; unit" Usage="dataTable.ReadXmlSerializable reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> オブジェクト。</param>
        <summary>XML ストリームから読み取ります。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RejectChanges">
      <MemberSignature Language="C#" Value="public void RejectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RejectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.RejectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub RejectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RejectChanges();" />
      <MemberSignature Language="F#" Value="member this.RejectChanges : unit -&gt; unit" Usage="dataTable.RejectChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このテーブルを読み込むか、前回 <see cref="M:System.Data.DataTable.AcceptChanges" /> を呼び出した以降にこのテーブルに対して行われたすべての変更をロールバックします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに<xref:System.Data.DataTable.RejectChanges%2A>が呼び出されると、いずれかの<xref:System.Data.DataRow>編集モードに残っているオブジェクトがそれらの編集をキャンセルします。 新しい行が削除されます。 行、<xref:System.Data.DataRowState>に設定`Modified`または`Deleted`元の状態に戻り値。  
  
   
  
## Examples  
 次の例でいくつかの変更、 <xref:System.Data.DataTable>、呼び出すことによって、変更を拒否が、<xref:System.Data.DataTable.RejectChanges%2A>メソッド。  
  
 [!code-csharp[Classic WebData DataTable.RejectChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RejectChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RejectChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RejectChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable イベントの処理</related>
      </Docs>
    </Member>
    <Member MemberName="RemotingFormat">
      <MemberSignature Language="C#" Value="public System.Data.SerializationFormat RemotingFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SerializationFormat RemotingFormat" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.RemotingFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property RemotingFormat As SerializationFormat" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SerializationFormat RemotingFormat { System::Data::SerializationFormat get(); void set(System::Data::SerializationFormat value); };" />
      <MemberSignature Language="F#" Value="member this.RemotingFormat : System.Data.SerializationFormat with get, set" Usage="System.Data.DataTable.RemotingFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SerializationFormat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>シリアル化形式を取得または設定します。</summary>
        <value>
          <see langword="Binary" /> シリアル化または <see langword="Xml" /> シリアル化を指定する <see cref="T:System.Data.SerializationFormat" /> 列挙体。</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="dataTable.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Data.DataTable" /> を元の状態にリセットします。 テーブルのすべてのデータ、インデックス、リレーションシップ、および列の削除をリセットします。 DataSet に DataTable が含まれている場合は、テーブルをリセットした後も、テーブルは DataSet の一部です。</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable イベントの処理</related>
      </Docs>
    </Member>
    <Member MemberName="RowChanged">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowChanged" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowChanged As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowChanged;" />
      <MemberSignature Language="F#" Value="member this.RowChanged : System.Data.DataRowChangeEventHandler " Usage="member this.RowChanged : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowChangedDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataRow" /> が正常に変更された後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 詳細については、次を参照してください。 [DataTable イベントの処理](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)します。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowChanged Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanged Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="RowChanging">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowChanging" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowChanging As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowChanging;" />
      <MemberSignature Language="F#" Value="member this.RowChanging : System.Data.DataRowChangeEventHandler " Usage="member this.RowChanging : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowChangingDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataRow" /> が変更されているときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 詳細については、次を参照してください。 [DataTable イベントの処理](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)します。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowChanging Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanging Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowChanging Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanging Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="RowDeleted">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowDeleted" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowDeleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowDeleted As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowDeleted;" />
      <MemberSignature Language="F#" Value="member this.RowDeleted : System.Data.DataRowChangeEventHandler " Usage="member this.RowDeleted : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowDeletedDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>テーブル内の行が削除された後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 詳細については、次を参照してください。 [DataTable イベントの処理](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)します。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowDeleted Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleted Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowDeleted Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleted Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="RowDeleting">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowDeleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowDeleting" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowDeleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowDeleting As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowDeleting;" />
      <MemberSignature Language="F#" Value="member this.RowDeleting : System.Data.DataRowChangeEventHandler " Usage="member this.RowDeleting : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowDeletingDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>テーブル内の行が削除される直前に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 詳細については、次を参照してください。 [DataTable イベントの処理](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)します。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowDeleting Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleting Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowDeleting Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleting Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="Rows">
      <MemberSignature Language="C#" Value="public System.Data.DataRowCollection Rows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRowCollection Rows" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Rows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rows As DataRowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRowCollection ^ Rows { System::Data::DataRowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Rows : System.Data.DataRowCollection" Usage="System.Data.DataTable.Rows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このテーブルに属する行のコレクションを取得します。</summary>
        <value>
          <see cref="T:System.Data.DataRowCollection" /> オブジェクトが格納されている <see cref="T:System.Data.DataRow" />。<see cref="T:System.Data.DataRow" /> オブジェクトが存在しない場合は null 値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新たに作成する<xref:System.Data.DataRow>、使用する必要があります、<xref:System.Data.DataTable.NewRow%2A>新しいオブジェクトを返すメソッド。 このようなオブジェクトが自動的に構成に定義されたスキーマに従って、<xref:System.Data.DataTable>のコレクションを<xref:System.Data.DataColumn>オブジェクト。 新しい行を作成し、行の各列の値を設定した後に行を追加、<xref:System.Data.DataRowCollection>を使用して、`Add`メソッド。  
  
 各<xref:System.Data.DataRow>コレクション内には、テーブル内のデータの行を表します。 行内の列の値に変更をコミットするを呼び出す必要があります、<xref:System.Data.DataTable.AcceptChanges%2A>メソッド。  
  
   
  
## Examples  
 設定する行を返し、2 つの例を次に示します。 最初の例では、<xref:System.Data.DataTable.Rows%2A>プロパティを行ごとに各列の値を出力します。 2 番目の例では、<xref:System.Data.DataTable>オブジェクトの<xref:System.Data.DataTable.NewRow%2A>新たに作成するメソッド<xref:System.Data.DataRow>のスキーマ オブジェクトを<xref:System.Data.DataTable>します。 行を追加する行の値を設定した後、<xref:System.Data.DataRowCollection>を通じて、`Add`メソッド。  
  
 [!code-csharp[Classic WebData DataTable.Rows Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Rows Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Rows Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Rows Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.AcceptChanges" />
        <altmember cref="T:System.Data.DataRow" />
        <altmember cref="T:System.Data.DataRowCollection" />
        <altmember cref="M:System.Data.DataTable.NewRow" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Select">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataRow" /> オブジェクトの配列を取得します。</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select" />
      <MemberSignature Language="VB.NET" Value="Public Function Select () As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select();" />
      <MemberSignature Language="F#" Value="member this.Select : unit -&gt; System.Data.DataRow[]" Usage="dataTable.Select " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>すべての <see cref="T:System.Data.DataRow" /> オブジェクトの配列を取得します。</summary>
        <returns>
          <see cref="T:System.Data.DataRow" /> オブジェクトの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 適切な並べ替え順序を確実での並べ替え条件の指定<xref:System.Data.DataTable.Select%2A>または<xref:System.Data.DataTable.Select%2A>します。  
  
   
  
## Examples  
 次の例の配列を返します<xref:System.Data.DataRow>オブジェクトを通じて、<xref:System.Data.DataTable.Select%2A>メソッド。  
  
 [!code-csharp[Classic WebData DataTable.Select Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=191549">null 値</related>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression);" />
      <MemberSignature Language="F#" Value="member this.Select : string -&gt; System.Data.DataRow[]" Usage="dataTable.Select filterExpression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterExpression">行にフィルターをかけるために使用する基準。 行をフィルター処理する方法の例については、「[DataView RowFilter の構文 [C#]](https://www.csharp-examples.net/dataview-rowfilter/)」を参照してください。</param>
        <summary>フィルター基準と一致するすべての <see cref="T:System.Data.DataRow" /> オブジェクトの配列を取得します。</summary>
        <returns>
          <see cref="T:System.Data.DataRow" /> オブジェクトの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 作成する、`filterExpression`引数に適用される同じ規則を使用して、<xref:System.Data.DataColumn>クラスの<xref:System.Data.DataColumn.Expression%2A>フィルターを作成するためのプロパティの値。  
  
 適切な並べ替え順序を確実での並べ替え条件の指定<xref:System.Data.DataTable.Select%2A>または<xref:System.Data.DataTable.Select%2A>します。  
  
 フィルターの列に null 値が含まれている場合、結果の一部をされません。  
  
   
  
## Examples  
 次の例では、フィルター式を使用して、配列を返す<xref:System.Data.DataRow>オブジェクト。  
  
 [!code-csharp[Classic WebData DataTable.Select1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=191549">null 値</related>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression, string sort);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression, string sort) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String, sort As String) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression, System::String ^ sort);" />
      <MemberSignature Language="F#" Value="member this.Select : string * string -&gt; System.Data.DataRow[]" Usage="dataTable.Select (filterExpression, sort)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
        <Parameter Name="sort" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterExpression">行にフィルターをかけるために使用する基準。 行をフィルター処理する方法の例については、「[DataView RowFilter の構文 [C#]](https://www.csharp-examples.net/dataview-rowfilter/)」を参照してください。</param>
        <param name="sort">列と並べ替え方向を指定する文字列。</param>
        <summary>フィルター基準と一致するすべての <see cref="T:System.Data.DataRow" /> オブジェクトの配列を、指定した並べ替え順で取得します。</summary>
        <returns>フィルター式と一致する <see cref="T:System.Data.DataRow" /> オブジェクトの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フォームに、`filterExpression`引数を作成するため、同じ規則を使用して、<xref:System.Data.DataColumn>クラスの<xref:System.Data.DataColumn.Expression%2A>プロパティの値。 `Sort`引数は、クラスの作成に同じ規則を使用するも<xref:System.Data.DataColumn.Expression%2A>文字列。  
  
 フィルターの列に null 値が含まれている場合、結果の一部をされません。  
  
   
  
## Examples  
 次の例では、フィルター式を使用して、配列を返す<xref:System.Data.DataRow>オブジェクト。  
  
 [!code-csharp[Classic WebData DataTable.Select2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=191549">null 値</related>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression, string sort, System.Data.DataViewRowState recordStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression, string sort, valuetype System.Data.DataViewRowState recordStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String, sort As String, recordStates As DataViewRowState) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression, System::String ^ sort, System::Data::DataViewRowState recordStates);" />
      <MemberSignature Language="F#" Value="member this.Select : string * string * System.Data.DataViewRowState -&gt; System.Data.DataRow[]" Usage="dataTable.Select (filterExpression, sort, recordStates)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
        <Parameter Name="sort" Type="System.String" />
        <Parameter Name="recordStates" Type="System.Data.DataViewRowState" />
      </Parameters>
      <Docs>
        <param name="filterExpression">行にフィルターをかけるために使用する基準。 行をフィルター処理する方法の例については、「[DataView RowFilter の構文 [C#]](https://www.csharp-examples.net/dataview-rowfilter/)」を参照してください。</param>
        <param name="sort">列と並べ替え方向を指定する文字列。</param>
        <param name="recordStates">
          <see cref="T:System.Data.DataViewRowState" /> 値のいずれか 1 つ。</param>
        <summary>フィルター基準と一致するすべての <see cref="T:System.Data.DataRow" /> オブジェクトの配列を、指定した状態と一致する並べ替え順に取得します。</summary>
        <returns>
          <see cref="T:System.Data.DataRow" /> オブジェクトの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フォームに、`filterExpression`引数を作成するため、同じ規則を使用して、<xref:System.Data.DataColumn>クラスの<xref:System.Data.DataColumn.Expression%2A>プロパティの値。 `Sort`引数は、クラスの作成に同じ規則を使用するも<xref:System.Data.DataColumn.Expression%2A>文字列。  
  
 フィルターの列に null 値が含まれている場合、結果の一部をされません。  
  
   
  
## Examples  
 次の例では、フィルター式とレコードの状態を使用して、配列を返します<xref:System.Data.DataRow>オブジェクト。  
  
 [!code-csharp[Classic WebData DataTable.Select3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=191549">null 値</related>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Data.DataTable.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.ComponentModel.ISite" /> の <see cref="T:System.Data.DataTable" /> を取得または設定します。</summary>
        <value>
          <see cref="T:System.ComponentModel.ISite" /> の <see cref="T:System.Data.DataTable" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サイト バインドを<xref:System.ComponentModel.Component>を<xref:System.ComponentModel.Container>と、それらの間の通信を有効にするだけでなく、コンテナーは、そのコンポーネントを管理する方法を提供します。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System::ComponentModel::IListSource::ContainsListCollection { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />」をご覧ください。</summary>
        <value>コレクションが <see cref="T:System.Collections.IList" /> オブジェクトのコレクションである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Data.DataTable> のインスタンスが <xref:System.ComponentModel.IListSource> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="M:System.ComponentModel.IListSource.GetList" />」をご覧ください。</summary>
        <returns>オブジェクトからデータ ソースに連結できる <see cref="T:System.Collections.IList" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Data.DataTable> のインスタンスが <xref:System.ComponentModel.IListSource> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> オブジェクト。</param>
        <param name="context">
          <see cref="T:System.Runtime.Serialization.StreamingContext" /> オブジェクト。</param>
        <summary>シリアル化情報オブジェクトを、<see cref="T:System.Data.DataTable" /> のシリアル化に必要なデータで事前設定します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberSignature Language="VB.NET" Value="Function GetSchema () As XmlSchema Implements IXmlSerializable.GetSchema" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Xml::Schema::XmlSchema ^ System.Xml.Serialization.IXmlSerializable.GetSchema() = System::Xml::Serialization::IXmlSerializable::GetSchema;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />」をご覧ください。</summary>
        <returns>
          <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> メソッドによって生成され <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /> メソッドによって処理されるオブジェクトの XML 表現を記述する <see cref="T:System.Xml.Schema.XmlSchema" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Data.DataSet> のインスタンスが <xref:System.Xml.Serialization.IXmlSerializable> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Sub ReadXml (reader As XmlReader) Implements IXmlSerializable.ReadXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.ReadXml(System::Xml::XmlReader ^ reader) = System::Xml::Serialization::IXmlSerializable::ReadXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">XmlReader。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />」をご覧ください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Data.DataSet> のインスタンスが <xref:System.Xml.Serialization.IXmlSerializable> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Sub WriteXml (writer As XmlWriter) Implements IXmlSerializable.WriteXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.WriteXml(System::Xml::XmlWriter ^ writer) = System::Xml::Serialization::IXmlSerializable::WriteXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">XmlWriter。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />」をご覧ください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Data.DataSet> のインスタンスが <xref:System.Xml.Serialization.IXmlSerializable> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableCleared">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableClearEventHandler TableCleared;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableClearEventHandler TableCleared" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableCleared" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableCleared As DataTableClearEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableClearEventHandler ^ TableCleared;" />
      <MemberSignature Language="F#" Value="member this.TableCleared : System.Data.DataTableClearEventHandler " Usage="member this.TableCleared : System.Data.DataTableClearEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableClearEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataTable" /> が消去された後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.TableCleared>すぐにすべての行が削除された後正常にする前に、イベントが発生した、<xref:System.Data.DataTable.Clear%2A>メソッドが呼び出し元にコントロールを返します。 <xref:System.Data.DataTable.TableCleared>消去操作中に例外がある場合、イベントは発生しません。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable イベントの処理</related>
      </Docs>
    </Member>
    <Member MemberName="TableClearing">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableClearEventHandler TableClearing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableClearEventHandler TableClearing" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableClearing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableClearing As DataTableClearEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableClearEventHandler ^ TableClearing;" />
      <MemberSignature Language="F#" Value="member this.TableClearing : System.Data.DataTableClearEventHandler " Usage="member this.TableClearing : System.Data.DataTableClearEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableClearEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataTable" /> が削除されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.TableClearing>の処理の前にイベントが発生した、<xref:System.Data.DataTable.Clear%2A>操作を開始します。 このイベントがときに発生することは常に、<xref:System.Data.DataTable.Clear%2A>テーブルには、0 行が含まれている場合でも、メソッドが呼び出されます。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable イベントの処理</related>
      </Docs>
    </Member>
    <Member MemberName="TableName">
      <MemberSignature Language="C#" Value="public string TableName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TableName" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.TableName" />
      <MemberSignature Language="VB.NET" Value="Public Property TableName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TableName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TableName : string with get, set" Usage="System.Data.DataTable.TableName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableTableNameDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataTable" /> の名前を取得または設定します。</summary>
        <value>
          <see cref="T:System.Data.DataTable" /> の名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.TableName%2A>親からこのテーブルを返すために使用<xref:System.Data.DataSet>オブジェクトの<xref:System.Data.DataTableCollection>(によって返される、<xref:System.Data.DataSet.Tables%2A>プロパティ)。  
  
   
  
## Examples  
 次の例では、印刷、<xref:System.Data.DataTable.TableName%2A>のコレクション内の各テーブルの<xref:System.Data.DataTable>オブジェクト。  
  
 [!code-csharp[Classic WebData DataTable.TableName Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.TableName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.TableName Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.TableName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see langword="null" /> または空の文字列 ("") が渡され、このテーブルはコレクションに属します。</exception>
        <exception cref="T:System.Data.DuplicateNameException">テーブルが属しているコレクションに、同じ名前のテーブルが既に含まれています。 比較では、大文字と小文字が区別されます。</exception>
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="P:System.Data.DataSet.Tables" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="TableNewRow">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableNewRowEventHandler TableNewRow;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableNewRowEventHandler TableNewRow" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableNewRow" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableNewRow As DataTableNewRowEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableNewRowEventHandler ^ TableNewRow;" />
      <MemberSignature Language="F#" Value="member this.TableNewRow : System.Data.DataTableNewRowEventHandler " Usage="member this.TableNewRow : System.Data.DataTableNewRowEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableNewRowEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>新しい <see cref="T:System.Data.DataRow" /> が挿入されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新しいの後に発生<xref:System.Data.DataRow>を使用して作成された<xref:System.Data.DataTable.NewRow%2A>します。 このイベントが発生する前に、呼び出された`NewRow`メソッドを返します。 新しい<xref:System.Data.DataRow>インスタンスがデタッチは、コレクションに追加されていません。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable イベントの処理</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="dataTable.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="P:System.Data.DataTable.TableName" /> と <see cref="P:System.Data.DataTable.DisplayExpression" /> が連結された文字列として存在する場合は、これらを取得します。</summary>
        <returns>
          <see cref="P:System.Data.DataTable.TableName" /> と <see cref="P:System.Data.DataTable.DisplayExpression" /> 値で構成された文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 取得、<xref:System.Data.DataTable.TableName%2A>と<xref:System.Data.DataTable.DisplayExpression%2A>の<xref:System.Data.DataTable>します。  
  
   
  
## Examples  
 次の例を返します、<xref:System.Data.DataTable.TableName%2A>と<xref:System.Data.DataTable.DisplayExpression%2A>を使用して、<xref:System.Data.DataTable.ToString%2A>メソッド。  
  
 [!code-csharp[Classic WebData DataTable.ToString Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ToString Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ToString Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ToString Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataTable" /> の現在の内容を XML として書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> 、いずれかのデータのみを記述する方法またはデータとスキーマの両方からメソッドを提供します、 <xref:System.Data.DataTable> XML ドキュメントに対し、<xref:System.Data.DataTable.WriteXmlSchema%2A>メソッドは、スキーマのみを書き込みます。 データとスキーマの両方を含むオーバー ロードのいずれかを使用して、<xref:System.Data.XmlWriteMode>パラメーター、その値に設定し、 `WriteSchema`。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataTable.ReadXml%2A>と<xref:System.Data.DataTable.ReadXmlSchema%2A>メソッドでは、それぞれします。 XML データ、または両方のスキーマとにデータを読み取る、`DataTable`を使用して、`ReadXml`メソッド。 スキーマだけを読み取り、使用、`ReadXmlSchema`メソッド。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合、列の型がスローされます、`DataRow`から読み取りまたは実装に書き込まれる<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装しない<xref:System.Xml.Serialization.IXmlSerializable>します。  
  
   
  
## Examples  
 次のコンソール アプリケーションでは、2 つ作成されます<xref:System.Data.DataTable>インスタンスを追加します、 <xref:System.Data.DataSet>、作成、<xref:System.Data.DataRelation>テーブル、および使用して、関連する 2 つ、 <xref:System.Data.DataTable.WriteXml%2A> に親テーブル内のデータを書き込むメソッド<xref:System.IO.TextWriter>. 設定するときに、例を示します、動作、`writeHierarchy`にその値の各パラメーター。  
  
> [!NOTE]
>  この例では、WriteXml のオーバー ロードされたバージョンのいずれかを使用する方法を示します。 使用可能な可能性があるその他の例は、個々 のオーバー ロードのトピックを参照してください。  
  
 [!code-csharp[DataWorks DataTable.WriteXmlOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlOverload/VB/source.vb#1)]  
  
 この例では、次の出力がコンソール ウィンドウに表示されます。  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
</NewDataSet>  
==============================  
Customer table, with hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
          <xs:element name="Table2">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="OrderID" type="xs:int" />  
                <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
                <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
      <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" m  
sdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="OrderID" />  
      </xs:unique>  
      <xs:keyref name="CustomerOrder" refer="Constraint1">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="CustomerID" />  
      </xs:keyref>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
  <Table2>  
    <OrderID>1</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>2</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>3</OrderID>  
    <CustomerID>2</CustomerID>  
    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>4</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>5</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>6</OrderID>  
    <CustomerID>4</CustomerID>  
    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
</NewDataSet>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream -&gt; unit" Usage="dataTable.WriteXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">データが書き込まれるストリーム。</param>
        <summary>
          <see cref="T:System.Data.DataTable" /> の現在の内容を指定された <see cref="T:System.IO.Stream" /> を使用して XML として書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> 、いずれかのデータのみを記述する方法またはデータとスキーマの両方からメソッドを提供します、 <xref:System.Data.DataTable> XML ドキュメントに対し、<xref:System.Data.DataTable.WriteXmlSchema%2A>メソッドは、スキーマのみを書き込みます。 データとスキーマの両方を作成するを含むオーバー ロードのいずれかを使用、<xref:System.Data.XmlWriteMode>パラメーターに値を設定および`WriteSchema`します。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataTable.ReadXml%2A>と<xref:System.Data.DataTable.ReadXmlSchema%2A>メソッドでは、それぞれします。 XML データ、または両方のスキーマとにデータを読み取る、`DataTable`を使用して、`ReadXml`メソッド。 スキーマだけを読み取り、使用、`ReadXmlSchema`メソッド。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合、列の型がスローされます、`DataRow`から読み取りまたは実装に書き込まれる<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装しない<xref:System.Xml.Serialization.IXmlSerializable>します。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter -&gt; unit" Usage="dataTable.WriteXml writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">内容を書き込む対象の <see cref="T:System.IO.TextWriter" />。</param>
        <summary>
          <see cref="T:System.Data.DataTable" /> の現在の内容を指定された <see cref="T:System.IO.TextWriter" /> を使用して XML として書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> 、いずれかのデータのみを記述する方法またはデータとスキーマの両方からメソッドを提供します、 <xref:System.Data.DataTable> XML ドキュメントに対し、<xref:System.Data.DataTable.WriteXmlSchema%2A>メソッドは、スキーマのみを書き込みます。 データとスキーマの両方を作成するを含むオーバー ロードのいずれかを使用、<xref:System.Data.XmlWriteMode>パラメーターに値を設定および`WriteSchema`します。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataTable.ReadXml%2A>と<xref:System.Data.DataTable.ReadXmlSchema%2A>メソッドでは、それぞれします。 XML データ、または両方のスキーマとにデータを読み取る、`DataTable`を使用して、`ReadXml`メソッド。 スキーマだけを読み取り、使用、`ReadXmlSchema`メソッド。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合、列の型がスローされます、`DataRow`から読み取りまたは実装に書き込まれる<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装しない<xref:System.Xml.Serialization.IXmlSerializable>します。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string -&gt; unit" Usage="dataTable.WriteXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">XML データの書き込み先ファイル。</param>
        <summary>指定したファイルを使用して <see cref="T:System.Data.DataTable" /> の現在の内容を XML で書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> 、いずれかのデータのみを記述する方法またはデータとスキーマの両方からメソッドを提供します、 <xref:System.Data.DataTable> XML ドキュメントに対し、<xref:System.Data.DataTable.WriteXmlSchema%2A>メソッドは、スキーマのみを書き込みます。 データとスキーマの両方を作成するを含むオーバー ロードのいずれかを使用、<xref:System.Data.XmlWriteMode>パラメーターに値を設定および`WriteSchema`します。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataTable.ReadXml%2A>と<xref:System.Data.DataTable.ReadXmlSchema%2A>メソッドでは、それぞれします。 XML データ、または両方のスキーマとにデータを読み取る、`DataTable`を使用して、`ReadXml`メソッド。 スキーマだけを読み取り、使用、`ReadXmlSchema`メソッド。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合、列の型がスローされます、`DataRow`から読み取りまたは実装に書き込まれる<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装しない<xref:System.Xml.Serialization.IXmlSerializable>します。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter -&gt; unit" Usage="dataTable.WriteXml writer" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">内容の書き込みに使用する <see cref="T:System.Xml.XmlWriter" />。</param>
        <summary>
          <see cref="T:System.Data.DataTable" /> の現在の内容を指定された <see cref="T:System.Xml.XmlWriter" /> を使用して XML として書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> 、いずれかのデータのみを記述する方法またはデータとスキーマの両方からメソッドを提供します、 <xref:System.Data.DataTable> XML ドキュメントに対し、<xref:System.Data.DataTable.WriteXmlSchema%2A>メソッドは、スキーマのみを書き込みます。 データとスキーマの両方を含むオーバー ロードのいずれかを使用して、<xref:System.Data.XmlWriteMode>パラメーター、その値に設定し、 `WriteSchema`。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataTable.ReadXml%2A>と<xref:System.Data.DataTable.ReadXmlSchema%2A>メソッドでは、それぞれします。 XML データ、または両方のスキーマとにデータを読み取る、`DataTable`を使用して、`ReadXml`メソッド。 スキーマだけを読み取り、使用、`ReadXmlSchema`メソッド。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合、列の型がスローされます、`DataRow`から読み取りまたは実装に書き込まれる<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装しない<xref:System.Xml.Serialization.IXmlSerializable>します。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * bool -&gt; unit" Usage="dataTable.WriteXml (stream, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">データが書き込まれるストリーム。</param>
        <param name="writeHierarchy">
          <see langword="true" /> の場合は、現在のテーブルとその子孫の内容を書き込みます。 <see langword="false" /> (既定値) の場合は、現在のテーブルのデータのみを書き込みます。</param>
        <summary>
          <see cref="T:System.Data.DataTable" /> の現在の内容を指定された <see cref="T:System.IO.Stream" /> を使用して XML として書き込みます。 テーブルのデータとその子孫をすべて保存するには、<paramref name="writeHierarchy" /> パラメーターを <see langword="true" /> に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Data.DataTable.WriteXmlSchema%2A>のスキーマを記述するメソッド、 <xref:System.Data.DataTable> XML ドキュメントにします。 スキーマには、テーブル、リレーションシップ、および制約の定義が含まれます。  
  
 XML スキーマでは、XSD 標準を使用して書き込まれます。  
  
 XML ドキュメントに、データの書き込みに使用して、<xref:System.Data.DataTable.WriteXml%2A>メソッド。  
  
 通常、`WriteXml`メソッドは、現在のテーブルのみデータを書き込みます。 現在のテーブルとその子孫でのすべてのデータの書き込みに関連するテーブルでメソッドを呼び出し、`writeHierarchy`パラメーターに設定`true`します。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合、列の型がスローされます、`DataRow`から読み取りまたは実装に書き込まれる<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装しない<xref:System.Xml.Serialization.IXmlSerializable>します。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (stream, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="stream">データが書き込まれるストリーム。</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 値のいずれか 1 つ。</param>
        <summary>指定した <see cref="T:System.Data.DataTable" /> を使用して、<see cref="T:System.Data.XmlWriteMode" /> の現在のデータを、指定したファイルに書き込みます。オプションでスキーマを書き込むこともできます。 スキーマを書き込むには、<paramref name="mode" /> パラメーターの値を <see langword="WriteSchema" /> に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> 、いずれかのデータのみを記述する方法またはデータとスキーマの両方からメソッドを提供します、 <xref:System.Data.DataTable> XML ドキュメントに対し、<xref:System.Data.DataTable.WriteXmlSchema%2A>メソッドは、スキーマのみを書き込みます。 データとスキーマの両方を作成するを含むオーバー ロードのいずれかを使用、<xref:System.Data.XmlWriteMode>パラメーターに値を設定および`WriteSchema`します。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataTable.ReadXml%2A>と<xref:System.Data.DataTable.ReadXmlSchema%2A>メソッドでは、それぞれします。 XML データ、または両方のスキーマとにデータを読み取る、`DataTable`を使用して、`ReadXml`メソッド。 スキーマだけを読み取り、使用、`ReadXmlSchema`メソッド。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合、列の型がスローされます、`DataRow`から読み取りまたは実装に書き込まれる<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装しない<xref:System.Xml.Serialization.IXmlSerializable>します。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * bool -&gt; unit" Usage="dataTable.WriteXml (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">内容を書き込む対象の <see cref="T:System.IO.TextWriter" />。</param>
        <param name="writeHierarchy">
          <see langword="true" /> の場合は、現在のテーブルとその子孫の内容を書き込みます。 <see langword="false" /> (既定値) の場合は、現在のテーブルのデータのみを書き込みます。</param>
        <summary>
          <see cref="T:System.Data.DataTable" /> の現在の内容を指定された <see cref="T:System.IO.TextWriter" /> を使用して XML として書き込みます。 テーブルのデータとその子孫をすべて保存するには、<paramref name="writeHierarchy" /> パラメーターを <see langword="true" /> に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> 、いずれかのデータのみを記述する方法またはデータとスキーマの両方からメソッドを提供します、 <xref:System.Data.DataTable> XML ドキュメントに対し、<xref:System.Data.DataTable.WriteXmlSchema%2A>メソッドは、スキーマのみを書き込みます。 データとスキーマの両方を作成するを含むオーバー ロードのいずれかを使用、<xref:System.Data.XmlWriteMode>パラメーターに値を設定および`WriteSchema`します。  
  
 通常、`WriteXml`メソッドは、現在のテーブルのみデータを書き込みます。 現在のテーブルとすべての子孫、関連するテーブルのデータを書き込むでメソッドを呼び出し、`writeHierarchy`パラメーターに設定`true`します。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合、列の型がスローされます、`DataRow`から読み取りまたは実装に書き込まれる<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装しない<xref:System.Xml.Serialization.IXmlSerializable>します。  
  
   
  
## Examples  
 次のコンソール アプリケーションでは、2 つ作成されます<xref:System.Data.DataTable>インスタンスを追加します、 <xref:System.Data.DataSet>、作成、<xref:System.Data.DataRelation>テーブル、および使用して、関連する 2 つ、 <xref:System.Data.DataTable.WriteXml%2A> に親テーブル内のデータを書き込むメソッド<xref:System.IO.TextWriter>. 設定するときに、例を示します、動作、`writeHierarchy`パラメーター`true`します。  
  
 [!code-csharp[DataWorks DataTable.WriteXml#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXml/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXml#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXml/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">ドキュメントを書き込むために使用する <see cref="T:System.IO.TextWriter" />。</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 値のいずれか 1 つ。</param>
        <summary>指定した <see cref="T:System.Data.DataTable" /> と <see cref="T:System.IO.TextWriter" /> を使用して、<see cref="T:System.Data.XmlWriteMode" /> の現在のデータを書き込みます。オプションでスキーマを書き込むこともできます。 スキーマを書き込むには、<paramref name="mode" /> パラメーターの値を <see langword="WriteSchema" /> に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> 、いずれかのデータのみを記述する方法またはデータとスキーマの両方からメソッドを提供します、 <xref:System.Data.DataTable> XML ドキュメントに対し、<xref:System.Data.DataTable.WriteXmlSchema%2A>メソッドは、スキーマのみを書き込みます。 データとスキーマの両方を作成するを含むオーバー ロードのいずれかを使用、<xref:System.Data.XmlWriteMode>パラメーターに値を設定および`WriteSchema`します。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataTable.ReadXml%2A>と<xref:System.Data.DataTable.ReadXmlSchema%2A>メソッドでは、それぞれします。 XML データ、または両方のスキーマとにデータを読み取る、`DataTable`を使用して、`ReadXml`メソッド。 スキーマだけを読み取り、使用、`ReadXmlSchema`メソッド。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合、列の型がスローされます、`DataRow`から読み取りまたは実装に書き込まれる<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装しない<xref:System.Xml.Serialization.IXmlSerializable>します。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * bool -&gt; unit" Usage="dataTable.WriteXml (fileName, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">XML データの書き込み先ファイル。</param>
        <param name="writeHierarchy">
          <see langword="true" /> の場合は、現在のテーブルとその子孫の内容を書き込みます。 <see langword="false" /> (既定値) の場合は、現在のテーブルのデータのみを書き込みます。</param>
        <summary>指定したファイルを使用して <see cref="T:System.Data.DataTable" /> の現在の内容を XML で書き込みます。 テーブルのデータとその子孫をすべて保存するには、<paramref name="writeHierarchy" /> パラメーターを <see langword="true" /> に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> 、いずれかのデータのみを記述する方法またはデータとスキーマの両方からメソッドを提供します、 <xref:System.Data.DataTable> XML ドキュメントに対し、<xref:System.Data.DataTable.WriteXmlSchema%2A>メソッドは、スキーマのみを書き込みます。 データとスキーマの両方を作成するを含むオーバー ロードのいずれかを使用、<xref:System.Data.XmlWriteMode>パラメーターに値を設定および`WriteSchema`します。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataTable.ReadXml%2A>と<xref:System.Data.DataTable.ReadXmlSchema%2A>メソッドでは、それぞれします。 XML データ、または両方のスキーマとにデータを読み取る、`DataTable`を使用して、`ReadXml`メソッド。 スキーマだけを読み取り、使用、`ReadXmlSchema`メソッド。  
  
 通常、`WriteXml`メソッドは、現在のテーブルのみデータを書き込みます。 現在のテーブルとその子孫でのすべてのデータの書き込みに関連するテーブルでメソッドを呼び出し、`writeHierarchy`パラメーターに設定`true`します。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合、列の型がスローされます、`DataRow`から読み取りまたは実装に書き込まれる<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装しない<xref:System.Xml.Serialization.IXmlSerializable>します。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (fileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="fileName">データが書き込まれるファイルの名前。</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 値のいずれか 1 つ。</param>
        <summary>指定したファイルと <see cref="T:System.Data.DataTable" /> を使用して、<see cref="T:System.Data.XmlWriteMode" /> の現在のデータを書き込みます。オプションでスキーマを書き込むこともできます。 スキーマを書き込むには、<paramref name="mode" /> パラメーターの値を <see langword="WriteSchema" /> に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> 、いずれかのデータのみを記述する方法またはデータとスキーマの両方からメソッドを提供します、 <xref:System.Data.DataTable> XML ドキュメントに対し、<xref:System.Data.DataTable.WriteXmlSchema%2A>メソッドは、スキーマのみを書き込みます。 データとスキーマの両方を含むオーバー ロードのいずれかを使用して、<xref:System.Data.XmlWriteMode>パラメーター、その値に設定し、 `WriteSchema`。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataTable.ReadXml%2A>と<xref:System.Data.DataTable.ReadXmlSchema%2A>メソッドでは、それぞれします。 XML データ、または両方のスキーマとにデータを読み取る、`DataTable`を使用して、`ReadXml`メソッド。 スキーマだけを読み取り、使用、`ReadXmlSchema`メソッド。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合、列の型がスローされます、`DataRow`から読み取りまたは実装に書き込まれる<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装しない<xref:System.Xml.Serialization.IXmlSerializable>します。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * bool -&gt; unit" Usage="dataTable.WriteXml (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">内容の書き込みに使用する <see cref="T:System.Xml.XmlWriter" />。</param>
        <param name="writeHierarchy">
          <see langword="true" /> の場合は、現在のテーブルとその子孫の内容を書き込みます。 <see langword="false" /> (既定値) の場合は、現在のテーブルのデータのみを書き込みます。</param>
        <summary>
          <see cref="T:System.Data.DataTable" /> の現在の内容を指定された <see cref="T:System.Xml.XmlWriter" /> を使用して XML として書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> 、いずれかのデータのみを記述する方法またはデータとスキーマの両方からメソッドを提供します、 <xref:System.Data.DataTable> XML ドキュメントに対し、<xref:System.Data.DataTable.WriteXmlSchema%2A>メソッドは、スキーマのみを書き込みます。 データとスキーマの両方を含むオーバー ロードのいずれかを使用して、<xref:System.Data.XmlWriteMode>パラメーター、その値に設定し、 `WriteSchema`。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataTable.ReadXml%2A>と<xref:System.Data.DataTable.ReadXmlSchema%2A>メソッドでは、それぞれします。 XML データ、または両方のスキーマとにデータを読み取る、`DataTable`を使用して、`ReadXml`メソッド。 スキーマだけを読み取り、使用、`ReadXmlSchema`メソッド。  
  
 通常、`WriteXml`メソッドは、現在のテーブルのみデータを書き込みます。 現在のテーブルとその子孫、関連するテーブル全体のデータを書き込むでメソッドを呼び出し、`writeHierarchy`パラメーターに設定`true`します。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合、列の型がスローされます、`DataRow`から読み取りまたは実装に書き込まれる<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装しない<xref:System.Xml.Serialization.IXmlSerializable>します。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">ドキュメントを書き込むために使用する <see cref="T:System.Xml.XmlWriter" />。</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 値のいずれか 1 つ。</param>
        <summary>指定した <see cref="T:System.Data.DataTable" /> と <see cref="T:System.Xml.XmlWriter" /> を使用して、<see cref="T:System.Data.XmlWriteMode" /> の現在のデータを書き込みます。オプションでスキーマを書き込むこともできます。 スキーマを書き込むには、<paramref name="mode" /> パラメーターの値を <see langword="WriteSchema" /> に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> 、いずれかのデータのみを記述する方法またはデータとスキーマの両方からメソッドを提供します、 <xref:System.Data.DataTable> XML ドキュメントに対し、<xref:System.Data.DataTable.WriteXmlSchema%2A>メソッドは、スキーマのみを書き込みます。 データとスキーマの両方を含むオーバー ロードのいずれかを使用して、<xref:System.Data.XmlWriteMode>パラメーター、その値に設定し、 `WriteSchema`。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataTable.ReadXml%2A>と<xref:System.Data.DataTable.ReadXmlSchema%2A>メソッドでは、それぞれします。 XML データ、または両方のスキーマとにデータを読み取る、`DataTable`を使用して、`ReadXml`メソッド。 スキーマだけを読み取り、使用、`ReadXmlSchema`メソッド。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合、列の型がスローされます、`DataRow`から読み取りまたは実装に書き込まれる<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装しない<xref:System.Xml.Serialization.IXmlSerializable>します。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (stream, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">データが書き込まれるストリーム。</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 値のいずれか 1 つ。</param>
        <param name="writeHierarchy">
          <see langword="true" /> の場合は、現在のテーブルとその子孫の内容を書き込みます。 <see langword="false" /> (既定値) の場合は、現在のテーブルのデータのみを書き込みます。</param>
        <summary>指定した <see cref="T:System.Data.DataTable" /> を使用して、<see cref="T:System.Data.XmlWriteMode" /> の現在のデータを、指定したファイルに書き込みます。オプションでスキーマを書き込むこともできます。 スキーマを書き込むには、<paramref name="mode" /> パラメーターの値を <see langword="WriteSchema" /> に設定します。 テーブルのデータとその子孫をすべて保存するには、<paramref name="writeHierarchy" /> パラメーターを <see langword="true" /> に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> 、いずれかのデータのみを記述する方法またはデータとスキーマの両方からメソッドを提供します、 `DataTable` XML ドキュメントに対し、<xref:System.Data.DataTable.WriteXmlSchema%2A>メソッドは、スキーマのみを書き込みます。 データとスキーマの両方を作成するを含むオーバー ロードのいずれかを使用、`XmlWriteMode`パラメーターに値を設定および`WriteSchema`します。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataTable.ReadXml%2A>と<xref:System.Data.DataTable.ReadXmlSchema%2A>メソッドでは、それぞれします。 XML データ、または両方のスキーマとにデータを読み取る、`DataTable`を使用して、`ReadXml`メソッド。 スキーマだけを読み取り、使用、`ReadXmlSchema`メソッド。  
  
 通常、`WriteXml`メソッドは、現在のテーブルに対してのみデータを保存します。 `WriteXml` 、いずれかのデータのみを記述する方法またはデータとスキーマの両方からメソッドを提供します、 `DataTable` XML ドキュメントに対し、`WriteXmlSchema`メソッドは、スキーマのみを書き込みます。 データとスキーマの両方を作成するを含むオーバー ロードのいずれかを使用、`XmlWriteMode`パラメーターに値を設定および`WriteSchema`します。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataTable.ReadXml%2A>と<xref:System.Data.DataTable.ReadXmlSchema%2A>メソッドでは、それぞれします。 XML データ、または両方のスキーマとにデータを読み取る、`DataTable`を使用して、`ReadXml`メソッド。 スキーマだけを読み取り、使用、`ReadXmlSchema`メソッド。  
  
 通常、`WriteXml`メソッドは、現在のテーブルのみデータを書き込みます。 現在のテーブルとその子孫でのすべてのデータの書き込みに関連するテーブルでメソッドを呼び出し、`writeHierarchy`パラメーターに設定`true`します。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合、列の型がスローされます、`DataRow`から読み取りまたは実装に書き込まれる<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装しない<xref:System.Xml.Serialization.IXmlSerializable>します。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (writer, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">ドキュメントを書き込むために使用する <see cref="T:System.IO.TextWriter" />。</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 値のいずれか 1 つ。</param>
        <param name="writeHierarchy">
          <see langword="true" /> の場合は、現在のテーブルとその子孫の内容を書き込みます。 <see langword="false" /> (既定値) の場合は、現在のテーブルのデータのみを書き込みます。</param>
        <summary>指定した <see cref="T:System.Data.DataTable" /> と <see cref="T:System.IO.TextWriter" /> を使用して、<see cref="T:System.Data.XmlWriteMode" /> の現在のデータを書き込みます。オプションでスキーマを書き込むこともできます。 スキーマを書き込むには、<paramref name="mode" /> パラメーターの値を <see langword="WriteSchema" /> に設定します。 テーブルのデータとその子孫をすべて保存するには、<paramref name="writeHierarchy" /> パラメーターを <see langword="true" /> に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> 、いずれかのデータのみを記述する方法またはデータとスキーマの両方からメソッドを提供します、 <xref:System.Data.DataTable> XML ドキュメントに対し、<xref:System.Data.DataTable.WriteXmlSchema%2A>メソッドは、スキーマのみを書き込みます。 データとスキーマの両方を作成するを含むオーバー ロードのいずれかを使用、<xref:System.Data.XmlWriteMode>パラメーターに値を設定および`WriteSchema`します。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataTable.ReadXml%2A>と<xref:System.Data.DataTable.ReadXmlSchema%2A>メソッドでは、それぞれします。 XML データ、または両方のスキーマとにデータを読み取る、`DataTable`を使用して、`ReadXml`メソッド。 スキーマだけを読み取り、使用、`ReadXmlSchema`メソッド。  
  
 通常、`WriteXml`メソッドは、現在のテーブルに対してのみデータを保存します。 <xref:System.Data.DataTable.WriteXml%2A> 、いずれかのデータのみを記述する方法またはデータとスキーマの両方からメソッドを提供します、 <xref:System.Data.DataTable> XML ドキュメントに対し、<xref:System.Data.DataTable.WriteXmlSchema%2A>メソッドは、スキーマのみを書き込みます。 データとスキーマの両方を作成するを含むオーバー ロードのいずれかを使用、<xref:System.Data.XmlWriteMode>パラメーターに値を設定および`WriteSchema`します。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataTable.ReadXml%2A>と<xref:System.Data.DataTable.ReadXmlSchema%2A>メソッドでは、それぞれします。 XML データ、または両方のスキーマとにデータを読み取る、`DataTable`を使用して、`ReadXml`メソッド。 スキーマだけを読み取り、使用、`ReadXmlSchema`メソッド。  
  
 通常、`WriteXml`メソッドは、現在のテーブルのみデータを書き込みます。 現在のテーブルとその子孫でのすべてのデータの書き込みに関連するテーブルでメソッドを呼び出し、`writeHierarchy`パラメーターに設定`true`します。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合、列の型がスローされます、`DataRow`から読み取りまたは実装に書き込まれる<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装しない<xref:System.Xml.Serialization.IXmlSerializable>します。  
  
   
  
## Examples  
 次のコンソール アプリケーションでは、2 つ作成されます<xref:System.Data.DataTable>インスタンスを追加します、 <xref:System.Data.DataSet>、作成、<xref:System.Data.DataRelation>テーブル、および使用して、関連する 2 つ、 <xref:System.Data.DataTable.WriteXml%2A> に親テーブル内のデータを書き込むメソッド<xref:System.IO.TextWriter>. 設定するときに、例を示します、動作、`writeHierarchy`にその値の各パラメーター。  
  
 [!code-csharp[DataWorks DataTable.WriteXmlIO#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlIO/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlIO#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlIO/VB/source.vb#1)]  
  
 この例では、次の出力がコンソール ウィンドウに表示されます。  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
</NewDataSet>  
==============================  
Customer table, with hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
          <xs:element name="Table2">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="OrderID" type="xs:int" />  
                <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
                <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
      <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" m  
sdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="OrderID" />  
      </xs:unique>  
      <xs:keyref name="CustomerOrder" refer="Constraint1">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="CustomerID" />  
      </xs:keyref>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
  <Table2>  
    <OrderID>1</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>2</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>3</OrderID>  
    <CustomerID>2</CustomerID>  
    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>4</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>5</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>6</OrderID>  
    <CustomerID>4</CustomerID>  
    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
</NewDataSet>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (fileName, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">データが書き込まれるファイルの名前。</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 値のいずれか 1 つ。</param>
        <param name="writeHierarchy">
          <see langword="true" /> の場合は、現在のテーブルとその子孫の内容を書き込みます。 <see langword="false" /> (既定値) の場合は、現在のテーブルのデータのみを書き込みます。</param>
        <summary>指定したファイルと <see cref="T:System.Data.DataTable" /> を使用して、<see cref="T:System.Data.XmlWriteMode" /> の現在のデータを書き込みます。オプションでスキーマを書き込むこともできます。 スキーマを書き込むには、<paramref name="mode" /> パラメーターの値を <see langword="WriteSchema" /> に設定します。 テーブルのデータとその子孫をすべて保存するには、<paramref name="writeHierarchy" /> パラメーターを <see langword="true" /> に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> 、いずれかのデータのみを記述する方法またはデータとスキーマの両方からメソッドを提供します、 <xref:System.Data.DataTable> XML ドキュメントに対し、<xref:System.Data.DataTable.WriteXmlSchema%2A>メソッドは、スキーマのみを書き込みます。 データとスキーマの両方を含むオーバー ロードのいずれかを使用して、<xref:System.Data.XmlWriteMode>パラメーター、その値に設定し、 `WriteSchema`。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataTable.ReadXml%2A>と<xref:System.Data.DataTable.ReadXmlSchema%2A>メソッドでは、それぞれします。 XML データ、または両方のスキーマとにデータを読み取る、`DataTable`を使用して、`ReadXml`メソッド。 スキーマだけを読み取り、使用、`ReadXmlSchema`メソッド。  
  
 通常、`WriteXml`メソッドは、現在のテーブルに対してのみデータを保存します。 現在のテーブルとスキーマのすべてのデータを保存する場合、<xref:System.Data.DataTable.WriteXml%2A>メソッドを提供するいずれかのデータのみを記述する方法またはデータとスキーマの両方から、 <xref:System.Data.DataTable> XML ドキュメントには、<xref:System.Data.DataTable.WriteXmlSchema%2A>メソッドは、スキーマのみを書き込みます。 データとスキーマの両方を含むオーバー ロードのいずれかを使用して、<xref:System.Data.XmlWriteMode>パラメーター、その値に設定し、 `WriteSchema`。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataTable.ReadXml%2A>と<xref:System.Data.DataTable.ReadXmlSchema%2A>メソッドでは、それぞれします。 XML データ、または両方のスキーマとにデータを読み取る、`DataTable`を使用して、`ReadXml`メソッド。 スキーマだけを読み取り、使用、`ReadXmlSchema`メソッド。  
  
 通常、`WriteXml`メソッドは、現在のテーブルのみデータを書き込みます。 現在のテーブルとすべての子孫、関連するテーブルのデータを書き込むでメソッドを呼び出し、`writeHierarchy`パラメーターに設定`true`します。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合、列の型がスローされます、`DataRow`から読み取りまたは実装に書き込まれる<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装しない<xref:System.Xml.Serialization.IXmlSerializable>します。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (writer, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">ドキュメントを書き込むために使用する <see cref="T:System.Xml.XmlWriter" />。</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 値のいずれか 1 つ。</param>
        <param name="writeHierarchy">
          <see langword="true" /> の場合は、現在のテーブルとその子孫の内容を書き込みます。 <see langword="false" /> (既定値) の場合は、現在のテーブルのデータのみを書き込みます。</param>
        <summary>指定した <see cref="T:System.Data.DataTable" /> と <see cref="T:System.Xml.XmlWriter" /> を使用して、<see cref="T:System.Data.XmlWriteMode" /> の現在のデータを書き込みます。オプションでスキーマを書き込むこともできます。 スキーマを書き込むには、<paramref name="mode" /> パラメーターの値を <see langword="WriteSchema" /> に設定します。 テーブルのデータとその子孫をすべて保存するには、<paramref name="writeHierarchy" /> パラメーターを <see langword="true" /> に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> 、いずれかのデータのみを記述する方法またはデータとスキーマの両方からメソッドを提供します、 <xref:System.Data.DataTable> XML ドキュメントに対し、<xref:System.Data.DataTable.WriteXmlSchema%2A>メソッドは、スキーマのみを書き込みます。 データとスキーマの両方を含むオーバー ロードのいずれかを使用して、<xref:System.Data.XmlWriteMode>パラメーター、その値に設定し、 `WriteSchema`。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataTable.ReadXml%2A>と<xref:System.Data.DataTable.ReadXmlSchema%2A>メソッドでは、それぞれします。 XML データ、または両方のスキーマとにデータを読み取る、`DataTable`を使用して、`ReadXml`メソッド。 スキーマだけを読み取り、使用、`ReadXmlSchema`メソッド。  
  
 通常、`WriteXml`メソッドは、現在のテーブルのみデータを書き込みます。 現在のテーブルとその子孫、関連するテーブル全体のデータを書き込むでメソッドを呼び出し、`writeHierarchy`パラメーターに設定`true`します。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合、列の型がスローされます、`DataRow`から読み取りまたは実装に書き込まれる<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装しない<xref:System.Xml.Serialization.IXmlSerializable>します。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataTable" /> の現在のデータ構造体を XML スキーマとして書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Data.DataTable.WriteXmlSchema%2A>のスキーマを記述するメソッド、 <xref:System.Data.DataTable> XML ドキュメントにします。 スキーマには、テーブル、リレーションシップ、および制約の定義が含まれます。  
  
 XML スキーマでは、XSD 標準を使用して書き込まれます。  
  
 XML ドキュメントに、データの書き込みに使用して、<xref:System.Data.DataTable.WriteXml%2A>メソッド。  
  
   
  
## Examples  
 次のコンソール アプリケーションでは、2 つ作成されます<xref:System.Data.DataTable>インスタンスを追加します、 <xref:System.Data.DataSet>、作成、<xref:System.Data.DataRelation>テーブル、および使用して、関連する 2 つ、 <xref:System.Data.DataTable.WriteXmlSchema%2A> に親テーブル内のデータを書き込むメソッド<xref:System.IO.TextWriter>. 設定するときに、例を示します、動作、`writeHierarchy`にその値の各パラメーター。  
  
> [!NOTE]
>  この例は、のいずれかのオーバー ロードされたバージョンを使用する方法を示します`WriteXmlSchema`、使用可能な可能性があるその他の例は、個々 のオーバー ロードのトピックを参照してください。  
  
 [!code-csharp[DataWorks DataTable.WriteXmlSchemaOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchemaOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlSchemaOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchemaOverload/VB/source.vb#1)]  
  
 この例では、次の出力がコンソール ウィンドウに表示されます。  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Ta  
ble1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
  </xs:element>  
</xs:schema>  
==============================  
Customer table, with hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
        <xs:element name="Table2">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="OrderID" type="xs:int" />  
              <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
              <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
    <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="OrderID" />  
    </xs:unique>  
    <xs:keyref name="CustomerOrder" refer="Constraint1">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="CustomerID" />  
    </xs:keyref>  
  </xs:element>  
</xs:schema>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream -&gt; unit" Usage="dataTable.WriteXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">XML スキーマが書き込まれるストリーム。</param>
        <summary>
          <see cref="T:System.Data.DataTable" /> の現在のデータ構造体を指定されたストリームに XML スキーマとして書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Data.DataTable.WriteXmlSchema%2A>のスキーマを記述するメソッド、 <xref:System.Data.DataTable> XML ドキュメントにします。 スキーマには、テーブル、リレーションシップ、および制約の定義が含まれます。  
  
 XML スキーマでは、XSD 標準を使用して書き込まれます。  
  
 XML ドキュメントに、データの書き込みに使用して、<xref:System.Data.DataTable.WriteXml%2A>メソッド。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter -&gt; unit" Usage="dataTable.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">書き込みに使用する <see cref="T:System.IO.TextWriter" />。</param>
        <summary>指定した <see cref="T:System.Data.DataTable" /> を使用して、<see cref="T:System.IO.TextWriter" /> の現在のデータ構造体を XML スキーマとして書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Data.DataTable.WriteXmlSchema%2A>のスキーマを記述するメソッド、 <xref:System.Data.DataTable> XML ドキュメントにします。 スキーマには、テーブル、リレーションシップ、および制約の定義が含まれます。  
  
 XML スキーマでは、XSD 標準を使用して書き込まれます。  
  
 XML ドキュメントに、データの書き込みに使用して、<xref:System.Data.DataTable.WriteXml%2A>メソッド。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string -&gt; unit" Usage="dataTable.WriteXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">使用するファイルの名前。</param>
        <summary>
          <see cref="T:System.Data.DataTable" /> の現在のデータ構造体を指定されたファイルに XML スキーマとして書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Data.DataTable.WriteXmlSchema%2A>のスキーマを記述するメソッド、 <xref:System.Data.DataTable> XML ドキュメントにします。 スキーマには、テーブル、リレーションシップ、および制約の定義が含まれます。  
  
 XML スキーマでは、XSD 標準を使用して書き込まれます。  
  
 XML ドキュメントに、データの書き込みに使用して、<xref:System.Data.DataTable.WriteXml%2A>メソッド。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter -&gt; unit" Usage="dataTable.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">使用する <see cref="T:System.Xml.XmlWriter" />。</param>
        <summary>指定した <see cref="T:System.Data.DataTable" /> を使用して、<see cref="T:System.Xml.XmlWriter" /> の現在のデータ構造体を XML スキーマとして書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Data.DataTable.WriteXmlSchema%2A>のスキーマを記述するメソッド、 <xref:System.Data.DataTable> XML ドキュメントにします。 スキーマには、テーブル、リレーションシップ、および制約の定義が含まれます。  
  
 XML スキーマでは、XSD 標準を使用して書き込まれます。  
  
 XML ドキュメントに、データの書き込みに使用して、<xref:System.Data.DataTable.WriteXml%2A>メソッド。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (stream, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">XML スキーマが書き込まれるストリーム。</param>
        <param name="writeHierarchy">
          <see langword="true" /> の場合は、現在のテーブルとその子孫のスキーマを書き込みます。 <see langword="false" /> (既定値) の場合は、現在のテーブルのスキーマのみを書き込みます。</param>
        <summary>
          <see cref="T:System.Data.DataTable" /> の現在のデータ構造体を指定されたストリームに XML スキーマとして書き込みます。 テーブルのスキーマとその子孫をすべて保存するには、<paramref name="writeHierarchy" /> パラメーターを <see langword="true" /> に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Data.DataTable.WriteXmlSchema%2A>のスキーマを記述するメソッド、 <xref:System.Data.DataTable> XML ドキュメントにします。 スキーマには、テーブル、リレーションシップ、および制約の定義が含まれます。  
  
 XML スキーマでは、XSD 標準を使用して書き込まれます。  
  
 XML ドキュメントに、データの書き込みに使用して、<xref:System.Data.DataTable.WriteXml%2A>メソッド。  
  
 通常、`WriteXmlSchema`メソッドは、現在のテーブルのみのスキーマを書き込みます。 現在のテーブルとその全体の子孫、関連するテーブルのスキーマを書き込むでメソッドを呼び出し、`writeHierarchy`パラメーターに設定`true`。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">書き込みに使用する <see cref="T:System.IO.TextWriter" />。</param>
        <param name="writeHierarchy">
          <see langword="true" /> の場合は、現在のテーブルとその子孫のスキーマを書き込みます。 <see langword="false" /> (既定値) の場合は、現在のテーブルのスキーマのみを書き込みます。</param>
        <summary>指定した <see cref="T:System.Data.DataTable" /> を使用して、<see cref="T:System.IO.TextWriter" /> の現在のデータ構造体を XML スキーマとして書き込みます。 テーブルのスキーマとその子孫をすべて保存するには、<paramref name="writeHierarchy" /> パラメーターを <see langword="true" /> に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Data.DataTable.WriteXmlSchema%2A>のスキーマを記述するメソッド、 <xref:System.Data.DataTable> XML ドキュメントにします。 スキーマには、テーブル、リレーションシップ、および制約の定義が含まれます。  
  
 XML スキーマでは、XSD 標準を使用して書き込まれます。  
  
 XML ドキュメントに、データの書き込みに使用して、<xref:System.Data.DataTable.WriteXml%2A>メソッド。  
  
 通常、`WriteXmlSchema`メソッドは、現在のテーブルのみのスキーマを書き込みます。 現在のテーブルとその全体の子孫、関連するテーブルのスキーマを書き込むでメソッドを呼び出し、`writeHierarchy`パラメーターに設定`true`。  
  
   
  
## Examples  
 次のコンソール アプリケーションでは、2 つ作成されます<xref:System.Data.DataTable>インスタンスを追加します、 <xref:System.Data.DataSet>、作成、<xref:System.Data.DataRelation>テーブル、および使用して、関連する 2 つ、 <xref:System.Data.DataTable.WriteXmlSchema%2A> に親テーブル内のデータを書き込むメソッド<xref:System.IO.TextWriter>. 設定するときに、例を示します、動作、`writeHierarchy`にその値の各パラメーター。  
  
 [!code-csharp[DataWorks DataTable.WriteXmlSchema#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchema/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlSchema#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchema/VB/source.vb#1)]  
  
 この例では、次の出力がコンソール ウィンドウに表示されます。  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Ta  
ble1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
  </xs:element>  
</xs:schema>  
==============================  
Customer table, with hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
        <xs:element name="Table2">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="OrderID" type="xs:int" />  
              <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
              <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
    <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="OrderID" />  
    </xs:unique>  
    <xs:keyref name="CustomerOrder" refer="Constraint1">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="CustomerID" />  
    </xs:keyref>  
  </xs:element>  
</xs:schema>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (fileName, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">使用するファイルの名前。</param>
        <param name="writeHierarchy">
          <see langword="true" /> の場合は、現在のテーブルとその子孫のスキーマを書き込みます。 <see langword="false" /> (既定値) の場合は、現在のテーブルのスキーマのみを書き込みます。</param>
        <summary>
          <see cref="T:System.Data.DataTable" /> の現在のデータ構造体を指定されたファイルに XML スキーマとして書き込みます。 テーブルのスキーマとその子孫をすべて保存するには、<paramref name="writeHierarchy" /> パラメーターを <see langword="true" /> に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Data.DataTable.WriteXmlSchema%2A>のスキーマを記述するメソッド、 <xref:System.Data.DataTable> XML ドキュメントにします。 スキーマには、テーブル、リレーションシップ、および制約の定義が含まれます。  
  
 XML スキーマでは、XSD 標準を使用して書き込まれます。  
  
 XML ドキュメントに、データの書き込みに使用して、<xref:System.Data.DataTable.WriteXml%2A>メソッド。  
  
 通常、`WriteXmlSchema`メソッドは、現在のテーブルのみのスキーマを書き込みます。 現在のテーブルとその全体の子孫、関連するテーブルのスキーマを書き込むでメソッドを呼び出し、`writeHierarchy`パラメーターに設定`true`。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">ドキュメントを書き込むために使用する <see cref="T:System.Xml.XmlWriter" />。</param>
        <param name="writeHierarchy">
          <see langword="true" /> の場合は、現在のテーブルとその子孫のスキーマを書き込みます。 <see langword="false" /> (既定値) の場合は、現在のテーブルのスキーマのみを書き込みます。</param>
        <summary>指定した <see cref="T:System.Data.DataTable" /> を使用して、<see cref="T:System.Xml.XmlWriter" /> の現在のデータ構造体を XML スキーマとして書き込みます。 テーブルのスキーマとその子孫をすべて保存するには、<paramref name="writeHierarchy" /> パラメーターを <see langword="true" /> に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Data.DataTable.WriteXmlSchema%2A>のスキーマを記述するメソッド、 <xref:System.Data.DataTable> XML ドキュメントにします。 スキーマには、テーブル、リレーションシップ、および制約の定義が含まれます。  
  
 XML スキーマでは、XSD 標準を使用して書き込まれます。  
  
 XML ドキュメントに、データの書き込みに使用して、<xref:System.Data.DataTable.WriteXml%2A>メソッド。  
  
 通常、`WriteXmlSchema`メソッドは、現在のテーブルのみのスキーマを書き込みます。 現在のテーブルとその全体の子孫、関連するテーブルのスキーマを書き込むでメソッドを呼び出し、`writeHierarchy`パラメーターに設定`true`。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">作成とデータ テーブルの使用</related>
      </Docs>
    </Member>
  </Members>
</Type>